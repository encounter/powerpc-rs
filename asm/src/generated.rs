#![allow(unused)]
#![cfg_attr(rustfmt, rustfmt_skip)]
// Code generated by ppc750-genisa. DO NOT EDIT.
use crate::types::*;
pub type Arguments = [Argument; 5];
fn gen_add(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000214 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_addc(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000014 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_adde(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000114 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_addi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x38000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 2, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_addic(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x30000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 2, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_addic_(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x34000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 2, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_addis(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x3c000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // uimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0xffff)?;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_addme(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0001d4 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_addze(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c000194 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_and(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000038 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_andc(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000078 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_andi_(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x70000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // uimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0xffff)?;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_andis_(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x74000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // uimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0xffff)?;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_b(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x48000000 | modifiers;
    // LI
    {
        let arg = parse_signed(args, 0, -0x2000000, 0x2000000)? as u32;
        code |= arg & 0x3fffffc;
    }
    Ok(code)
}
fn gen_bc(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x40000000 | modifiers;
    // BO
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // BI
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // BD
    {
        let arg = parse_signed(args, 2, -0x8000, 0x8000)? as u32;
        code |= arg & 0xfffc;
    }
    Ok(code)
}
fn gen_bcctr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x4c000420 | modifiers;
    // BO
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // BI
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_bclr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x4c000020 | modifiers;
    // BO
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // BI
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_bctr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x4e800420 | modifiers;
    Ok(code)
}
fn gen_bdnz(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x42000000 | modifiers;
    // BD
    {
        let arg = parse_signed(args, 0, -0x8000, 0x8000)? as u32;
        code |= arg & 0xfffc;
    }
    Ok(code)
}
fn gen_bdnzf(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x40000000 | modifiers;
    // BI
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // BD
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xfffc;
    }
    Ok(code)
}
fn gen_bdnzflr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x4c000020 | modifiers;
    // BI
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_bdnzlr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x4e000020 | modifiers;
    Ok(code)
}
fn gen_bdnzt(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x41000000 | modifiers;
    // BI
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // BD
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xfffc;
    }
    Ok(code)
}
fn gen_bdnztlr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x4d000020 | modifiers;
    // BI
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_bdz(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x42400000 | modifiers;
    // BD
    {
        let arg = parse_signed(args, 0, -0x8000, 0x8000)? as u32;
        code |= arg & 0xfffc;
    }
    Ok(code)
}
fn gen_bdzf(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x40400000 | modifiers;
    // BI
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // BD
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xfffc;
    }
    Ok(code)
}
fn gen_bdzflr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x4c000020 | modifiers;
    // BI
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_bdzlr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x4e400020 | modifiers;
    Ok(code)
}
fn gen_bdzt(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x41400000 | modifiers;
    // BI
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // BD
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xfffc;
    }
    Ok(code)
}
fn gen_bdztlr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x4d400020 | modifiers;
    // BI
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_beq(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        1 => {
            let mut code = 0x41820000 | modifiers;
            // BD
            {
                let arg = parse_signed(args, 0, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        2 => {
            let mut code = 0x41820000 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            // BD
            {
                let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 2,
            })
        }
    }
}
fn gen_beqctr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4d820420 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4d820420 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_beqlr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4d820020 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4d820020 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_bge(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        1 => {
            let mut code = 0x40800000 | modifiers;
            // BD
            {
                let arg = parse_signed(args, 0, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        2 => {
            let mut code = 0x40800000 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            // BD
            {
                let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 2,
            })
        }
    }
}
fn gen_bgectr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4c800420 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4c800420 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_bgelr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4c800020 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4c800020 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_bgt(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        1 => {
            let mut code = 0x41810000 | modifiers;
            // BD
            {
                let arg = parse_signed(args, 0, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        2 => {
            let mut code = 0x41810000 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            // BD
            {
                let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 2,
            })
        }
    }
}
fn gen_bgtctr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4d810420 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4d810420 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_bgtlr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4d810020 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4d810020 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_ble(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        1 => {
            let mut code = 0x40810000 | modifiers;
            // BD
            {
                let arg = parse_signed(args, 0, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        2 => {
            let mut code = 0x40810000 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            // BD
            {
                let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 2,
            })
        }
    }
}
fn gen_blectr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4c810420 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4c810420 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_blelr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4c810020 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4c810020 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_blr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x4e800020 | modifiers;
    Ok(code)
}
fn gen_blt(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        1 => {
            let mut code = 0x41800000 | modifiers;
            // BD
            {
                let arg = parse_signed(args, 0, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        2 => {
            let mut code = 0x41800000 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            // BD
            {
                let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 2,
            })
        }
    }
}
fn gen_bltctr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4d800420 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4d800420 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_bltlr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4d800020 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4d800020 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_bne(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        1 => {
            let mut code = 0x40820000 | modifiers;
            // BD
            {
                let arg = parse_signed(args, 0, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        2 => {
            let mut code = 0x40820000 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            // BD
            {
                let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 2,
            })
        }
    }
}
fn gen_bnectr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4c820420 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4c820420 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_bnelr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4c820020 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4c820020 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_bns(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        1 => {
            let mut code = 0x40830000 | modifiers;
            // BD
            {
                let arg = parse_signed(args, 0, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        2 => {
            let mut code = 0x40830000 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            // BD
            {
                let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 2,
            })
        }
    }
}
fn gen_bnsctr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4c830420 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4c830420 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_bnslr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4c830020 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4c830020 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_bso(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        1 => {
            let mut code = 0x41830000 | modifiers;
            // BD
            {
                let arg = parse_signed(args, 0, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        2 => {
            let mut code = 0x41830000 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            // BD
            {
                let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
                code |= arg & 0xfffc;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 2,
            })
        }
    }
}
fn gen_bsoctr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4d830420 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4d830420 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_bsolr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        0 => {
            let mut code = 0x4d830020 | modifiers;
            Ok(code)
        }
        1 => {
            let mut code = 0x4d830020 | modifiers;
            // crfS
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 18;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_clrlslwi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x54000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // MB
    {
        let arg = (parse_unsigned(args, 2, 0x0, 0x1f)?
            - parse_unsigned(args, 3, 0x0, 0x1f)?);
        code |= (arg & 0x1f) << 6;
    }
    // SH
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // ME
    {
        let arg = (31 - parse_unsigned(args, 3, 0x0, 0x1f)?);
        code |= (arg & 0x1f) << 1;
    }
    Ok(code)
}
fn gen_clrlwi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x5400003e | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // MB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_clrrwi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x54000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // ME
    {
        let arg = (31 - parse_unsigned(args, 2, 0x0, 0x1f)?);
        code |= (arg & 0x1f) << 1;
    }
    Ok(code)
}
fn gen_cmp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x7c000000 | modifiers;
    // crfD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
        code |= (arg & 0x7) << 23;
    }
    // L
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1)?;
        code |= (arg & 0x1) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_cmpd(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        2 => {
            let mut code = 0x7c200000 | modifiers;
            // rA
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // rB
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 11;
            }
            Ok(code)
        }
        3 => {
            let mut code = 0x7c200000 | modifiers;
            // crfD
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 23;
            }
            // rA
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // rB
            {
                let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 11;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 3,
            })
        }
    }
}
fn gen_cmpdi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        2 => {
            let mut code = 0x2c200000 | modifiers;
            // rA
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // simm
            {
                let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
                code |= arg & 0xffff;
            }
            Ok(code)
        }
        3 => {
            let mut code = 0x2c200000 | modifiers;
            // crfD
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 23;
            }
            // rA
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // simm
            {
                let arg = parse_signed(args, 2, -0x8000, 0x8000)? as u32;
                code |= arg & 0xffff;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 3,
            })
        }
    }
}
fn gen_cmpi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x2c000000 | modifiers;
    // crfD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
        code |= (arg & 0x7) << 23;
    }
    // L
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1)?;
        code |= (arg & 0x1) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 3, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_cmpl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x7c000040 | modifiers;
    // crfD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
        code |= (arg & 0x7) << 23;
    }
    // L
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1)?;
        code |= (arg & 0x1) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_cmpld(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        2 => {
            let mut code = 0x7c200040 | modifiers;
            // rA
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // rB
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 11;
            }
            Ok(code)
        }
        3 => {
            let mut code = 0x7c200040 | modifiers;
            // crfD
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 23;
            }
            // rA
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // rB
            {
                let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 11;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 3,
            })
        }
    }
}
fn gen_cmpldi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        2 => {
            let mut code = 0x28200000 | modifiers;
            // rA
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // uimm
            {
                let arg = parse_unsigned(args, 1, 0x0, 0xffff)?;
                code |= arg & 0xffff;
            }
            Ok(code)
        }
        3 => {
            let mut code = 0x28200000 | modifiers;
            // crfD
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 23;
            }
            // rA
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // uimm
            {
                let arg = parse_unsigned(args, 2, 0x0, 0xffff)?;
                code |= arg & 0xffff;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 3,
            })
        }
    }
}
fn gen_cmpli(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x28000000 | modifiers;
    // crfD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
        code |= (arg & 0x7) << 23;
    }
    // L
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1)?;
        code |= (arg & 0x1) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // uimm
    {
        let arg = parse_unsigned(args, 3, 0x0, 0xffff)?;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_cmplw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        2 => {
            let mut code = 0x7c000040 | modifiers;
            // rA
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // rB
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 11;
            }
            Ok(code)
        }
        3 => {
            let mut code = 0x7c000040 | modifiers;
            // crfD
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 23;
            }
            // rA
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // rB
            {
                let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 11;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 3,
            })
        }
    }
}
fn gen_cmplwi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        2 => {
            let mut code = 0x28000000 | modifiers;
            // rA
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // uimm
            {
                let arg = parse_unsigned(args, 1, 0x0, 0xffff)?;
                code |= arg & 0xffff;
            }
            Ok(code)
        }
        3 => {
            let mut code = 0x28000000 | modifiers;
            // crfD
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 23;
            }
            // rA
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // uimm
            {
                let arg = parse_unsigned(args, 2, 0x0, 0xffff)?;
                code |= arg & 0xffff;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 3,
            })
        }
    }
}
fn gen_cmpw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        2 => {
            let mut code = 0x7c000000 | modifiers;
            // rA
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // rB
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 11;
            }
            Ok(code)
        }
        3 => {
            let mut code = 0x7c000000 | modifiers;
            // crfD
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 23;
            }
            // rA
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // rB
            {
                let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 11;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 3,
            })
        }
    }
}
fn gen_cmpwi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        2 => {
            let mut code = 0x2c000000 | modifiers;
            // rA
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // simm
            {
                let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
                code |= arg & 0xffff;
            }
            Ok(code)
        }
        3 => {
            let mut code = 0x2c000000 | modifiers;
            // crfD
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
                code |= (arg & 0x7) << 23;
            }
            // rA
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
                code |= (arg & 0x1f) << 16;
            }
            // simm
            {
                let arg = parse_signed(args, 2, -0x8000, 0x8000)? as u32;
                code |= arg & 0xffff;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 3,
            })
        }
    }
}
fn gen_cntlzd(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c000074 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_cntlzw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c000034 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_crand(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x4c000202 | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // crbA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // crbB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_crandc(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x4c000102 | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // crbA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // crbB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_crclr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x4c000182 | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // crbA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // crbB
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_creqv(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x4c000242 | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // crbA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // crbB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_crmove(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x4c000382 | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // crbA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // crbB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_crnand(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x4c0001c2 | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // crbA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // crbB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_crnor(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x4c000042 | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // crbA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // crbB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_crnot(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x4c000042 | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // crbA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // crbB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_cror(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x4c000382 | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // crbA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // crbB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_crorc(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x4c000342 | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // crbA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // crbB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_crset(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x4c000242 | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // crbA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // crbB
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_crxor(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x4c000182 | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // crbA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // crbB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_dcbf(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0000ac | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_dcbi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0003ac | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_dcbst(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c00006c | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_dcbt(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c00022c | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_dcbtst(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0001ec | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_dcbz(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0007ec | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_dcbz_l(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x100007ec | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_divd(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0003d2 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_divdu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000392 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_divw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0003d6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_divwu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000396 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_dss(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        2 => {
            let mut code = 0x7c00066c | modifiers;
            // STRM
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x3)?;
                code |= (arg & 0x3) << 21;
            }
            // ds_A
            {
                let arg = parse_unsigned(args, 1, 0x0, 0x1)?;
                code |= (arg & 0x1) << 25;
            }
            Ok(code)
        }
        1 => {
            let mut code = 0x7c00066c | modifiers;
            // STRM
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x3)?;
                code |= (arg & 0x3) << 21;
            }
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 2,
            })
        }
    }
}
fn gen_dssall(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x7e00066c | modifiers;
    Ok(code)
}
fn gen_dst(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0002ac | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // STRM
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x3)?;
        code |= (arg & 0x3) << 21;
    }
    Ok(code)
}
fn gen_dstst(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0002ec | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // STRM
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x3)?;
        code |= (arg & 0x3) << 21;
    }
    Ok(code)
}
fn gen_eciwx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00026c | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_ecowx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00036c | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_eieio(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x7c0006ac | modifiers;
    Ok(code)
}
fn gen_eqv(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000238 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_extlwi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x54000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // ME
    {
        let arg = (parse_unsigned(args, 2, 0x0, 0x1f)? - 1);
        code |= (arg & 0x1f) << 1;
    }
    // SH
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_extrwi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x5400003e | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // MB
    {
        let arg = (32 - parse_unsigned(args, 2, 0x0, 0x1f)?);
        code |= (arg & 0x1f) << 6;
    }
    // SH
    {
        let arg = (parse_unsigned(args, 3, 0x0, 0x1f)?
            + parse_unsigned(args, 2, 0x0, 0x1f)?);
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_extsb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c000774 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_extsh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c000734 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_extsw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0007b4 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_fabs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc000210 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fadd(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xfc00002a | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fadds(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xec00002a | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fcfid(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc00069c | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fcmpo(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xfc000040 | modifiers;
    // crfD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
        code |= (arg & 0x7) << 23;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fcmpu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xfc000000 | modifiers;
    // crfD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
        code |= (arg & 0x7) << 23;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fctid(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc00065c | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fctidz(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc00065e | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fctiw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc00001c | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fctiwz(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc00001e | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fdiv(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xfc000024 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fdivs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xec000024 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fmadd(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0xfc00003a | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // frB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fmadds(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0xec00003a | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // frB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fmr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc000090 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fmsub(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0xfc000038 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // frB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fmsubs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0xec000038 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // frB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fmul(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xfc000032 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_fmuls(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xec000032 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_fnabs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc000110 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fneg(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc000050 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fnmadd(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0xfc00003e | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // frB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fnmadds(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0xec00003e | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // frB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fnmsub(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0xfc00003c | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // frB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fnmsubs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0xec00003c | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // frB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fres(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xec000030 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_frsp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc000018 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_frsqrte(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc000034 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fsel(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0xfc00002e | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // frB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fsub(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xfc000028 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_fsubs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xec000028 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // frA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // frB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_icbi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0007ac | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_isync(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x4c00012c | modifiers;
    Ok(code)
}
fn gen_lbz(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x88000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lbzu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x8c000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lbzux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0000ee | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lbzx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0000ae | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_ld(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xe8000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // ds
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xfffc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_ldarx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0000a8 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_ldu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xe8000001 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // ds
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xfffc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_ldux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00006a | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_ldx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00002a | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lfd(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xc8000000 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lfdu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xcc000000 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lfdux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0004ee | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lfdx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0004ae | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lfs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xc0000000 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lfsu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xc4000000 | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lfsux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00046e | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lfsx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00042e | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lha(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xa8000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lhau(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xac000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lhaux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0002ee | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lhax(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0002ae | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lhbrx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00062c | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lhz(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xa0000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lhzu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xa4000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lhzux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00026e | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lhzx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00022e | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_li(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x38000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // simm
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_lis(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x3c000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // uimm
    {
        let arg = parse_unsigned(args, 1, 0x0, 0xffff)?;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_lmw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xb8000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lswi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0004aa | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // NB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lswx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00042a | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvebx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00000e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvehx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00004e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvewx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00008e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvewx128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000083 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvlx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00040e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvlx128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000403 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvlxl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00060e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvlxl128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000603 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvrx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00044e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvrx128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000443 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvrxl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00064e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvrxl128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000643 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvsl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00000c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvsl128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000003 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvsr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00004c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvsr128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000043 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0000ce | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvx128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100000c3 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvxl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0002ce | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lvxl128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100002c3 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lwa(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xe8000002 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // ds
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xfffc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lwarx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000028 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lwaux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0002ea | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lwax(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0002aa | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lwbrx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00042c | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lwsync(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x7c2004ac | modifiers;
    Ok(code)
}
fn gen_lwz(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x80000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lwzu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x84000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_lwzux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00006e | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_lwzx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00002e | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_mcrf(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x4c000000 | modifiers;
    // crfD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
        code |= (arg & 0x7) << 23;
    }
    // crfS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7)?;
        code |= (arg & 0x7) << 18;
    }
    Ok(code)
}
fn gen_mcrfs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc000080 | modifiers;
    // crfD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
        code |= (arg & 0x7) << 23;
    }
    // crfS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7)?;
        code |= (arg & 0x7) << 18;
    }
    Ok(code)
}
fn gen_mcrxr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c000400 | modifiers;
    // crfD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
        code |= (arg & 0x7) << 23;
    }
    Ok(code)
}
fn gen_mfcr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c000026 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mfctr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c0902a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mfdar(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1302a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mfdbatl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c1982a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // spr_BAT
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x3)?;
        code |= (arg & 0x3) << 17;
    }
    Ok(code)
}
fn gen_mfdbatu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c1882a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // spr_BAT
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x3)?;
        code |= (arg & 0x3) << 17;
    }
    Ok(code)
}
fn gen_mfdec(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1602a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mfdsisr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1202a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mfear(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1a42a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mffs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0xfc00048e | modifiers;
    // frD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mfibatl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c1182a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // spr_BAT
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x3)?;
        code |= (arg & 0x3) << 17;
    }
    Ok(code)
}
fn gen_mfibatu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c1082a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // spr_BAT
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x3)?;
        code |= (arg & 0x3) << 17;
    }
    Ok(code)
}
fn gen_mflr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c0802a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mfmsr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c0000a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mfsdr1(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1902a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mfspr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0002a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // spr
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x3ff)?;
        code |= (arg & 0x1f) << 16;
        code |= (arg & 0x3e0) << 6;
    }
    Ok(code)
}
fn gen_mfsprg(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c1042a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // spr_SPRG
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x3)?;
        code |= (arg & 0x3) << 16;
    }
    Ok(code)
}
fn gen_mfsr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0004a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // sr
    {
        let arg = parse_unsigned(args, 1, 0x0, 0xf)?;
        code |= (arg & 0xf) << 16;
    }
    Ok(code)
}
fn gen_mfsrin(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c000526 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_mfsrr0(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1a02a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mfsrr1(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1b02a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mftb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0002e6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // tbr
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x3ff)?;
        code |= (arg & 0x1f) << 16;
        code |= (arg & 0x3e0) << 6;
    }
    Ok(code)
}
fn gen_mfvscr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x10000604 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mfxer(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c0102a6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c000378 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_mtcrf(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c000120 | modifiers;
    // crm
    {
        let arg = parse_unsigned(args, 0, 0x0, 0xff)?;
        code |= (arg & 0xff) << 12;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtctr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c0903a6 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtdar(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1303a6 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtdbatl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c1983a6 | modifiers;
    // spr_BAT
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x3)?;
        code |= (arg & 0x3) << 17;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtdbatu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c1883a6 | modifiers;
    // spr_BAT
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x3)?;
        code |= (arg & 0x3) << 17;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtdec(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1603a6 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtdsisr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1203a6 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtear(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1a43a6 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtfsb0(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0xfc00008c | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtfsb1(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0xfc00004c | modifiers;
    // crbD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtfsf(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc00058e | modifiers;
    // mtfsf_FM
    {
        let arg = parse_unsigned(args, 0, 0x0, 0xff)?;
        code |= (arg & 0xff) << 17;
    }
    // frB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_mtfsfi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfc00010c | modifiers;
    // crfD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7)?;
        code |= (arg & 0x7) << 23;
    }
    // mtfsf_IMM
    {
        let arg = parse_unsigned(args, 1, 0x0, 0xf)?;
        code |= (arg & 0xf) << 12;
    }
    Ok(code)
}
fn gen_mtibatl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c1183a6 | modifiers;
    // spr_BAT
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x3)?;
        code |= (arg & 0x3) << 17;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtibatu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c1083a6 | modifiers;
    // spr_BAT
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x3)?;
        code |= (arg & 0x3) << 17;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtlr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c0803a6 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtmsr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c000124 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtmsrd(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c000164 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // mtmsrd_L
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1)?;
        code |= (arg & 0x1) << 16;
    }
    Ok(code)
}
fn gen_mtsdr1(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1903a6 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtspr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0003a6 | modifiers;
    // spr
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x3ff)?;
        code |= (arg & 0x1f) << 16;
        code |= (arg & 0x3e0) << 6;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtsprg(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c1043a6 | modifiers;
    // spr_SPRG
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x3)?;
        code |= (arg & 0x3) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtsr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0001a4 | modifiers;
    // sr
    {
        let arg = parse_unsigned(args, 0, 0x0, 0xf)?;
        code |= (arg & 0xf) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtsrd(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0000a4 | modifiers;
    // sr
    {
        let arg = parse_unsigned(args, 0, 0x0, 0xf)?;
        code |= (arg & 0xf) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtsrdin(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0000e4 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_mtsrin(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0001e4 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_mtsrr0(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1a03a6 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtsrr1(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1b03a6 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mttbl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1c43a6 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mttbu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c1d43a6 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mtvscr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x10000644 | modifiers;
    // vB
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_mtxer(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c0103a6 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    Ok(code)
}
fn gen_mulhd(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000092 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_mulhdu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000012 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_mulhw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000096 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_mulhwu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000016 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_mulld(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0001d2 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_mulli(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1c000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 2, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_mullw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0001d6 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_nand(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0003b8 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_neg(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0000d0 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_nop(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x60000000 | modifiers;
    Ok(code)
}
fn gen_nor(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0000f8 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_or(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000378 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_orc(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000338 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_ori(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x60000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // uimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0xffff)?;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_oris(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x64000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // uimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0xffff)?;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_ptesync(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x7c4004ac | modifiers;
    Ok(code)
}
fn gen_rfi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x4c000064 | modifiers;
    Ok(code)
}
fn gen_rfid(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x4c000024 | modifiers;
    Ok(code)
}
fn gen_rldcl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x78000010 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // MB64
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x3f)?;
        code |= (arg & 0x1f) << 6;
        code |= arg & 0x20;
    }
    Ok(code)
}
fn gen_rldcr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x78000012 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // ME64
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x3f)?;
        code |= (arg & 0x1f) << 6;
        code |= arg & 0x20;
    }
    Ok(code)
}
fn gen_rldic(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x78000008 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // SH64
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x3f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 4) & 0x2;
    }
    // MB64
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x3f)?;
        code |= (arg & 0x1f) << 6;
        code |= arg & 0x20;
    }
    Ok(code)
}
fn gen_rldicl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x78000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // SH64
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x3f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 4) & 0x2;
    }
    // MB64
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x3f)?;
        code |= (arg & 0x1f) << 6;
        code |= arg & 0x20;
    }
    Ok(code)
}
fn gen_rldicr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x78000004 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // SH64
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x3f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 4) & 0x2;
    }
    // ME64
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x3f)?;
        code |= (arg & 0x1f) << 6;
        code |= arg & 0x20;
    }
    Ok(code)
}
fn gen_rldimi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x7800000c | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // SH64
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x3f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 4) & 0x2;
    }
    // MB64
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x3f)?;
        code |= (arg & 0x1f) << 6;
        code |= arg & 0x20;
    }
    Ok(code)
}
fn gen_rlwimi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 5)?;
    let mut code = 0x50000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // SH
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // MB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // ME
    {
        let arg = parse_unsigned(args, 4, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 1;
    }
    Ok(code)
}
fn gen_rlwinm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 5)?;
    let mut code = 0x54000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // SH
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // MB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // ME
    {
        let arg = parse_unsigned(args, 4, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 1;
    }
    Ok(code)
}
fn gen_rlwnm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 5)?;
    let mut code = 0x5c000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // MB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // ME
    {
        let arg = parse_unsigned(args, 4, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 1;
    }
    Ok(code)
}
fn gen_rotld(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x78000010 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_rotlw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x5c00003e | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_rotlwi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x5400003e | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // SH
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_rotrwi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x5400003e | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // SH
    {
        let arg = (32 - parse_unsigned(args, 2, 0x0, 0x1f)?);
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_sc(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x44000002 | modifiers;
    Ok(code)
}
fn gen_slbia(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x7c0003e4 | modifiers;
    Ok(code)
}
fn gen_slbie(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c000364 | modifiers;
    // rB
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_sld(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000036 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_slw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000030 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_slwi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x54000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // SH
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // ME
    {
        let arg = (31 - parse_unsigned(args, 2, 0x0, 0x1f)?);
        code |= (arg & 0x1f) << 1;
    }
    Ok(code)
}
fn gen_srad(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000634 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_sradi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000674 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // SH64
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x3f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 4) & 0x2;
    }
    Ok(code)
}
fn gen_sraw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000630 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_srawi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000670 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // SH
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_srd(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000436 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_srw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000430 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_srwi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x5400003e | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // MB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // SH
    {
        let arg = (32 - parse_unsigned(args, 2, 0x0, 0x1f)?);
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x98000000 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_stbu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x9c000000 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_stbux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0001ee | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stbx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0001ae | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_std(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xf8000000 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // ds
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xfffc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_stdcx_(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0001ad | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stdu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xf8000001 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // ds
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xfffc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_stdux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00016a | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stdx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00012a | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stfd(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xd8000000 | modifiers;
    // frS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_stfdu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xdc000000 | modifiers;
    // frS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_stfdux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0005ee | modifiers;
    // frS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stfdx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0005ae | modifiers;
    // frS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stfiwx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0007ae | modifiers;
    // frS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stfs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xd0000000 | modifiers;
    // frS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_stfsu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xd4000000 | modifiers;
    // frS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_stfsux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00056e | modifiers;
    // frS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stfsx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00052e | modifiers;
    // frS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_sth(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xb0000000 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_sthbrx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00072c | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_sthu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xb4000000 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_sthux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00036e | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_sthx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00032e | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stmw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xbc000000 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_stswi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0005aa | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // NB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stswx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00052a | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvebx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00010e | modifiers;
    // vS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvehx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00014e | modifiers;
    // vS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvewx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00018e | modifiers;
    // vS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvewx128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000183 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvlx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00050e | modifiers;
    // vS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvlx128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000503 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvlxl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00070e | modifiers;
    // vS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvlxl128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000703 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvrx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00054e | modifiers;
    // vS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvrx128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000543 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvrxl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00074e | modifiers;
    // vS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvrxl128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000743 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0001ce | modifiers;
    // vS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvx128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100001c3 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvxl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c0003ce | modifiers;
    // vS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stvxl128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100003c3 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x90000000 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_stwbrx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00052c | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stwcx_(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00012d | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stwu(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x94000000 | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // offset
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    // rA
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_stwux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00016e | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_stwx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c00012e | modifiers;
    // rS
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_subf(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000050 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_subfc(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000010 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_subfe(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000110 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_subfic(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x20000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 2, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_subfme(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c0001d0 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_subfze(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c000190 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_subi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x38000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = (-parse_signed(args, 2, -0x8000, 0x8000)?) as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_subic(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x30000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = (-parse_signed(args, 2, -0x8000, 0x8000)?) as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_subic_(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x34000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = (-parse_signed(args, 2, -0x8000, 0x8000)?) as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_subis(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x3c000000 | modifiers;
    // rD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = (-parse_signed(args, 2, -0x8000, 0x8000)?) as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_sync(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    match arg_count(args) {
        1 => {
            let mut code = 0x7c0004ac | modifiers;
            // sync_L
            {
                let arg = parse_unsigned(args, 0, 0x0, 0x3)?;
                code |= (arg & 0x3) << 21;
            }
            Ok(code)
        }
        0 => {
            let mut code = 0x7c0004ac | modifiers;
            Ok(code)
        }
        value => {
            Err(ArgumentError::ArgCount {
                value,
                expected: 1,
            })
        }
    }
}
fn gen_td(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000088 | modifiers;
    // TO
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_tdge(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7d800088 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_tdi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x8000000 | modifiers;
    // TO
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 2, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_tdlnl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7ca00088 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_tdlti(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xa000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_tdnei(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xb000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_tlbie(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 1)?;
    let mut code = 0x7c000264 | modifiers;
    // rB
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_tlbsync(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x7c00046c | modifiers;
    Ok(code)
}
fn gen_trap(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 0)?;
    let mut code = 0x7fe00008 | modifiers;
    Ok(code)
}
fn gen_tw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000008 | modifiers;
    // TO
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_tweq(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7c800008 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_twgti(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xd000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_twi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0xc000000 | modifiers;
    // TO
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 2, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_twlge(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x7ca00008 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_twllei(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xcc00000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_twui(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0xfe00000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // simm
    {
        let arg = parse_signed(args, 1, -0x8000, 0x8000)? as u32;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_vaddcuw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000180 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vaddfp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000000a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vaddfp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000010 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vaddsbs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000300 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vaddshs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000340 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vaddsws(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000380 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vaddubm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000000 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vaddubs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000200 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vadduhm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000040 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vadduhs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000240 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vadduwm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000080 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vadduws(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000280 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vand(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000404 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vand128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000210 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vandc(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000444 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vandc128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000250 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vavgsb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000502 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vavgsh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000542 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vavgsw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000582 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vavgub(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000402 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vavguh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000442 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vavguw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000482 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcfsx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000034a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vuimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vcfsx128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x180002b0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    // vsimm
    {
        let arg = parse_signed(args, 2, -0x10, 0x10)? as u32;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vcfux(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000030a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vuimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vcfux128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x180002f0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    // vuimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vcmpbfp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100003c6 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcmpbfp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000180 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vcmpeqfp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100000c6 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcmpeqfp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000000 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vcmpequb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000006 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcmpequh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000046 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcmpequw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000086 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcmpequw128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000200 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vcmpgefp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100001c6 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcmpgefp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000080 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vcmpgtfp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100002c6 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcmpgtfp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000100 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vcmpgtsb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000306 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcmpgtsh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000346 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcmpgtsw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000386 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcmpgtub(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000206 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcmpgtuh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000246 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vcmpgtuw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000286 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vctsxs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100003ca | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vuimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vctsxs128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000230 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    // vsimm
    {
        let arg = parse_signed(args, 2, -0x10, 0x10)? as u32;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vctuxs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000038a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vuimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vctuxs128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000270 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    // vuimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vexptefp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000018a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vexptefp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x180006b0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vlogefp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x100001ca | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vlogefp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x180006f0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vmaddcfp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000110 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vmaddfp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x1000002e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // vB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmaddfp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x140000d0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vmaxfp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000040a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmaxfp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000280 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vmaxsb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000102 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmaxsh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000142 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmaxsw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000182 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmaxub(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000002 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmaxuh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000042 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmaxuw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000082 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmhaddshs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x10000020 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vC
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_vmhraddshs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x10000021 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vC
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_vminfp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000044a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vminfp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x180002c0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vminsb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000302 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vminsh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000342 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vminsw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000382 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vminub(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000202 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vminuh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000242 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vminuw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000282 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmladduhm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x10000022 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vC
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_vmr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x10000484 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmrghb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000000c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmrghh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000004c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmrghw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000008c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmrghw128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000300 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vmrglb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000010c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmrglh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000014c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmrglw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000018c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmrglw128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000340 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vmsum3fp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000190 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vmsum4fp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x140001d0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vmsummbm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x10000025 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vC
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_vmsumshm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x10000028 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vC
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_vmsumshs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x10000029 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vC
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_vmsumubm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x10000024 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vC
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_vmsumuhm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x10000026 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vC
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_vmsumuhs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x10000027 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vC
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_vmulesb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000308 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmulesh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000348 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmuleub(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000208 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmuleuh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000248 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmulfp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000090 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vmulosb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000108 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmulosh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000148 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmuloub(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000008 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vmulouh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000048 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vnmsubfp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x1000002f | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vC
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    // vB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vnmsubfp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000150 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vnor(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000504 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vnor128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000290 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vnot(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x10000504 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vor(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000484 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vor128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x140002d0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vperm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x1000002b | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vC
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_vperm128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x14000000 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    // VC128
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x7)?;
        code |= (arg & 0x7) << 6;
    }
    Ok(code)
}
fn gen_vpermwi128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000210 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    // PERM
    {
        let arg = parse_unsigned(args, 2, 0x0, 0xff)?;
        code |= (arg & 0x1f) << 16;
        code |= (arg & 0xe0) << 1;
    }
    Ok(code)
}
fn gen_vpkd3d128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 5)?;
    let mut code = 0x18000610 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    // D3DType
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7)?;
        code |= (arg & 0x7) << 18;
    }
    // VMASK
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x3)?;
        code |= (arg & 0x3) << 16;
    }
    // Zimm
    {
        let arg = parse_unsigned(args, 4, 0x0, 0x3)?;
        code |= (arg & 0x3) << 6;
    }
    Ok(code)
}
fn gen_vpkpx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000030e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vpkshss(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000018e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vpkshss128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000200 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vpkshus(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000010e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vpkshus128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000240 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vpkswss(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100001ce | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vpkswss128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000280 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vpkswus(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000014e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vpkswus128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x140002c0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vpkuhum(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000000e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vpkuhum128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000300 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vpkuhus(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000008e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vpkuhus128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000340 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vpkuwum(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000004e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vpkuwum128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000380 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vpkuwus(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100000ce | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vpkuwus128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x140003c0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vrefp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000010a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vrefp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x18000630 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vrfim(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x100002ca | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vrfim128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x18000330 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vrfin(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000020a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vrfin128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x18000370 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vrfip(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000028a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vrfip128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x180003b0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vrfiz(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000024a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vrfiz128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x180003f0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vrlb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000004 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vrlh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000044 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vrlimi128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x18000710 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    // vuimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // Zimm
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x3)?;
        code |= (arg & 0x3) << 6;
    }
    Ok(code)
}
fn gen_vrlw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000084 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vrlw128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000050 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vrsqrtefp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000014a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vrsqrtefp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x18000670 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vsel(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x1000002a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vC
    {
        let arg = parse_unsigned(args, 3, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 6;
    }
    Ok(code)
}
fn gen_vsel128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000350 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vsl(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100001c4 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vslb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000104 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsldoi(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x1000002c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // SHB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0xf)?;
        code |= (arg & 0xf) << 6;
    }
    Ok(code)
}
fn gen_vsldoi128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 4)?;
    let mut code = 0x10000010 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    // SHB
    {
        let arg = parse_unsigned(args, 3, 0x0, 0xf)?;
        code |= (arg & 0xf) << 6;
    }
    Ok(code)
}
fn gen_vslh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000144 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vslo(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000040c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vslo128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000390 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vslw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000184 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vslw128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x180000d0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vspltb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000020c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vuimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vsplth(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000024c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vuimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vspltisb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000030c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vsimm
    {
        let arg = parse_signed(args, 1, -0x10, 0x10)? as u32;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vspltish(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000034c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vsimm
    {
        let arg = parse_signed(args, 1, -0x10, 0x10)? as u32;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vspltisw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000038c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vsimm
    {
        let arg = parse_signed(args, 1, -0x10, 0x10)? as u32;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vspltisw128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000770 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    // vsimm
    {
        let arg = parse_signed(args, 2, -0x10, 0x10)? as u32;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vspltw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000028c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    // vuimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vspltw128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000730 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    // vuimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vsr(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100002c4 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsrab(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000304 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsrah(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000344 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsraw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000384 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsraw128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x18000150 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vsrb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000204 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsrh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000244 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsro(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000044c | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsro128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x140003d0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vsrw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000284 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsrw128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x180001d0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vsubcuw(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000580 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsubfp(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x1000004a | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsubfp128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000050 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vsubsbs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000700 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsubshs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000740 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsubsws(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000780 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsububm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000400 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsububs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000600 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsubuhm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000440 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsubuhs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000640 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsubuwm(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000480 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsubuws(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000680 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsum2sws(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000688 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsum4sbs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000708 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsum4shs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000648 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsum4ubs(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000608 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vsumsws(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x10000788 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vupkd3d128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x180007f0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    // vuimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    Ok(code)
}
fn gen_vupkhpx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000034e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vupkhsb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000020e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vupkhsb128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x18000380 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vupkhsh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000024e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vupkhsh128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x180007a0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vupklpx(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x100003ce | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vupklsb(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x1000028e | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vupklsb128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x180003c0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vupklsh(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x100002ce | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vB
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vupklsh128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 2)?;
    let mut code = 0x180007e0 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_vxor(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x100004c4 | modifiers;
    // vD
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // vA
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // vB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_vxor128(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x14000310 | modifiers;
    // VDS128
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 21;
        code |= (arg >> 3) & 0xc;
    }
    // VA128
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 16;
        code |= arg & 0x20;
        code |= (arg & 0x40) << 4;
    }
    // VB128
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x7f)?;
        code |= (arg & 0x1f) << 11;
        code |= (arg >> 5) & 0x3;
    }
    Ok(code)
}
fn gen_xor(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x7c000278 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // rB
    {
        let arg = parse_unsigned(args, 2, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 11;
    }
    Ok(code)
}
fn gen_xori(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x68000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // uimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0xffff)?;
        code |= arg & 0xffff;
    }
    Ok(code)
}
fn gen_xoris(args: &Arguments, modifiers: u32) -> Result<u32, ArgumentError> {
    check_arg_count(args, 3)?;
    let mut code = 0x6c000000 | modifiers;
    // rA
    {
        let arg = parse_unsigned(args, 0, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 16;
    }
    // rS
    {
        let arg = parse_unsigned(args, 1, 0x0, 0x1f)?;
        code |= (arg & 0x1f) << 21;
    }
    // uimm
    {
        let arg = parse_unsigned(args, 2, 0x0, 0xffff)?;
        code |= arg & 0xffff;
    }
    Ok(code)
}
type MnemonicFn = fn(&Arguments, u32) -> Result<u32, ArgumentError>;
static MNEMONIC_MAP: phf::Map<&'static str, (MnemonicFn, u32)> = ::phf::Map {
    key: 12913932095322966823,
    disps: &[
        (0, 691),
        (0, 0),
        (0, 15),
        (0, 15),
        (0, 14),
        (0, 5),
        (0, 117),
        (0, 5),
        (0, 33),
        (0, 0),
        (0, 62),
        (0, 8),
        (0, 160),
        (0, 15),
        (1, 612),
        (0, 1),
        (0, 32),
        (0, 37),
        (0, 264),
        (1, 2),
        (0, 435),
        (0, 845),
        (0, 0),
        (0, 137),
        (0, 78),
        (0, 98),
        (0, 29),
        (0, 277),
        (0, 326),
        (0, 25),
        (0, 818),
        (0, 5),
        (0, 15),
        (0, 44),
        (0, 27),
        (0, 132),
        (0, 0),
        (0, 24),
        (2, 521),
        (1, 689),
        (0, 5),
        (0, 301),
        (0, 6),
        (0, 0),
        (0, 43),
        (0, 0),
        (0, 50),
        (0, 33),
        (0, 237),
        (0, 171),
        (0, 31),
        (0, 60),
        (0, 2),
        (0, 3),
        (0, 46),
        (0, 2),
        (0, 111),
        (0, 503),
        (0, 5),
        (0, 4),
        (0, 36),
        (0, 156),
        (0, 90),
        (0, 0),
        (0, 129),
        (0, 406),
        (0, 2),
        (0, 367),
        (0, 81),
        (0, 14),
        (0, 0),
        (0, 242),
        (0, 134),
        (0, 51),
        (0, 854),
        (0, 743),
        (0, 432),
        (0, 61),
        (0, 443),
        (0, 273),
        (0, 11),
        (0, 0),
        (0, 378),
        (3, 890),
        (0, 388),
        (0, 1),
        (0, 7),
        (1, 350),
        (0, 160),
        (0, 545),
        (0, 3),
        (0, 4),
        (0, 11),
        (0, 331),
        (0, 39),
        (0, 313),
        (0, 853),
        (1, 595),
        (0, 0),
        (1, 249),
        (0, 4),
        (1, 57),
        (0, 82),
        (0, 16),
        (0, 355),
        (0, 884),
        (0, 50),
        (0, 252),
        (0, 14),
        (0, 1),
        (1, 137),
        (0, 2),
        (0, 15),
        (0, 522),
        (0, 964),
        (0, 46),
        (0, 710),
        (1, 290),
        (0, 27),
        (1, 40),
        (0, 454),
        (0, 6),
        (0, 13),
        (1, 229),
        (3, 151),
        (0, 56),
        (0, 163),
        (0, 249),
        (0, 37),
        (2, 836),
        (5, 198),
        (1, 836),
        (8, 714),
        (0, 5),
        (0, 32),
        (0, 447),
        (0, 3),
        (0, 1),
        (1, 486),
        (0, 828),
        (0, 725),
        (0, 827),
        (0, 893),
        (0, 0),
        (0, 7),
        (0, 12),
        (0, 426),
        (0, 38),
        (0, 7),
        (0, 101),
        (0, 8),
        (0, 91),
        (0, 164),
        (1, 467),
        (0, 151),
        (3, 571),
        (0, 91),
        (8, 697),
        (1, 107),
        (0, 2),
        (0, 688),
        (0, 149),
        (3, 584),
        (0, 572),
        (1, 38),
        (0, 493),
        (0, 13),
        (0, 16),
        (0, 15),
        (0, 628),
        (0, 199),
        (0, 35),
        (10, 71),
        (7, 866),
        (8, 320),
        (0, 498),
        (0, 8),
        (0, 6),
        (0, 88),
        (0, 73),
        (14, 502),
        (1, 474),
        (16, 757),
        (0, 578),
        (0, 47),
        (6, 310),
        (4, 156),
        (0, 606),
        (7, 578),
        (0, 806),
        (4, 483),
        (0, 345),
        (0, 37),
        (3, 263),
        (0, 0),
        (0, 381),
    ],
    entries: &[
        ("vmaddfp128", (gen_vmaddfp128, 0x0)),
        ("bnelrl+", (gen_bnelr, 0x200001)),
        ("fcfid.", (gen_fcfid, 0x1)),
        ("mftb", (gen_mftb, 0x0)),
        ("divduo", (gen_divdu, 0x400)),
        ("bgea+", (gen_bge, 0x200002)),
        ("vadduhs", (gen_vadduhs, 0x0)),
        ("vsl", (gen_vsl, 0x0)),
        ("vsraw", (gen_vsraw, 0x0)),
        ("mtxer", (gen_mtxer, 0x0)),
        ("bnsctr+", (gen_bnsctr, 0x200000)),
        ("bdnzla", (gen_bdnz, 0x3)),
        ("vcmpgtfp.", (gen_vcmpgtfp, 0x400)),
        ("fnmadd.", (gen_fnmadd, 0x1)),
        ("bltctrl+", (gen_bltctr, 0x200001)),
        ("subfmeo.", (gen_subfme, 0x401)),
        ("cntlzw", (gen_cntlzw, 0x0)),
        ("vminsh", (gen_vminsh, 0x0)),
        ("bgel+", (gen_bge, 0x200001)),
        ("rotlwi", (gen_rotlwi, 0x0)),
        ("vpkshss128", (gen_vpkshss128, 0x0)),
        ("fctiwz.", (gen_fctiwz, 0x1)),
        ("bnelr", (gen_bnelr, 0x0)),
        ("bdnztl-", (gen_bdnzt, 0x200001)),
        ("subi", (gen_subi, 0x0)),
        ("fmuls.", (gen_fmuls, 0x1)),
        ("addze", (gen_addze, 0x0)),
        ("stw", (gen_stw, 0x0)),
        ("bgelrl", (gen_bgelr, 0x1)),
        ("stvebx", (gen_stvebx, 0x0)),
        ("bgta+", (gen_bgt, 0x200002)),
        ("bsol", (gen_bso, 0x1)),
        ("vpkpx", (gen_vpkpx, 0x0)),
        ("slbia", (gen_slbia, 0x0)),
        ("addi", (gen_addi, 0x0)),
        ("vspltw", (gen_vspltw, 0x0)),
        ("subfco.", (gen_subfc, 0x401)),
        ("fmul.", (gen_fmul, 0x1)),
        ("bdnzfl-", (gen_bdnzf, 0x200001)),
        ("clrlslwi", (gen_clrlslwi, 0x0)),
        ("bne+", (gen_bne, 0x200000)),
        ("orc.", (gen_orc, 0x1)),
        ("vandc", (gen_vandc, 0x0)),
        ("divdo", (gen_divd, 0x400)),
        ("blectr+", (gen_blectr, 0x200000)),
        ("stfsu", (gen_stfsu, 0x0)),
        ("bsoctr+", (gen_bsoctr, 0x200000)),
        ("fnmsub", (gen_fnmsub, 0x0)),
        ("vmaxfp", (gen_vmaxfp, 0x0)),
        ("bns", (gen_bns, 0x0)),
        ("bdz-", (gen_bdz, 0x200000)),
        ("bdnzl", (gen_bdnz, 0x1)),
        ("vmrghw128", (gen_vmrghw128, 0x0)),
        ("bltla-", (gen_blt, 0x200003)),
        ("bdza+", (gen_bdz, 0x200002)),
        ("rlwimi.", (gen_rlwimi, 0x1)),
        ("fdivs.", (gen_fdivs, 0x1)),
        ("vminsb", (gen_vminsb, 0x0)),
        ("cntlzw.", (gen_cntlzw, 0x1)),
        ("bltl", (gen_blt, 0x1)),
        ("blta", (gen_blt, 0x2)),
        ("vrsqrtefp128", (gen_vrsqrtefp128, 0x0)),
        ("stvrxl128", (gen_stvrxl128, 0x0)),
        ("mtvscr", (gen_mtvscr, 0x0)),
        ("bdnzla-", (gen_bdnz, 0x200003)),
        ("bnsla+", (gen_bns, 0x200003)),
        ("icbi.", (gen_icbi, 0x1)),
        ("bgelr", (gen_bgelr, 0x0)),
        ("vor", (gen_vor, 0x0)),
        ("rldcl", (gen_rldcl, 0x0)),
        ("bdnzlrl+", (gen_bdnzlr, 0x200001)),
        ("bnel-", (gen_bne, 0x200001)),
        ("rldicl.", (gen_rldicl, 0x1)),
        ("bnslrl", (gen_bnslr, 0x1)),
        ("blelrl+", (gen_blelr, 0x200001)),
        ("mtfsb0.", (gen_mtfsb0, 0x1)),
        ("mttbu", (gen_mttbu, 0x0)),
        ("andc.", (gen_andc, 0x1)),
        ("bc", (gen_bc, 0x0)),
        ("add.", (gen_add, 0x1)),
        ("bcctr", (gen_bcctr, 0x0)),
        ("addis", (gen_addis, 0x0)),
        ("crnot", (gen_crnot, 0x0)),
        ("vsldoi", (gen_vsldoi, 0x0)),
        ("extsb", (gen_extsb, 0x0)),
        ("subic", (gen_subic, 0x0)),
        ("sthu", (gen_sthu, 0x0)),
        ("bgtla+", (gen_bgt, 0x200003)),
        ("vctsxs128", (gen_vctsxs128, 0x0)),
        ("rldcr", (gen_rldcr, 0x0)),
        ("and", (gen_and, 0x0)),
        ("cmpl", (gen_cmpl, 0x0)),
        ("cmplw", (gen_cmplw, 0x0)),
        ("blel-", (gen_ble, 0x200001)),
        ("bdzlrl", (gen_bdzlr, 0x1)),
        ("bdnztlrl+", (gen_bdnztlr, 0x200001)),
        ("clrlwi.", (gen_clrlwi, 0x1)),
        ("vrfiz", (gen_vrfiz, 0x0)),
        ("bcl+", (gen_bc, 0x200001)),
        ("vavguw", (gen_vavguw, 0x0)),
        ("bge", (gen_bge, 0x0)),
        ("fctiw", (gen_fctiw, 0x0)),
        ("sld.", (gen_sld, 0x1)),
        ("bdzflrl+", (gen_bdzflr, 0x200001)),
        ("lfdx", (gen_lfdx, 0x0)),
        ("rotld", (gen_rotld, 0x0)),
        ("beql+", (gen_beq, 0x200001)),
        ("stfdx", (gen_stfdx, 0x0)),
        ("vavgsb", (gen_vavgsb, 0x0)),
        ("bdzla", (gen_bdz, 0x3)),
        ("crorc", (gen_crorc, 0x0)),
        ("vpkshus", (gen_vpkshus, 0x0)),
        ("subfzeo.", (gen_subfze, 0x401)),
        ("bcla-", (gen_bc, 0x200003)),
        ("mtsprg", (gen_mtsprg, 0x0)),
        ("subf.", (gen_subf, 0x1)),
        ("bdnza+", (gen_bdnz, 0x200002)),
        ("vspltisb", (gen_vspltisb, 0x0)),
        ("bgtl", (gen_bgt, 0x1)),
        ("bgectr+", (gen_bgectr, 0x200000)),
        ("stvlx128", (gen_stvlx128, 0x0)),
        ("blea", (gen_ble, 0x2)),
        ("blr", (gen_blr, 0x0)),
        ("lvebx", (gen_lvebx, 0x0)),
        ("lfs", (gen_lfs, 0x0)),
        ("vcmpgtuw.", (gen_vcmpgtuw, 0x400)),
        ("bdnzl+", (gen_bdnz, 0x200001)),
        ("subfic", (gen_subfic, 0x0)),
        ("stvrx", (gen_stvrx, 0x0)),
        ("bcl-", (gen_bc, 0x200001)),
        ("bclrl", (gen_bclr, 0x1)),
        ("vcmpgtsh", (gen_vcmpgtsh, 0x0)),
        ("bltla+", (gen_blt, 0x200003)),
        ("vavgsw", (gen_vavgsw, 0x0)),
        ("bdnzfl+", (gen_bdnzf, 0x200001)),
        ("subfeo.", (gen_subfe, 0x401)),
        ("lswx", (gen_lswx, 0x0)),
        ("rldcl.", (gen_rldcl, 0x1)),
        ("mfdbatu", (gen_mfdbatu, 0x0)),
        ("mr", (gen_mr, 0x0)),
        ("vaddubs", (gen_vaddubs, 0x0)),
        ("vlogefp", (gen_vlogefp, 0x0)),
        ("stbu", (gen_stbu, 0x0)),
        ("divwo", (gen_divw, 0x400)),
        ("blelr+", (gen_blelr, 0x200000)),
        ("fmsub.", (gen_fmsub, 0x1)),
        ("bns-", (gen_bns, 0x200000)),
        ("dcbi", (gen_dcbi, 0x0)),
        ("rlwinm.", (gen_rlwinm, 0x1)),
        ("bgt+", (gen_bgt, 0x200000)),
        ("vupklsh", (gen_vupklsh, 0x0)),
        ("bgtlr", (gen_bgtlr, 0x0)),
        ("vcmpbfp128.", (gen_vcmpbfp128, 0x40)),
        ("vrefp", (gen_vrefp, 0x0)),
        ("bnea-", (gen_bne, 0x200002)),
        ("mtmsr", (gen_mtmsr, 0x0)),
        ("addco.", (gen_addc, 0x401)),
        ("mfsdr1", (gen_mfsdr1, 0x0)),
        ("mcrxr", (gen_mcrxr, 0x0)),
        ("bnsl+", (gen_bns, 0x200001)),
        ("bsoctr", (gen_bsoctr, 0x0)),
        ("vnor128", (gen_vnor128, 0x0)),
        ("bdzt-", (gen_bdzt, 0x200000)),
        ("sthx", (gen_sthx, 0x0)),
        ("bnsa+", (gen_bns, 0x200002)),
        ("beqlr", (gen_beqlr, 0x0)),
        ("bnsl", (gen_bns, 0x1)),
        ("vcmpgtub.", (gen_vcmpgtub, 0x400)),
        ("vaddfp", (gen_vaddfp, 0x0)),
        ("creqv", (gen_creqv, 0x0)),
        ("bnela", (gen_bne, 0x3)),
        ("srad.", (gen_srad, 0x1)),
        ("xori", (gen_xori, 0x0)),
        ("bsola-", (gen_bso, 0x200003)),
        ("beqctrl", (gen_beqctr, 0x1)),
        ("vsumsws", (gen_vsumsws, 0x0)),
        ("crand", (gen_crand, 0x0)),
        ("lvlxl128", (gen_lvlxl128, 0x0)),
        ("beqla-", (gen_beq, 0x200003)),
        ("vcmpeqfp.", (gen_vcmpeqfp, 0x400)),
        ("mulhd.", (gen_mulhd, 0x1)),
        ("vmaxsb", (gen_vmaxsb, 0x0)),
        ("bdzfla", (gen_bdzf, 0x3)),
        ("rfid", (gen_rfid, 0x0)),
        ("stwbrx", (gen_stwbrx, 0x0)),
        ("vpkuwum", (gen_vpkuwum, 0x0)),
        ("srw", (gen_srw, 0x0)),
        ("ecowx", (gen_ecowx, 0x0)),
        ("vsum4sbs", (gen_vsum4sbs, 0x0)),
        ("mffs", (gen_mffs, 0x0)),
        ("bdnzlr+", (gen_bdnzlr, 0x200000)),
        ("mflr", (gen_mflr, 0x0)),
        ("vrsqrtefp", (gen_vrsqrtefp, 0x0)),
        ("bdnzlrl", (gen_bdnzlr, 0x1)),
        ("lis", (gen_lis, 0x0)),
        ("fneg", (gen_fneg, 0x0)),
        ("vadduwm", (gen_vadduwm, 0x0)),
        ("bgelr+", (gen_bgelr, 0x200000)),
        ("rldcr.", (gen_rldcr, 0x1)),
        ("bsolrl+", (gen_bsolr, 0x200001)),
        ("bnel", (gen_bne, 0x1)),
        ("sthbrx", (gen_sthbrx, 0x0)),
        ("vmaxub", (gen_vmaxub, 0x0)),
        ("ble", (gen_ble, 0x0)),
        ("nor", (gen_nor, 0x0)),
        ("td", (gen_td, 0x0)),
        ("vmsumuhs", (gen_vmsumuhs, 0x0)),
        ("mfspr", (gen_mfspr, 0x0)),
        ("vmaxuh", (gen_vmaxuh, 0x0)),
        ("bgtlrl", (gen_bgtlr, 0x1)),
        ("vrfip", (gen_vrfip, 0x0)),
        ("mtsdr1", (gen_mtsdr1, 0x0)),
        ("bl", (gen_b, 0x1)),
        ("bdnzfla-", (gen_bdnzf, 0x200003)),
        ("ori", (gen_ori, 0x0)),
        ("stwx", (gen_stwx, 0x0)),
        ("rotlwi.", (gen_rotlwi, 0x1)),
        ("frsp", (gen_frsp, 0x0)),
        ("lbzx", (gen_lbzx, 0x0)),
        ("lvrx", (gen_lvrx, 0x0)),
        ("bdzflr+", (gen_bdzflr, 0x200000)),
        ("bdzla-", (gen_bdz, 0x200003)),
        ("bnectr", (gen_bnectr, 0x0)),
        ("vsubcuw", (gen_vsubcuw, 0x0)),
        ("subfc", (gen_subfc, 0x0)),
        ("bdnzla+", (gen_bdnz, 0x200003)),
        ("extsh.", (gen_extsh, 0x1)),
        ("bdzfl", (gen_bdzf, 0x1)),
        ("subfmeo", (gen_subfme, 0x400)),
        ("bdztlrl", (gen_bdztlr, 0x1)),
        ("ba", (gen_b, 0x2)),
        ("bdnz", (gen_bdnz, 0x0)),
        ("bctr", (gen_bctr, 0x0)),
        ("beqla+", (gen_beq, 0x200003)),
        ("blectrl", (gen_blectr, 0x1)),
        ("bgt-", (gen_bgt, 0x200000)),
        ("mulli", (gen_mulli, 0x0)),
        ("lvx", (gen_lvx, 0x0)),
        ("vaddsbs", (gen_vaddsbs, 0x0)),
        ("mulhwu", (gen_mulhwu, 0x0)),
        ("slbie", (gen_slbie, 0x0)),
        ("lfd", (gen_lfd, 0x0)),
        ("vrlw128", (gen_vrlw128, 0x0)),
        ("stfiwx", (gen_stfiwx, 0x0)),
        ("divdo.", (gen_divd, 0x401)),
        ("bltlr", (gen_bltlr, 0x0)),
        ("bgta-", (gen_bgt, 0x200002)),
        ("vsubuwm", (gen_vsubuwm, 0x0)),
        ("bdnza-", (gen_bdnz, 0x200002)),
        ("bdzl+", (gen_bdz, 0x200001)),
        ("bca", (gen_bc, 0x2)),
        ("bgea-", (gen_bge, 0x200002)),
        ("blea+", (gen_ble, 0x200002)),
        ("vrfim128", (gen_vrfim128, 0x0)),
        ("bgel", (gen_bge, 0x1)),
        ("vslb", (gen_vslb, 0x0)),
        ("fmsubs", (gen_fmsubs, 0x0)),
        ("adde", (gen_adde, 0x0)),
        ("lwax", (gen_lwax, 0x0)),
        ("blela-", (gen_ble, 0x200003)),
        ("b", (gen_b, 0x0)),
        ("vnmsubfp128", (gen_vnmsubfp128, 0x0)),
        ("xor.", (gen_xor, 0x1)),
        ("tdlti", (gen_tdlti, 0x0)),
        ("and.", (gen_and, 0x1)),
        ("bdz", (gen_bdz, 0x0)),
        ("nand", (gen_nand, 0x0)),
        ("vupklsh128", (gen_vupklsh128, 0x0)),
        ("vminub", (gen_vminub, 0x0)),
        ("lbzu", (gen_lbzu, 0x0)),
        ("bdza", (gen_bdz, 0x2)),
        ("stdx", (gen_stdx, 0x0)),
        ("vandc128", (gen_vandc128, 0x0)),
        ("vcmpgtfp128.", (gen_vcmpgtfp128, 0x40)),
        ("vavguh", (gen_vavguh, 0x0)),
        ("vmulosh", (gen_vmulosh, 0x0)),
        ("neg", (gen_neg, 0x0)),
        ("bcctr+", (gen_bcctr, 0x200000)),
        ("bcl", (gen_bc, 0x1)),
        ("divwu.", (gen_divwu, 0x1)),
        ("bgtl-", (gen_bgt, 0x200001)),
        ("or", (gen_or, 0x0)),
        ("beq+", (gen_beq, 0x200000)),
        ("vmrghh", (gen_vmrghh, 0x0)),
        ("rldicr.", (gen_rldicr, 0x1)),
        ("bdzfl-", (gen_bdzf, 0x200001)),
        ("fres.", (gen_fres, 0x1)),
        ("fsel.", (gen_fsel, 0x1)),
        ("bltl-", (gen_blt, 0x200001)),
        ("clrlslwi.", (gen_clrlslwi, 0x1)),
        ("stvlxl", (gen_stvlxl, 0x0)),
        ("fadds.", (gen_fadds, 0x1)),
        ("lwzx", (gen_lwzx, 0x0)),
        ("sradi.", (gen_sradi, 0x1)),
        ("cntlzd.", (gen_cntlzd, 0x1)),
        ("vsplth", (gen_vsplth, 0x0)),
        ("tdnei", (gen_tdnei, 0x0)),
        ("mulldo", (gen_mulld, 0x400)),
        ("lvrx128", (gen_lvrx128, 0x0)),
        ("mfdsisr", (gen_mfdsisr, 0x0)),
        ("bdnzta", (gen_bdnzt, 0x2)),
        ("bdnzfa", (gen_bdnzf, 0x2)),
        ("bdnz+", (gen_bdnz, 0x200000)),
        ("vmr", (gen_vmr, 0x0)),
        ("srd", (gen_srd, 0x0)),
        ("tdge", (gen_tdge, 0x0)),
        ("or.", (gen_or, 0x1)),
        ("xoris", (gen_xoris, 0x0)),
        ("divdu.", (gen_divdu, 0x1)),
        ("sth", (gen_sth, 0x0)),
        ("vmrghw", (gen_vmrghw, 0x0)),
        ("mtsrin", (gen_mtsrin, 0x0)),
        ("vaddfp128", (gen_vaddfp128, 0x0)),
        ("vpermwi128", (gen_vpermwi128, 0x0)),
        ("lvxl", (gen_lvxl, 0x0)),
        ("vcmpequb.", (gen_vcmpequb, 0x400)),
        ("dststt", (gen_dstst, 0x2000000)),
        ("vrfim", (gen_vrfim, 0x0)),
        ("vpkd3d128", (gen_vpkd3d128, 0x0)),
        ("divw", (gen_divw, 0x0)),
        ("lhbrx", (gen_lhbrx, 0x0)),
        ("bdza-", (gen_bdz, 0x200002)),
        ("andis.", (gen_andis_, 0x0)),
        ("addeo", (gen_adde, 0x400)),
        ("tweq", (gen_tweq, 0x0)),
        ("vupkd3d128", (gen_vupkd3d128, 0x0)),
        ("bgtctr+", (gen_bgtctr, 0x200000)),
        ("nego", (gen_neg, 0x400)),
        ("vavgsh", (gen_vavgsh, 0x0)),
        ("twlge", (gen_twlge, 0x0)),
        ("blea-", (gen_ble, 0x200002)),
        ("vminfp128", (gen_vminfp128, 0x0)),
        ("bsoctrl+", (gen_bsoctr, 0x200001)),
        ("lfsx", (gen_lfsx, 0x0)),
        ("bdnzflrl+", (gen_bdnzflr, 0x200001)),
        ("mulhw", (gen_mulhw, 0x0)),
        ("cmp", (gen_cmp, 0x0)),
        ("andc", (gen_andc, 0x0)),
        ("sc", (gen_sc, 0x0)),
        ("lvsl", (gen_lvsl, 0x0)),
        ("fmadds", (gen_fmadds, 0x0)),
        ("mullw", (gen_mullw, 0x0)),
        ("neg.", (gen_neg, 0x1)),
        ("cmpldi", (gen_cmpldi, 0x0)),
        ("addc.", (gen_addc, 0x1)),
        ("bdzflrl", (gen_bdzflr, 0x1)),
        ("clrlwi", (gen_clrlwi, 0x0)),
        ("beq-", (gen_beq, 0x200000)),
        ("extsw", (gen_extsw, 0x0)),
        ("divdu", (gen_divdu, 0x0)),
        ("lvsr128", (gen_lvsr128, 0x0)),
        ("subfo", (gen_subf, 0x400)),
        ("stfd", (gen_stfd, 0x0)),
        ("mtdsisr", (gen_mtdsisr, 0x0)),
        ("vand", (gen_vand, 0x0)),
        ("addco", (gen_addc, 0x400)),
        ("vcmpeqfp", (gen_vcmpeqfp, 0x0)),
        ("vmulouh", (gen_vmulouh, 0x0)),
        ("bdzfa", (gen_bdzf, 0x2)),
        ("divwu", (gen_divwu, 0x0)),
        ("vmuleub", (gen_vmuleub, 0x0)),
        ("vmaxfp128", (gen_vmaxfp128, 0x0)),
        ("divwuo.", (gen_divwu, 0x401)),
        ("ld", (gen_ld, 0x0)),
        ("stvehx", (gen_stvehx, 0x0)),
        ("slwi", (gen_slwi, 0x0)),
        ("fmr.", (gen_fmr, 0x1)),
        ("vsrb", (gen_vsrb, 0x0)),
        ("cmpwi", (gen_cmpwi, 0x0)),
        ("stvrxl", (gen_stvrxl, 0x0)),
        ("bgtl+", (gen_bgt, 0x200001)),
        ("bgectrl+", (gen_bgectr, 0x200001)),
        ("mfsrr0", (gen_mfsrr0, 0x0)),
        ("bdnzlr", (gen_bdnzlr, 0x0)),
        ("bdztlr", (gen_bdztlr, 0x0)),
        ("bdztla", (gen_bdzt, 0x3)),
        ("subic.", (gen_subic_, 0x0)),
        ("lmw", (gen_lmw, 0x0)),
        ("lwbrx", (gen_lwbrx, 0x0)),
        ("mulldo.", (gen_mulld, 0x401)),
        ("bdzlr+", (gen_bdzlr, 0x200000)),
        ("mfibatu", (gen_mfibatu, 0x0)),
        ("bltctr", (gen_bltctr, 0x0)),
        ("bdnzfa-", (gen_bdnzf, 0x200002)),
        ("fctidz", (gen_fctidz, 0x0)),
        ("vcfsx", (gen_vcfsx, 0x0)),
        ("vsr", (gen_vsr, 0x0)),
        ("clrrwi", (gen_clrrwi, 0x0)),
        ("vmaxsh", (gen_vmaxsh, 0x0)),
        ("mfxer", (gen_mfxer, 0x0)),
        ("vmhaddshs", (gen_vmhaddshs, 0x0)),
        ("vmsumshm", (gen_vmsumshm, 0x0)),
        ("fres", (gen_fres, 0x0)),
        ("vpkswss", (gen_vpkswss, 0x0)),
        ("srw.", (gen_srw, 0x1)),
        ("vperm128", (gen_vperm128, 0x0)),
        ("bcla+", (gen_bc, 0x200003)),
        ("fsub", (gen_fsub, 0x0)),
        ("vadduws", (gen_vadduws, 0x0)),
        ("bca+", (gen_bc, 0x200002)),
        ("frsqrte", (gen_frsqrte, 0x0)),
        ("bltctrl", (gen_bltctr, 0x1)),
        ("vmulesh", (gen_vmulesh, 0x0)),
        ("bnsa", (gen_bns, 0x2)),
        ("bge+", (gen_bge, 0x200000)),
        ("lhaux", (gen_lhaux, 0x0)),
        ("vor128", (gen_vor128, 0x0)),
        ("bdnzt", (gen_bdnzt, 0x0)),
        ("bclrl+", (gen_bclr, 0x200001)),
        ("mulld", (gen_mulld, 0x0)),
        ("cmpdi", (gen_cmpdi, 0x0)),
        ("vslo", (gen_vslo, 0x0)),
        ("sync", (gen_sync, 0x0)),
        ("extsb.", (gen_extsb, 0x1)),
        ("bdnza", (gen_bdnz, 0x2)),
        ("vcmpequh", (gen_vcmpequh, 0x0)),
        ("nop", (gen_nop, 0x0)),
        ("bnsctrl", (gen_bnsctr, 0x1)),
        ("divwuo", (gen_divwu, 0x400)),
        ("crnand", (gen_crnand, 0x0)),
        ("blela+", (gen_ble, 0x200003)),
        ("lvxl128", (gen_lvxl128, 0x0)),
        ("bltl+", (gen_blt, 0x200001)),
        ("mfsprg", (gen_mfsprg, 0x0)),
        ("bgel-", (gen_bge, 0x200001)),
        ("ldarx", (gen_ldarx, 0x0)),
        ("vsubuws", (gen_vsubuws, 0x0)),
        ("beq", (gen_beq, 0x0)),
        ("bdzl", (gen_bdz, 0x1)),
        ("dstt", (gen_dst, 0x2000000)),
        ("fadds", (gen_fadds, 0x0)),
        ("dcbt", (gen_dcbt, 0x0)),
        ("nand.", (gen_nand, 0x1)),
        ("ldu", (gen_ldu, 0x0)),
        ("mtfsb1", (gen_mtfsb1, 0x0)),
        ("fmr", (gen_fmr, 0x0)),
        ("vrlimi128", (gen_vrlimi128, 0x0)),
        ("addze.", (gen_addze, 0x1)),
        ("fmuls", (gen_fmuls, 0x0)),
        ("extsh", (gen_extsh, 0x0)),
        ("bnela+", (gen_bne, 0x200003)),
        ("vrfin128", (gen_vrfin128, 0x0)),
        ("divd", (gen_divd, 0x0)),
        ("srawi", (gen_srawi, 0x0)),
        ("vrlw", (gen_vrlw, 0x0)),
        ("stvewx", (gen_stvewx, 0x0)),
        ("vmaddcfp128", (gen_vmaddcfp128, 0x0)),
        ("bgtlrl+", (gen_bgtlr, 0x200001)),
        ("divduo.", (gen_divdu, 0x401)),
        ("extlwi", (gen_extlwi, 0x0)),
        ("vsrah", (gen_vsrah, 0x0)),
        ("addme.", (gen_addme, 0x1)),
        ("bdnz-", (gen_bdnz, 0x200000)),
        ("lwz", (gen_lwz, 0x0)),
        ("bdnzflrl", (gen_bdnzflr, 0x1)),
        ("lha", (gen_lha, 0x0)),
        ("stmw", (gen_stmw, 0x0)),
        ("vcfsx128", (gen_vcfsx128, 0x0)),
        ("vpkuwum128", (gen_vpkuwum128, 0x0)),
        ("rotrwi.", (gen_rotrwi, 0x1)),
        ("vavgub", (gen_vavgub, 0x0)),
        ("bc-", (gen_bc, 0x200000)),
        ("vmsum3fp128", (gen_vmsum3fp128, 0x0)),
        ("vsubsws", (gen_vsubsws, 0x0)),
        ("bdzlrl+", (gen_bdzlr, 0x200001)),
        ("bgectrl", (gen_bgectr, 0x1)),
        ("xor", (gen_xor, 0x0)),
        ("vcmpgtsw.", (gen_vcmpgtsw, 0x400)),
        ("vsro", (gen_vsro, 0x0)),
        ("stvrx128", (gen_stvrx128, 0x0)),
        ("vcfux128", (gen_vcfux128, 0x0)),
        ("vctuxs", (gen_vctuxs, 0x0)),
        ("bgtctrl+", (gen_bgtctr, 0x200001)),
        ("bdnztlr+", (gen_bdnztlr, 0x200000)),
        ("srd.", (gen_srd, 0x1)),
        ("tw", (gen_tw, 0x0)),
        ("cror", (gen_cror, 0x0)),
        ("bdnzflr+", (gen_bdnzflr, 0x200000)),
        ("dcbtst", (gen_dcbtst, 0x0)),
        ("bgtctr", (gen_bgtctr, 0x0)),
        ("mtfsb0", (gen_mtfsb0, 0x0)),
        ("vsububm", (gen_vsububm, 0x0)),
        ("bsolr+", (gen_bsolr, 0x200000)),
        ("beqa-", (gen_beq, 0x200002)),
        ("subfe.", (gen_subfe, 0x1)),
        ("fcmpu", (gen_fcmpu, 0x0)),
        ("vcmpgtsb", (gen_vcmpgtsb, 0x0)),
        ("subfe", (gen_subfe, 0x0)),
        ("vcmpgtfp128", (gen_vcmpgtfp128, 0x0)),
        ("fadd.", (gen_fadd, 0x1)),
        ("fctidz.", (gen_fctidz, 0x1)),
        ("vpkuhus128", (gen_vpkuhus128, 0x0)),
        ("fmadds.", (gen_fmadds, 0x1)),
        ("dcbst", (gen_dcbst, 0x0)),
        ("vmsummbm", (gen_vmsummbm, 0x0)),
        ("mtear", (gen_mtear, 0x0)),
        ("bgelrl+", (gen_bgelr, 0x200001)),
        ("vspltw128", (gen_vspltw128, 0x0)),
        ("mcrf", (gen_mcrf, 0x0)),
        ("vrefp128", (gen_vrefp128, 0x0)),
        ("mtfsfi.", (gen_mtfsfi, 0x1)),
        ("lwa", (gen_lwa, 0x0)),
        ("vspltisw", (gen_vspltisw, 0x0)),
        ("fmsubs.", (gen_fmsubs, 0x1)),
        ("mtmsrd", (gen_mtmsrd, 0x0)),
        ("lswi", (gen_lswi, 0x0)),
        ("extrwi", (gen_extrwi, 0x0)),
        ("frsp.", (gen_frsp, 0x1)),
        ("vxor128", (gen_vxor128, 0x0)),
        ("bnslrl+", (gen_bnslr, 0x200001)),
        ("vmsum4fp128", (gen_vmsum4fp128, 0x0)),
        ("frsqrte.", (gen_frsqrte, 0x1)),
        ("mtsr", (gen_mtsr, 0x0)),
        ("ble-", (gen_ble, 0x200000)),
        ("fdiv.", (gen_fdiv, 0x1)),
        ("bdzfa-", (gen_bdzf, 0x200002)),
        ("vminuw", (gen_vminuw, 0x0)),
        ("mtfsf", (gen_mtfsf, 0x0)),
        ("crnor", (gen_crnor, 0x0)),
        ("divwo.", (gen_divw, 0x401)),
        ("stvx", (gen_stvx, 0x0)),
        ("blel", (gen_ble, 0x1)),
        ("vpkswus", (gen_vpkswus, 0x0)),
        ("lfsux", (gen_lfsux, 0x0)),
        ("addzeo", (gen_addze, 0x400)),
        ("extlwi.", (gen_extlwi, 0x1)),
        ("fdiv", (gen_fdiv, 0x0)),
        ("clrrwi.", (gen_clrrwi, 0x1)),
        ("mulhw.", (gen_mulhw, 0x1)),
        ("bdnzta-", (gen_bdnzt, 0x200002)),
        ("vcmpgtsh.", (gen_vcmpgtsh, 0x400)),
        ("bdzflr", (gen_bdzflr, 0x0)),
        ("lwarx", (gen_lwarx, 0x0)),
        ("ldx", (gen_ldx, 0x0)),
        ("rldic", (gen_rldic, 0x0)),
        ("fadd", (gen_fadd, 0x0)),
        ("bnsctrl+", (gen_bnsctr, 0x200001)),
        ("bnelrl", (gen_bnelr, 0x1)),
        ("vpkshss", (gen_vpkshss, 0x0)),
        ("bnslr", (gen_bnslr, 0x0)),
        ("subfzeo", (gen_subfze, 0x400)),
        ("bsoctrl", (gen_bsoctr, 0x1)),
        ("vmladduhm", (gen_vmladduhm, 0x0)),
        ("crset", (gen_crset, 0x0)),
        ("fabs.", (gen_fabs, 0x1)),
        ("vadduhm", (gen_vadduhm, 0x0)),
        ("bdnztlrl", (gen_bdnztlr, 0x1)),
        ("ble+", (gen_ble, 0x200000)),
        ("bnectrl+", (gen_bnectr, 0x200001)),
        ("lhzux", (gen_lhzux, 0x0)),
        ("vrlb", (gen_vrlb, 0x0)),
        ("mfear", (gen_mfear, 0x0)),
        ("vsrab", (gen_vsrab, 0x0)),
        ("bgela", (gen_bge, 0x3)),
        ("tlbsync", (gen_tlbsync, 0x0)),
        ("sradi", (gen_sradi, 0x0)),
        ("bdzf-", (gen_bdzf, 0x200000)),
        ("vpkswss128", (gen_vpkswss128, 0x0)),
        ("rlwinm", (gen_rlwinm, 0x0)),
        ("fnabs.", (gen_fnabs, 0x1)),
        ("fctiwz", (gen_fctiwz, 0x0)),
        ("fnmadd", (gen_fnmadd, 0x0)),
        ("fsubs", (gen_fsubs, 0x0)),
        ("vspltish", (gen_vspltish, 0x0)),
        ("vminsw", (gen_vminsw, 0x0)),
        ("lwzux", (gen_lwzux, 0x0)),
        ("subfeo", (gen_subfe, 0x400)),
        ("eqv", (gen_eqv, 0x0)),
        ("bdnztla-", (gen_bdnzt, 0x200003)),
        ("vsro128", (gen_vsro128, 0x0)),
        ("vcmpgtuh.", (gen_vcmpgtuh, 0x400)),
        ("stswi", (gen_stswi, 0x0)),
        ("bdnztlr", (gen_bdnztlr, 0x0)),
        ("andi.", (gen_andi_, 0x0)),
        ("bsoa+", (gen_bso, 0x200002)),
        ("bgela+", (gen_bge, 0x200003)),
        ("vslo128", (gen_vslo128, 0x0)),
        ("vmrglw", (gen_vmrglw, 0x0)),
        ("cmpi", (gen_cmpi, 0x0)),
        ("vmulfp128", (gen_vmulfp128, 0x0)),
        ("bdnzfl", (gen_bdnzf, 0x1)),
        ("addmeo.", (gen_addme, 0x401)),
        ("crandc", (gen_crandc, 0x0)),
        ("bnsla-", (gen_bns, 0x200003)),
        ("slw.", (gen_slw, 0x1)),
        ("vcmpequw128.", (gen_vcmpequw128, 0x40)),
        ("bsola", (gen_bso, 0x3)),
        ("fabs", (gen_fabs, 0x0)),
        ("mttbl", (gen_mttbl, 0x0)),
        ("fcfid", (gen_fcfid, 0x0)),
        ("dstst", (gen_dstst, 0x0)),
        ("subfme", (gen_subfme, 0x0)),
        ("fnmadds", (gen_fnmadds, 0x0)),
        ("divd.", (gen_divd, 0x1)),
        ("mtfsf.", (gen_mtfsf, 0x1)),
        ("bgtla", (gen_bgt, 0x3)),
        ("addc", (gen_addc, 0x0)),
        ("beqa+", (gen_beq, 0x200002)),
        ("rlwnm", (gen_rlwnm, 0x0)),
        ("vcmpeqfp128", (gen_vcmpeqfp128, 0x0)),
        ("lvx128", (gen_lvx128, 0x0)),
        ("mfcr", (gen_mfcr, 0x0)),
        ("fsub.", (gen_fsub, 0x1)),
        ("vsrh", (gen_vsrh, 0x0)),
        ("bgta", (gen_bgt, 0x2)),
        ("vmulesb", (gen_vmulesb, 0x0)),
        ("mtctr", (gen_mtctr, 0x0)),
        ("fneg.", (gen_fneg, 0x1)),
        ("vmulosb", (gen_vmulosb, 0x0)),
        ("lwsync", (gen_lwsync, 0x0)),
        ("srwi.", (gen_srwi, 0x1)),
        ("eieio", (gen_eieio, 0x0)),
        ("lvewx", (gen_lvewx, 0x0)),
        ("vminuh", (gen_vminuh, 0x0)),
        ("bnsla", (gen_bns, 0x3)),
        ("crmove", (gen_crmove, 0x0)),
        ("divw.", (gen_divw, 0x1)),
        ("bdzf", (gen_bdzf, 0x0)),
        ("dst", (gen_dst, 0x0)),
        ("rfi", (gen_rfi, 0x0)),
        ("bdzt", (gen_bdzt, 0x0)),
        ("mtdbatu", (gen_mtdbatu, 0x0)),
        ("vupklpx", (gen_vupklpx, 0x0)),
        ("lvlxl", (gen_lvlxl, 0x0)),
        ("vcmpgtfp", (gen_vcmpgtfp, 0x0)),
        ("mulhdu", (gen_mulhdu, 0x0)),
        ("subfme.", (gen_subfme, 0x1)),
        ("bdzta+", (gen_bdzt, 0x200002)),
        ("addzeo.", (gen_addze, 0x401)),
        ("bdztl", (gen_bdzt, 0x1)),
        ("bdnzf-", (gen_bdnzf, 0x200000)),
        ("mtfsb1.", (gen_mtfsb1, 0x1)),
        ("li", (gen_li, 0x0)),
        ("lhax", (gen_lhax, 0x0)),
        ("beqlrl+", (gen_beqlr, 0x200001)),
        ("addeo.", (gen_adde, 0x401)),
        ("bsola+", (gen_bso, 0x200003)),
        ("tdlnl", (gen_tdlnl, 0x0)),
        ("lfdux", (gen_lfdux, 0x0)),
        ("bnelr+", (gen_bnelr, 0x200000)),
        ("dcbz_l", (gen_dcbz_l, 0x0)),
        ("cmpli", (gen_cmpli, 0x0)),
        ("vupklsb128", (gen_vupklsb128, 0x0)),
        ("stdu", (gen_stdu, 0x0)),
        ("vand128", (gen_vand128, 0x0)),
        ("mtcrf", (gen_mtcrf, 0x0)),
        ("fmsub", (gen_fmsub, 0x0)),
        ("bnsa-", (gen_bns, 0x200002)),
        ("twllei", (gen_twllei, 0x0)),
        ("vupklsb", (gen_vupklsb, 0x0)),
        ("bdztla+", (gen_bdzt, 0x200003)),
        ("twgti", (gen_twgti, 0x0)),
        ("stvlxl128", (gen_stvlxl128, 0x0)),
        ("blt", (gen_blt, 0x0)),
        ("bdnzf+", (gen_bdnzf, 0x200000)),
        ("vexptefp128", (gen_vexptefp128, 0x0)),
        ("vsel128", (gen_vsel128, 0x0)),
        ("blela", (gen_ble, 0x3)),
        ("vrfiz128", (gen_vrfiz128, 0x0)),
        ("trap", (gen_trap, 0x0)),
        ("bdztla-", (gen_bdzt, 0x200003)),
        ("lhzu", (gen_lhzu, 0x0)),
        ("vcmpequw", (gen_vcmpequw, 0x0)),
        ("ptesync", (gen_ptesync, 0x0)),
        ("stbx", (gen_stbx, 0x0)),
        ("bcctrl", (gen_bcctr, 0x1)),
        ("vsraw128", (gen_vsraw128, 0x0)),
        ("vmsumubm", (gen_vmsumubm, 0x0)),
        ("vsububs", (gen_vsububs, 0x0)),
        ("subfze", (gen_subfze, 0x0)),
        ("mcrfs", (gen_mcrfs, 0x0)),
        ("stb", (gen_stb, 0x0)),
        ("nego.", (gen_neg, 0x401)),
        ("vnot", (gen_vnot, 0x0)),
        ("fdivs", (gen_fdivs, 0x0)),
        ("vsubsbs", (gen_vsubsbs, 0x0)),
        ("vcmpgtuh", (gen_vcmpgtuh, 0x0)),
        ("beqctr", (gen_beqctr, 0x0)),
        ("bso", (gen_bso, 0x0)),
        ("adde.", (gen_adde, 0x1)),
        ("mr.", (gen_mr, 0x1)),
        ("stwux", (gen_stwux, 0x0)),
        ("bgtctrl", (gen_bgtctr, 0x1)),
        ("vexptefp", (gen_vexptefp, 0x0)),
        ("bgt", (gen_bgt, 0x0)),
        ("slwi.", (gen_slwi, 0x1)),
        ("vsum2sws", (gen_vsum2sws, 0x0)),
        ("add", (gen_add, 0x0)),
        ("bge-", (gen_bge, 0x200000)),
        ("mtfsfi", (gen_mtfsfi, 0x0)),
        ("vspltb", (gen_vspltb, 0x0)),
        ("vpkuhum128", (gen_vpkuhum128, 0x0)),
        ("vcmpgefp.", (gen_vcmpgefp, 0x400)),
        ("mtlr", (gen_mtlr, 0x0)),
        ("stfsx", (gen_stfsx, 0x0)),
        ("vcmpequb", (gen_vcmpequb, 0x0)),
        ("stfs", (gen_stfs, 0x0)),
        ("lwzu", (gen_lwzu, 0x0)),
        ("extrwi.", (gen_extrwi, 0x1)),
        ("stvewx128", (gen_stvewx128, 0x0)),
        ("vsubuhs", (gen_vsubuhs, 0x0)),
        ("fctid.", (gen_fctid, 0x1)),
        ("bdnztla+", (gen_bdnzt, 0x200003)),
        ("bdz+", (gen_bdz, 0x200000)),
        ("bnectr+", (gen_bnectr, 0x200000)),
        ("bne-", (gen_bne, 0x200000)),
        ("stbux", (gen_stbux, 0x0)),
        ("bdzfl+", (gen_bdzf, 0x200001)),
        ("lhz", (gen_lhz, 0x0)),
        ("fnmsubs", (gen_fnmsubs, 0x0)),
        ("blectr", (gen_blectr, 0x0)),
        ("tdi", (gen_tdi, 0x0)),
        ("slw", (gen_slw, 0x0)),
        ("bc+", (gen_bc, 0x200000)),
        ("vpkshus128", (gen_vpkshus128, 0x0)),
        ("std", (gen_std, 0x0)),
        ("vcmpgefp", (gen_vcmpgefp, 0x0)),
        ("bso+", (gen_bso, 0x200000)),
        ("subis", (gen_subis, 0x0)),
        ("bdnzt+", (gen_bdnzt, 0x200000)),
        ("mtsrr0", (gen_mtsrr0, 0x0)),
        ("cmpw", (gen_cmpw, 0x0)),
        ("mulhwu.", (gen_mulhwu, 0x1)),
        ("bdnzf", (gen_bdnzf, 0x0)),
        ("bdnzfla", (gen_bdnzf, 0x3)),
        ("vmaxsw", (gen_vmaxsw, 0x0)),
        ("addic", (gen_addic, 0x0)),
        ("fnmsubs.", (gen_fnmsubs, 0x1)),
        ("mfsrr1", (gen_mfsrr1, 0x0)),
        ("bsoa-", (gen_bso, 0x200002)),
        ("vupkhsh128", (gen_vupkhsh128, 0x0)),
        ("bdzfla-", (gen_bdzf, 0x200003)),
        ("crxor", (gen_crxor, 0x0)),
        ("stfdux", (gen_stfdux, 0x0)),
        ("addo", (gen_add, 0x400)),
        ("vsubuhm", (gen_vsubuhm, 0x0)),
        ("lhau", (gen_lhau, 0x0)),
        ("bla", (gen_b, 0x3)),
        ("vmuloub", (gen_vmuloub, 0x0)),
        ("lvlx128", (gen_lvlx128, 0x0)),
        ("mtsrdin", (gen_mtsrdin, 0x0)),
        ("beqlr+", (gen_beqlr, 0x200000)),
        ("bltctr+", (gen_bltctr, 0x200000)),
        ("stwcx.", (gen_stwcx_, 0x0)),
        ("eciwx", (gen_eciwx, 0x0)),
        ("subf", (gen_subf, 0x0)),
        ("bne", (gen_bne, 0x0)),
        ("sraw.", (gen_sraw, 0x1)),
        ("bdzla+", (gen_bdz, 0x200003)),
        ("eqv.", (gen_eqv, 0x1)),
        ("vrlh", (gen_vrlh, 0x0)),
        ("bdzfa+", (gen_bdzf, 0x200002)),
        ("bsoa", (gen_bso, 0x2)),
        ("nor.", (gen_nor, 0x1)),
        ("bdzl-", (gen_bdz, 0x200001)),
        ("cntlzd", (gen_cntlzd, 0x0)),
        ("fctid", (gen_fctid, 0x0)),
        ("bdztl+", (gen_bdzt, 0x200001)),
        ("vslw", (gen_vslw, 0x0)),
        ("vcmpeqfp128.", (gen_vcmpeqfp128, 0x40)),
        ("vaddshs", (gen_vaddshs, 0x0)),
        ("vpkuwus128", (gen_vpkuwus128, 0x0)),
        ("mullw.", (gen_mullw, 0x1)),
        ("vspltisw128", (gen_vspltisw128, 0x0)),
        ("bdzta", (gen_bdzt, 0x2)),
        ("lfdu", (gen_lfdu, 0x0)),
        ("sthux", (gen_sthux, 0x0)),
        ("bltla", (gen_blt, 0x3)),
        ("bdztlrl+", (gen_bdztlr, 0x200001)),
        ("bsol-", (gen_bso, 0x200001)),
        ("vcmpbfp.", (gen_vcmpbfp, 0x400)),
        ("vupkhsb128", (gen_vupkhsb128, 0x0)),
        ("subfze.", (gen_subfze, 0x1)),
        ("beql", (gen_beq, 0x1)),
        ("vcmpbfp128", (gen_vcmpbfp128, 0x0)),
        ("mfsrin", (gen_mfsrin, 0x0)),
        ("vsum4shs", (gen_vsum4shs, 0x0)),
        ("vmaddfp", (gen_vmaddfp, 0x0)),
        ("vaddubm", (gen_vaddubm, 0x0)),
        ("stvxl128", (gen_stvxl128, 0x0)),
        ("beqa", (gen_beq, 0x2)),
        ("bnela-", (gen_bne, 0x200003)),
        ("vrfip128", (gen_vrfip128, 0x0)),
        ("mtsrr1", (gen_mtsrr1, 0x0)),
        ("srawi.", (gen_srawi, 0x1)),
        ("bsol+", (gen_bso, 0x200001)),
        ("vcfux", (gen_vcfux, 0x0)),
        ("vctsxs", (gen_vctsxs, 0x0)),
        ("bnslr+", (gen_bnslr, 0x200000)),
        ("bgtla-", (gen_bgt, 0x200003)),
        ("stfdu", (gen_stfdu, 0x0)),
        ("blt-", (gen_blt, 0x200000)),
        ("bns+", (gen_bns, 0x200000)),
        ("bnectrl", (gen_bnectr, 0x1)),
        ("twi", (gen_twi, 0x0)),
        ("vxor", (gen_vxor, 0x0)),
        ("fnmadds.", (gen_fnmadds, 0x1)),
        ("oris", (gen_oris, 0x0)),
        ("mfsr", (gen_mfsr, 0x0)),
        ("vmsumuhm", (gen_vmsumuhm, 0x0)),
        ("bsolr", (gen_bsolr, 0x0)),
        ("tlbie", (gen_tlbie, 0x0)),
        ("rotld.", (gen_rotld, 0x1)),
        ("bnea", (gen_bne, 0x2)),
        ("blel+", (gen_ble, 0x200001)),
        ("bcla", (gen_bc, 0x3)),
        ("bdzlr", (gen_bdzlr, 0x0)),
        ("vslh", (gen_vslh, 0x0)),
        ("subfco", (gen_subfc, 0x400)),
        ("rotrwi", (gen_rotrwi, 0x0)),
        ("vperm", (gen_vperm, 0x0)),
        ("vcmpgefp128", (gen_vcmpgefp128, 0x0)),
        ("lvlx", (gen_lvlx, 0x0)),
        ("vcmpequw.", (gen_vcmpequw, 0x400)),
        ("rlwnm.", (gen_rlwnm, 0x1)),
        ("stdcx.", (gen_stdcx_, 0x0)),
        ("mffs.", (gen_mffs, 0x1)),
        ("fmadd", (gen_fmadd, 0x0)),
        ("fmadd.", (gen_fmadd, 0x1)),
        ("vcmpgtsb.", (gen_vcmpgtsb, 0x400)),
        ("bgectr", (gen_bgectr, 0x0)),
        ("rotlw", (gen_rotlw, 0x0)),
        ("bdnzt-", (gen_bdnzt, 0x200000)),
        ("bgela-", (gen_bge, 0x200003)),
        ("bgea", (gen_bge, 0x2)),
        ("bltlrl", (gen_bltlr, 0x1)),
        ("twui", (gen_twui, 0x0)),
        ("vaddsws", (gen_vaddsws, 0x0)),
        ("vlogefp128", (gen_vlogefp128, 0x0)),
        ("vsum4ubs", (gen_vsum4ubs, 0x0)),
        ("blrl", (gen_blr, 0x1)),
        ("vsubshs", (gen_vsubshs, 0x0)),
        ("dss", (gen_dss, 0x0)),
        ("lbzux", (gen_lbzux, 0x0)),
        ("fsel", (gen_fsel, 0x0)),
        ("rldicr", (gen_rldicr, 0x0)),
        ("beqla", (gen_beq, 0x3)),
        ("lvewx128", (gen_lvewx128, 0x0)),
        ("srwi", (gen_srwi, 0x0)),
        ("mtdar", (gen_mtdar, 0x0)),
        ("mfdbatl", (gen_mfdbatl, 0x0)),
        ("rotlw.", (gen_rotlw, 0x1)),
        ("vcmpequw128", (gen_vcmpequw128, 0x0)),
        ("bsolrl", (gen_bsolr, 0x1)),
        ("lvrxl", (gen_lvrxl, 0x0)),
        ("bdzta-", (gen_bdzt, 0x200002)),
        ("vnmsubfp", (gen_vnmsubfp, 0x0)),
        ("addo.", (gen_add, 0x401)),
        ("lwaux", (gen_lwaux, 0x0)),
        ("mtdec", (gen_mtdec, 0x0)),
        ("bdnzfa+", (gen_bdnzf, 0x200002)),
        ("vcmpgefp128.", (gen_vcmpgefp128, 0x40)),
        ("stvxl", (gen_stvxl, 0x0)),
        ("cmpld", (gen_cmpld, 0x0)),
        ("sld", (gen_sld, 0x0)),
        ("cmplwi", (gen_cmplwi, 0x0)),
        ("bdzf+", (gen_bdzf, 0x200000)),
        ("fnmsub.", (gen_fnmsub, 0x1)),
        ("lvsl128", (gen_lvsl128, 0x0)),
        ("vminfp", (gen_vminfp, 0x0)),
        ("beqctr+", (gen_beqctr, 0x200000)),
        ("beqlrl", (gen_beqlr, 0x1)),
        ("bdnzta+", (gen_bdnzt, 0x200002)),
        ("mullwo", (gen_mullw, 0x400)),
        ("vcmpgtub", (gen_vcmpgtub, 0x0)),
        ("bctrl", (gen_bctr, 0x1)),
        ("mfctr", (gen_mfctr, 0x0)),
        ("vmrglh", (gen_vmrglh, 0x0)),
        ("vsrw", (gen_vsrw, 0x0)),
        ("bdnzl-", (gen_bdnz, 0x200001)),
        ("mfdec", (gen_mfdec, 0x0)),
        ("lvehx", (gen_lvehx, 0x0)),
        ("bclr+", (gen_bclr, 0x200000)),
        ("beqctrl+", (gen_beqctr, 0x200001)),
        ("bdnztl", (gen_bdnzt, 0x1)),
        ("stvlx", (gen_stvlx, 0x0)),
        ("vmrglb", (gen_vmrglb, 0x0)),
        ("vctuxs128", (gen_vctuxs128, 0x0)),
        ("bdnztla", (gen_bdnzt, 0x3)),
        ("bdnztl+", (gen_bdnzt, 0x200001)),
        ("vpkuhus", (gen_vpkuhus, 0x0)),
        ("mfmsr", (gen_mfmsr, 0x0)),
        ("extsw.", (gen_extsw, 0x1)),
        ("stswx", (gen_stswx, 0x0)),
        ("addic.", (gen_addic_, 0x0)),
        ("sraw", (gen_sraw, 0x0)),
        ("bnsl-", (gen_bns, 0x200001)),
        ("vcmpgtuw", (gen_vcmpgtuw, 0x0)),
        ("dcbf", (gen_dcbf, 0x0)),
        ("vnor", (gen_vnor, 0x0)),
        ("rldic.", (gen_rldic, 0x1)),
        ("blelr", (gen_blelr, 0x0)),
        ("icbi", (gen_icbi, 0x0)),
        ("bltlr+", (gen_bltlr, 0x200000)),
        ("vsel", (gen_vsel, 0x0)),
        ("lhzx", (gen_lhzx, 0x0)),
        ("subfc.", (gen_subfc, 0x1)),
        ("bnsctr", (gen_bnsctr, 0x0)),
        ("dcbz", (gen_dcbz, 0x0)),
        ("vmsumshs", (gen_vmsumshs, 0x0)),
        ("bdztl-", (gen_bdzt, 0x200001)),
        ("vsubfp128", (gen_vsubfp128, 0x0)),
        ("vmuleuh", (gen_vmuleuh, 0x0)),
        ("isync", (gen_isync, 0x0)),
        ("stvx128", (gen_stvx128, 0x0)),
        ("bdnzfla+", (gen_bdnzf, 0x200003)),
        ("vmaxuw", (gen_vmaxuw, 0x0)),
        ("blelrl", (gen_blelr, 0x1)),
        ("mfvscr", (gen_mfvscr, 0x0)),
        ("vsubfp", (gen_vsubfp, 0x0)),
        ("vcmpgtsw", (gen_vcmpgtsw, 0x0)),
        ("srad", (gen_srad, 0x0)),
        ("vrfin", (gen_vrfin, 0x0)),
        ("vpkuwus", (gen_vpkuwus, 0x0)),
        ("vpkuhum", (gen_vpkuhum, 0x0)),
        ("mulld.", (gen_mulld, 0x1)),
        ("lvrxl128", (gen_lvrxl128, 0x0)),
        ("bdnzflr", (gen_bdnzflr, 0x0)),
        ("rldimi.", (gen_rldimi, 0x1)),
        ("mullwo.", (gen_mullw, 0x401)),
        ("mtsrd", (gen_mtsrd, 0x0)),
        ("vcmpbfp", (gen_vcmpbfp, 0x0)),
        ("subfo.", (gen_subf, 0x401)),
        ("lfsu", (gen_lfsu, 0x0)),
        ("bltlrl+", (gen_bltlr, 0x200001)),
        ("fsubs.", (gen_fsubs, 0x1)),
        ("mulhdu.", (gen_mulhdu, 0x1)),
        ("cmpd", (gen_cmpd, 0x0)),
        ("bso-", (gen_bso, 0x200000)),
        ("ldux", (gen_ldux, 0x0)),
        ("fnabs", (gen_fnabs, 0x0)),
        ("mtspr", (gen_mtspr, 0x0)),
        ("mulhd", (gen_mulhd, 0x0)),
        ("mtdbatl", (gen_mtdbatl, 0x0)),
        ("addmeo", (gen_addme, 0x400)),
        ("lbz", (gen_lbz, 0x0)),
        ("fctiw.", (gen_fctiw, 0x1)),
        ("blta+", (gen_blt, 0x200002)),
        ("vupkhsh", (gen_vupkhsh, 0x0)),
        ("blectrl+", (gen_blectr, 0x200001)),
        ("vsrw128", (gen_vsrw128, 0x0)),
        ("rldicl", (gen_rldicl, 0x0)),
        ("blt+", (gen_blt, 0x200000)),
        ("beql-", (gen_beq, 0x200001)),
        ("bclr", (gen_bclr, 0x0)),
        ("mfibatl", (gen_mfibatl, 0x0)),
        ("mfdar", (gen_mfdar, 0x0)),
        ("bdzfla+", (gen_bdzf, 0x200003)),
        ("bca-", (gen_bc, 0x200002)),
        ("vupkhpx", (gen_vupkhpx, 0x0)),
        ("stwu", (gen_stwu, 0x0)),
        ("mtibatu", (gen_mtibatu, 0x0)),
        ("fmul", (gen_fmul, 0x0)),
        ("lvsr", (gen_lvsr, 0x0)),
        ("vmrglw128", (gen_vmrglw128, 0x0)),
        ("vmrghb", (gen_vmrghb, 0x0)),
        ("bdzt+", (gen_bdzt, 0x200000)),
        ("rldimi", (gen_rldimi, 0x0)),
        ("mtibatl", (gen_mtibatl, 0x0)),
        ("orc", (gen_orc, 0x0)),
        ("rlwimi", (gen_rlwimi, 0x0)),
        ("vmhraddshs", (gen_vmhraddshs, 0x0)),
        ("vpkswus128", (gen_vpkswus128, 0x0)),
        ("dssall", (gen_dssall, 0x0)),
        ("vcmpequh.", (gen_vcmpequh, 0x400)),
        ("bcctrl+", (gen_bcctr, 0x200001)),
        ("crclr", (gen_crclr, 0x0)),
        ("vupkhsb", (gen_vupkhsb, 0x0)),
        ("vslw128", (gen_vslw128, 0x0)),
        ("bnel+", (gen_bne, 0x200001)),
        ("vsldoi128", (gen_vsldoi128, 0x0)),
        ("stdux", (gen_stdux, 0x0)),
        ("bdztlr+", (gen_bdztlr, 0x200000)),
        ("addme", (gen_addme, 0x0)),
        ("fcmpo", (gen_fcmpo, 0x0)),
        ("stfsux", (gen_stfsux, 0x0)),
        ("blta-", (gen_blt, 0x200002)),
        ("vaddcuw", (gen_vaddcuw, 0x0)),
        ("bnea+", (gen_bne, 0x200002)),
        ("bgtlr+", (gen_bgtlr, 0x200000)),
    ],
};
pub fn assemble(mnemonic: &str, args: &Arguments) -> Result<u32, ArgumentError> {
    if let Some(&(fn_ptr, modifiers)) = MNEMONIC_MAP.get(mnemonic) {
        fn_ptr(args, modifiers)
    } else {
        Err(ArgumentError::UnknownMnemonic)
    }
}
