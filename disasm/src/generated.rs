#![allow(unused)]
#![cfg_attr(rustfmt, rustfmt_skip)]
// Code generated by ppc750-genisa. DO NOT EDIT.
use crate::disasm::*;
/// The entry table allows us to quickly find the range of possible opcodes for a
/// given 6-bit prefix. 2*64 bytes should fit in a cache line (or two).
static OPCODE_ENTRIES: [(u8, u8); 64] = [
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 1),
    (1, 35),
    (0, 0),
    (0, 0),
    (35, 36),
    (36, 37),
    (0, 0),
    (37, 38),
    (38, 39),
    (39, 40),
    (40, 41),
    (41, 42),
    (42, 43),
    (43, 44),
    (44, 45),
    (45, 46),
    (46, 59),
    (59, 60),
    (60, 61),
    (0, 0),
    (61, 62),
    (62, 63),
    (63, 64),
    (64, 65),
    (65, 66),
    (66, 67),
    (67, 68),
    (0, 0),
    (68, 160),
    (160, 161),
    (161, 162),
    (162, 163),
    (163, 164),
    (164, 165),
    (165, 166),
    (166, 167),
    (167, 168),
    (168, 169),
    (169, 170),
    (170, 171),
    (171, 172),
    (172, 173),
    (173, 174),
    (174, 175),
    (175, 176),
    (176, 177),
    (177, 178),
    (178, 179),
    (179, 180),
    (180, 181),
    (181, 182),
    (182, 183),
    (183, 184),
    (184, 185),
    (185, 186),
    (0, 0),
    (186, 195),
    (195, 196),
    (196, 197),
    (0, 0),
    (197, 222),
];
/// The bitmask and pattern for each opcode.
static OPCODE_PATTERNS: [(u32, u32); 256] = [
    (0xfc000000, 0xc000000),
    (0xffe007ff, 0x100007ec),
    (0xfc00007f, 0x1000004c),
    (0xfc00007f, 0x1000000c),
    (0xfc00007f, 0x1000004e),
    (0xfc00007f, 0x1000000e),
    (0xfc1f07fe, 0x10000210),
    (0xfc0007fe, 0x1000002a),
    (0xfc6007ff, 0x10000040),
    (0xfc6007ff, 0x100000c0),
    (0xfc6007ff, 0x10000000),
    (0xfc6007ff, 0x10000080),
    (0xfc0007fe, 0x10000024),
    (0xfc00003e, 0x1000003a),
    (0xfc00003e, 0x1000001c),
    (0xfc00003e, 0x1000001e),
    (0xfc0007fe, 0x10000420),
    (0xfc0007fe, 0x10000460),
    (0xfc0007fe, 0x100004a0),
    (0xfc0007fe, 0x100004e0),
    (0xfc1f07fe, 0x10000090),
    (0xfc00003e, 0x10000038),
    (0xfc00f83e, 0x10000032),
    (0xfc00f83e, 0x10000018),
    (0xfc00f83e, 0x1000001a),
    (0xfc1f07fe, 0x10000110),
    (0xfc1f07fe, 0x10000050),
    (0xfc00003e, 0x1000003e),
    (0xfc00003e, 0x1000003c),
    (0xfc1f07fe, 0x10000030),
    (0xfc1f07fe, 0x10000034),
    (0xfc00003e, 0x1000002e),
    (0xfc0007fe, 0x10000028),
    (0xfc00003e, 0x10000014),
    (0xfc00003e, 0x10000016),
    (0xfc000000, 0x1c000000),
    (0xfc000000, 0x20000000),
    (0xfc400000, 0x28000000),
    (0xfc400000, 0x2c000000),
    (0xfc000000, 0x30000000),
    (0xfc000000, 0x34000000),
    (0xfc000000, 0x38000000),
    (0xfc000000, 0x3c000000),
    (0xfc000000, 0x40000000),
    (0xffffffff, 0x44000002),
    (0xfc000000, 0x48000000),
    (0xfc00fffe, 0x4c000420),
    (0xfc00fffe, 0x4c000020),
    (0xfc0007ff, 0x4c000202),
    (0xfc0007ff, 0x4c000102),
    (0xfc0007ff, 0x4c000242),
    (0xfc0007ff, 0x4c0001c2),
    (0xfc0007ff, 0x4c000042),
    (0xfc0007ff, 0x4c000382),
    (0xfc0007ff, 0x4c000342),
    (0xfc0007ff, 0x4c000182),
    (0xffffffff, 0x4c00012c),
    (0xfc63ffff, 0x4c000000),
    (0xffffffff, 0x4c000064),
    (0xfc000000, 0x50000000),
    (0xfc000000, 0x54000000),
    (0xfc000000, 0x5c000000),
    (0xfc000000, 0x60000000),
    (0xfc000000, 0x64000000),
    (0xfc000000, 0x68000000),
    (0xfc000000, 0x6c000000),
    (0xfc000000, 0x70000000),
    (0xfc000000, 0x74000000),
    (0xfc0003fe, 0x7c000214),
    (0xfc0003fe, 0x7c000014),
    (0xfc0003fe, 0x7c000114),
    (0xfc00fbfe, 0x7c0001d4),
    (0xfc00fbfe, 0x7c000194),
    (0xfc0007fe, 0x7c000038),
    (0xfc0007fe, 0x7c000078),
    (0xfc4007ff, 0x7c000000),
    (0xfc4007ff, 0x7c000040),
    (0xfc00fffe, 0x7c000034),
    (0xffe007ff, 0x7c0000ac),
    (0xffe007ff, 0x7c0003ac),
    (0xffe007ff, 0x7c00006c),
    (0xffe007ff, 0x7c00022c),
    (0xffe007ff, 0x7c0001ec),
    (0xffe007ff, 0x7c0007ec),
    (0xfc0003fe, 0x7c0003d6),
    (0xfc0003fe, 0x7c000396),
    (0xfc0007ff, 0x7c00026c),
    (0xfc0007ff, 0x7c00036c),
    (0xffffffff, 0x7c0006ac),
    (0xfc0007fe, 0x7c000238),
    (0xfc00fffe, 0x7c000774),
    (0xfc00fffe, 0x7c000734),
    (0xffe007fe, 0x7c0007ac),
    (0xfc0007ff, 0x7c0000ee),
    (0xfc0007ff, 0x7c0000ae),
    (0xfc0007ff, 0x7c0004ee),
    (0xfc0007ff, 0x7c0004ae),
    (0xfc0007ff, 0x7c00046e),
    (0xfc0007ff, 0x7c00042e),
    (0xfc0007ff, 0x7c0002ee),
    (0xfc0007ff, 0x7c0002ae),
    (0xfc0007ff, 0x7c00062c),
    (0xfc0007ff, 0x7c00026e),
    (0xfc0007ff, 0x7c00022e),
    (0xfc0007ff, 0x7c0004aa),
    (0xfc0007ff, 0x7c00042a),
    (0xfc0007ff, 0x7c000028),
    (0xfc0007ff, 0x7c00042c),
    (0xfc0007ff, 0x7c00006e),
    (0xfc0007ff, 0x7c00002e),
    (0xfc7fffff, 0x7c000400),
    (0xfc1fffff, 0x7c000026),
    (0xfc1fffff, 0x7c0000a6),
    (0xfc0007ff, 0x7c0002a6),
    (0xfc10ffff, 0x7c0004a6),
    (0xfc1f07ff, 0x7c000526),
    (0xfc0007ff, 0x7c0002e6),
    (0xfc100fff, 0x7c000120),
    (0xfc1fffff, 0x7c000124),
    (0xfc0007ff, 0x7c0003a6),
    (0xfc10ffff, 0x7c0001a4),
    (0xfc1f07ff, 0x7c0001e4),
    (0xfc0007fe, 0x7c000096),
    (0xfc0007fe, 0x7c000016),
    (0xfc0003fe, 0x7c0001d6),
    (0xfc0007fe, 0x7c0003b8),
    (0xfc00fbfe, 0x7c0000d0),
    (0xfc0007fe, 0x7c0000f8),
    (0xfc0007fe, 0x7c000378),
    (0xfc0007fe, 0x7c000338),
    (0xfc0007fe, 0x7c000030),
    (0xfc0007fe, 0x7c000630),
    (0xfc0007fe, 0x7c000670),
    (0xfc0007fe, 0x7c000430),
    (0xfc0007ff, 0x7c0001ee),
    (0xfc0007ff, 0x7c0001ae),
    (0xfc0007ff, 0x7c0005ee),
    (0xfc0007ff, 0x7c0005ae),
    (0xfc0007ff, 0x7c0007ae),
    (0xfc0007ff, 0x7c00056e),
    (0xfc0007ff, 0x7c00052e),
    (0xfc0007ff, 0x7c00072c),
    (0xfc0007ff, 0x7c00036e),
    (0xfc0007ff, 0x7c00032e),
    (0xfc0007ff, 0x7c0005aa),
    (0xfc0007ff, 0x7c00052a),
    (0xfc0007ff, 0x7c00052c),
    (0xfc0007ff, 0x7c00012d),
    (0xfc0007ff, 0x7c00016e),
    (0xfc0007ff, 0x7c00012e),
    (0xfc0003fe, 0x7c000050),
    (0xfc0003fe, 0x7c000010),
    (0xfc0003fe, 0x7c000110),
    (0xfc00fbfe, 0x7c0001d0),
    (0xfc00fbfe, 0x7c000190),
    (0xffffffff, 0x7c0004ac),
    (0xffff07ff, 0x7c000264),
    (0xffffffff, 0x7c00046c),
    (0xfc0007ff, 0x7c000008),
    (0xfc0007fe, 0x7c000278),
    (0xfc000000, 0x80000000),
    (0xfc000000, 0x84000000),
    (0xfc000000, 0x88000000),
    (0xfc000000, 0x8c000000),
    (0xfc000000, 0x90000000),
    (0xfc000000, 0x94000000),
    (0xfc000000, 0x98000000),
    (0xfc000000, 0x9c000000),
    (0xfc000000, 0xa0000000),
    (0xfc000000, 0xa4000000),
    (0xfc000000, 0xa8000000),
    (0xfc000000, 0xac000000),
    (0xfc000000, 0xb0000000),
    (0xfc000000, 0xb4000000),
    (0xfc000000, 0xb8000000),
    (0xfc000000, 0xbc000000),
    (0xfc000000, 0xc0000000),
    (0xfc000000, 0xc4000000),
    (0xfc000000, 0xc8000000),
    (0xfc000000, 0xcc000000),
    (0xfc000000, 0xd0000000),
    (0xfc000000, 0xd4000000),
    (0xfc000000, 0xd8000000),
    (0xfc000000, 0xdc000000),
    (0xfc000000, 0xe0000000),
    (0xfc000000, 0xe4000000),
    (0xfc0007fe, 0xec00002a),
    (0xfc0007fe, 0xec000024),
    (0xfc00003e, 0xec00003a),
    (0xfc00003e, 0xec000038),
    (0xfc00f83e, 0xec000032),
    (0xfc00003e, 0xec00003e),
    (0xfc00003e, 0xec00003c),
    (0xfc1f07fe, 0xec000030),
    (0xfc0007fe, 0xec000028),
    (0xfc000000, 0xf0000000),
    (0xfc000000, 0xf4000000),
    (0xfc1f07fe, 0xfc000210),
    (0xfc0007fe, 0xfc00002a),
    (0xfc6007ff, 0xfc000040),
    (0xfc6007ff, 0xfc000000),
    (0xfc1f07fe, 0xfc00001c),
    (0xfc1f07fe, 0xfc00001e),
    (0xfc0007fe, 0xfc000024),
    (0xfc00003e, 0xfc00003a),
    (0xfc1f07fe, 0xfc000090),
    (0xfc00003e, 0xfc000038),
    (0xfc00f83e, 0xfc000032),
    (0xfc1f07fe, 0xfc000110),
    (0xfc1f07fe, 0xfc000050),
    (0xfc00003e, 0xfc00003e),
    (0xfc00003e, 0xfc00003c),
    (0xfc1f07fe, 0xfc000018),
    (0xfc1f07fe, 0xfc000034),
    (0xfc00003e, 0xfc00002e),
    (0xfc0007fe, 0xfc000028),
    (0xfc63ffff, 0xfc000080),
    (0xfc1ffffe, 0xfc00048e),
    (0xfc1ffffe, 0xfc00008c),
    (0xfc1ffffe, 0xfc00004c),
    (0xfe0107fe, 0xfc00058e),
    (0xfc7f0ffe, 0xfc00010c),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
];
/// The name of each opcode.
static OPCODE_NAMES: [&str; 256] = [
    "twi",
    "dcbz_l",
    "psq_lux",
    "psq_lx",
    "psq_stux",
    "psq_stx",
    "ps_abs",
    "ps_add",
    "ps_cmpo0",
    "ps_cmpo1",
    "ps_cmpu0",
    "ps_cmpu1",
    "ps_div",
    "ps_madd",
    "ps_madds0",
    "ps_madds1",
    "ps_merge00",
    "ps_merge01",
    "ps_merge10",
    "ps_merge11",
    "ps_mr",
    "ps_msub",
    "ps_mul",
    "ps_muls0",
    "ps_muls1",
    "ps_nabs",
    "ps_neg",
    "ps_nmadd",
    "ps_nmsub",
    "ps_res",
    "ps_rsqrte",
    "ps_sel",
    "ps_sub",
    "ps_sum0",
    "ps_sum1",
    "mulli",
    "subfic",
    "cmpli",
    "cmpi",
    "addic",
    "addic.",
    "addi",
    "addis",
    "bc",
    "sc",
    "b",
    "bcctr",
    "bclr",
    "crand",
    "crandc",
    "creqv",
    "crnand",
    "crnor",
    "cror",
    "crorc",
    "crxor",
    "isync",
    "mcrf",
    "rfi",
    "rlwimi",
    "rlwinm",
    "rlwnm",
    "ori",
    "oris",
    "xori",
    "xoris",
    "andi.",
    "andis.",
    "add",
    "addc",
    "adde",
    "addme",
    "addze",
    "and",
    "andc",
    "cmp",
    "cmpl",
    "cntlzw",
    "dcbf",
    "dcbi",
    "dcbst",
    "dcbt",
    "dcbtst",
    "dcbz",
    "divw",
    "divwu",
    "eciwx",
    "ecowx",
    "eieio",
    "eqv",
    "extsb",
    "extsh",
    "icbi",
    "lbzux",
    "lbzx",
    "lfdux",
    "lfdx",
    "lfsux",
    "lfsx",
    "lhaux",
    "lhax",
    "lhbrx",
    "lhzux",
    "lhzx",
    "lswi",
    "lswx",
    "lwarx",
    "lwbrx",
    "lwzux",
    "lwzx",
    "mcrxr",
    "mfcr",
    "mfmsr",
    "mfspr",
    "mfsr",
    "mfsrin",
    "mftb",
    "mtcrf",
    "mtmsr",
    "mtspr",
    "mtsr",
    "mtsrin",
    "mulhw",
    "mulhwu",
    "mullw",
    "nand",
    "neg",
    "nor",
    "or",
    "orc",
    "slw",
    "sraw",
    "srawi",
    "srw",
    "stbux",
    "stbx",
    "stfdux",
    "stfdx",
    "stfiwx",
    "stfsux",
    "stfsx",
    "sthbrx",
    "sthux",
    "sthx",
    "stswi",
    "stswx",
    "stwbrx",
    "stwcx.",
    "stwux",
    "stwx",
    "subf",
    "subfc",
    "subfe",
    "subfme",
    "subfze",
    "sync",
    "tlbie",
    "tlbsync",
    "tw",
    "xor",
    "lwz",
    "lwzu",
    "lbz",
    "lbzu",
    "stw",
    "stwu",
    "stb",
    "stbu",
    "lhz",
    "lhzu",
    "lha",
    "lhau",
    "sth",
    "sthu",
    "lmw",
    "stmw",
    "lfs",
    "lfsu",
    "lfd",
    "lfdu",
    "stfs",
    "stfsu",
    "stfd",
    "stfdu",
    "psq_l",
    "psq_lu",
    "fadds",
    "fdivs",
    "fmadds",
    "fmsubs",
    "fmuls",
    "fnmadds",
    "fnmsubs",
    "fres",
    "fsubs",
    "psq_st",
    "psq_stu",
    "fabs",
    "fadd",
    "fcmpo",
    "fcmpu",
    "fctiw",
    "fctiwz",
    "fdiv",
    "fmadd",
    "fmr",
    "fmsub",
    "fmul",
    "fnabs",
    "fneg",
    "fnmadd",
    "fnmsub",
    "frsp",
    "frsqrte",
    "fsel",
    "fsub",
    "mcrfs",
    "mffs",
    "mtfsb0",
    "mtfsb1",
    "mtfsf",
    "mtfsfi",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
    "<illegal>",
];
#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]
#[repr(u8)]
#[non_exhaustive]
pub enum Opcode {
    /// An illegal or unknown opcode
    #[default]
    Illegal = u8::MAX,
    /// twi: Trap Word Immediate
    Twi = 0,
    /// dcbz_l: Data Cache Block Set to Zero Locked
    DcbzL = 1,
    /// psq_lux: Paired Single Quantized Load with Update Indexed
    PsqLux = 2,
    /// psq_lx: Paired Single Quantized Load Indexed
    PsqLx = 3,
    /// psq_stux: Paired Single Quantized Store with Update Indexed
    PsqStux = 4,
    /// psq_stx: Paired Single Quantized Store Indexed
    PsqStx = 5,
    /// ps_abs: Paired Single Absolute Value
    PsAbs = 6,
    /// ps_add: Paired Single Add
    PsAdd = 7,
    /// ps_cmpo0: Paired Singles Compare Ordered High
    PsCmpo0 = 8,
    /// ps_cmpo1: Paired Singles Compare Ordered Low
    PsCmpo1 = 9,
    /// ps_cmpu0: Paired Singles Compare Unordered High
    PsCmpu0 = 10,
    /// ps_cmpu1: Paired Singles Compare Unordered Low
    PsCmpu1 = 11,
    /// ps_div: Paired Single Divide
    PsDiv = 12,
    /// ps_madd: Paired Single Multiply-Add
    PsMadd = 13,
    /// ps_madds0: Paired Single Multiply-Add Scalar high
    PsMadds0 = 14,
    /// ps_madds1: Paired Single Multiply-Add Scalar low
    PsMadds1 = 15,
    /// ps_merge00: Paired Single MERGE high
    PsMerge00 = 16,
    /// ps_merge01: Paired Single MERGE direct
    PsMerge01 = 17,
    /// ps_merge10: Paired Single MERGE swapped
    PsMerge10 = 18,
    /// ps_merge11: Paired Single MERGE low
    PsMerge11 = 19,
    /// ps_mr: Paired Single Move Register
    PsMr = 20,
    /// ps_msub: Paired Single Multiply-Subtract
    PsMsub = 21,
    /// ps_mul: Paired Single Multiply
    PsMul = 22,
    /// ps_muls0: Paired Single Multiply Scalar high
    PsMuls0 = 23,
    /// ps_muls1: Paired Single Multiply Scalar low
    PsMuls1 = 24,
    /// ps_nabs: Paired Single Negative Absolute Value
    PsNabs = 25,
    /// ps_neg: Paired Single Negate
    PsNeg = 26,
    /// ps_nmadd: Paired Single Negative Multiply-Add
    PsNmadd = 27,
    /// ps_nmsub: Paired Single Negative Multiply-Subtract
    PsNmsub = 28,
    /// ps_res: Paired Single Reciprocal Estimate
    PsRes = 29,
    /// ps_rsqrte: Paired Single Reciprocal Square Root Estimate
    PsRsqrte = 30,
    /// ps_sel: Paired Single Select
    PsSel = 31,
    /// ps_sub: Paired Single Subtract
    PsSub = 32,
    /// ps_sum0: Paired Single vector SUM high
    PsSum0 = 33,
    /// ps_sum1: Paired Single vector SUM low
    PsSum1 = 34,
    /// mulli: Multiply Low Immediate
    Mulli = 35,
    /// subfic: Subtract from Immediate Carrying
    Subfic = 36,
    /// cmpli: Compare Logical Immediate
    Cmpli = 37,
    /// cmpi: Compare Immediate
    Cmpi = 38,
    /// addic: Add Immediate Carrying
    Addic = 39,
    /// addic.: Add Immediate Carrying and Record
    Addic_ = 40,
    /// addi: Add Immediate
    Addi = 41,
    /// addis: Add Immediate Shifted
    Addis = 42,
    /// bc: Branch Conditional
    Bc = 43,
    /// sc: System Call
    Sc = 44,
    /// b: Branch
    B = 45,
    /// bcctr: Branch Conditional to Count Register
    Bcctr = 46,
    /// bclr: Branch Conditional to Link Register
    Bclr = 47,
    /// crand: Condition Register AND
    Crand = 48,
    /// crandc: Condition Register AND with Complement
    Crandc = 49,
    /// creqv: Condition Register Equivalent
    Creqv = 50,
    /// crnand: Condition Register NAND
    Crnand = 51,
    /// crnor: Condition Register NOR
    Crnor = 52,
    /// cror: Condition Register OR
    Cror = 53,
    /// crorc: Condition Register OR with Complement
    Crorc = 54,
    /// crxor: Condition Register XOR
    Crxor = 55,
    /// isync: Instruction Synchronize
    Isync = 56,
    /// mcrf: Move Condition Register Field
    Mcrf = 57,
    /// rfi: Return from Interrupt
    Rfi = 58,
    /// rlwimi: Rotate Left Word Immediate then Mask Insert
    Rlwimi = 59,
    /// rlwinm: Rotate Left Word Immediate then AND with Mask
    Rlwinm = 60,
    /// rlwnm: Rotate Left Word then AND with Mask
    Rlwnm = 61,
    /// ori: OR Immediate
    Ori = 62,
    /// oris: OR Immediate Shifted
    Oris = 63,
    /// xori: XOR Immediate
    Xori = 64,
    /// xoris: XOR Immediate Shifted
    Xoris = 65,
    /// andi.: AND Immediate
    Andi_ = 66,
    /// andis.: AND Immediate Shifted
    Andis_ = 67,
    /// add: Add
    Add = 68,
    /// addc: Add Carrying
    Addc = 69,
    /// adde: Add Extended
    Adde = 70,
    /// addme: Add to Minus One Extended
    Addme = 71,
    /// addze: Add to Zero Extended
    Addze = 72,
    /// and: AND
    And = 73,
    /// andc: AND with Complement
    Andc = 74,
    /// cmp: Compare
    Cmp = 75,
    /// cmpl: Compare Logical
    Cmpl = 76,
    /// cntlzw: Count Leading Zeros Word
    Cntlzw = 77,
    /// dcbf: Data Cache Block Flush
    Dcbf = 78,
    /// dcbi: Data Cache Block Invalidate
    Dcbi = 79,
    /// dcbst: Data Cache Block Store
    Dcbst = 80,
    /// dcbt: Data Cache Block Touch
    Dcbt = 81,
    /// dcbtst: Data Cache Block Touch for Store
    Dcbtst = 82,
    /// dcbz: Data Cache Block Clear to Zero
    Dcbz = 83,
    /// divw: Divide Word
    Divw = 84,
    /// divwu: Divide Word Unsigned
    Divwu = 85,
    /// eciwx: External Control In Word Indexed
    Eciwx = 86,
    /// ecowx: External Control Out Word Indexed
    Ecowx = 87,
    /// eieio: Enforce In-Order Execution of I/O
    Eieio = 88,
    /// eqv: Equivalent
    Eqv = 89,
    /// extsb: Extend Sign Byte
    Extsb = 90,
    /// extsh: Extend Sign Half Word
    Extsh = 91,
    /// icbi: Instruction Cache Block Invalidate
    Icbi = 92,
    /// lbzux: Load Byte and Zero with Update Indexed
    Lbzux = 93,
    /// lbzx: Load Byte and Zero Indexed
    Lbzx = 94,
    /// lfdux: Load Floating-Point Double with Update Indexed
    Lfdux = 95,
    /// lfdx: Load Floating-Point Double Indexed
    Lfdx = 96,
    /// lfsux: Load Floating-Point Single with Update Indexed
    Lfsux = 97,
    /// lfsx: Load Floating-Point Single Indexed
    Lfsx = 98,
    /// lhaux: Load Half Word Algebraic with Update Indexed
    Lhaux = 99,
    /// lhax: Load Half Word Algebraic Indexed
    Lhax = 100,
    /// lhbrx: Load Half Word Byte-Reverse Indexed
    Lhbrx = 101,
    /// lhzux: Load Half Word and Zero with Update Indexed
    Lhzux = 102,
    /// lhzx: Load Half Word and Zero Indexed
    Lhzx = 103,
    /// lswi: Load String Word Immediate
    Lswi = 104,
    /// lswx: Load String Word Indexed
    Lswx = 105,
    /// lwarx: Load String Word and Reverse Indexed
    Lwarx = 106,
    /// lwbrx: Load String Word and Byte-Reverse Indexed
    Lwbrx = 107,
    /// lwzux: Load Word and Zero with Update Indexed
    Lwzux = 108,
    /// lwzx: Load Word and Zero Indexed
    Lwzx = 109,
    /// mcrxr: Move to Condition Register from XER
    Mcrxr = 110,
    /// mfcr: Move from Condition Register
    Mfcr = 111,
    /// mfmsr: Move from Machine State Register
    Mfmsr = 112,
    /// mfspr: Move from Special-Purpose Register
    Mfspr = 113,
    /// mfsr: Move from Segment Register
    Mfsr = 114,
    /// mfsrin: Move from Segment Register Indirect
    Mfsrin = 115,
    /// mftb: Move from Time Base
    Mftb = 116,
    /// mtcrf: Move to Condition Register Fields
    Mtcrf = 117,
    /// mtmsr: Move to Machine State Register
    Mtmsr = 118,
    /// mtspr: Move to Special-Purpose Register
    Mtspr = 119,
    /// mtsr: Move to Segment Register
    Mtsr = 120,
    /// mtsrin: Move to Segment Register Indirect
    Mtsrin = 121,
    /// mulhw: Multiply High Word
    Mulhw = 122,
    /// mulhwu: Multiply High Word Unsigned
    Mulhwu = 123,
    /// mullw: Multiply Low Word
    Mullw = 124,
    /// nand: NAND
    Nand = 125,
    /// neg: Negate
    Neg = 126,
    /// nor: NOR
    Nor = 127,
    /// or: OR
    Or = 128,
    /// orc: OR with Complement
    Orc = 129,
    /// slw: Shift Left Word
    Slw = 130,
    /// sraw: Shift Right Algebraic Word
    Sraw = 131,
    /// srawi: Shift Right Algebraic Word Immediate
    Srawi = 132,
    /// srw: Shift Right Word
    Srw = 133,
    /// stbux: Store Byte with Update Indexed
    Stbux = 134,
    /// stbx: Store Byte Indexed
    Stbx = 135,
    /// stfdux: Store Floating-Point Double with Update Indexed
    Stfdux = 136,
    /// stfdx: Store Floating-Point Double Indexed
    Stfdx = 137,
    /// stfiwx: Store Floating-Point as Integer Word Indexed
    Stfiwx = 138,
    /// stfsux: Store Floating-Point Single with Update Indexed
    Stfsux = 139,
    /// stfsx: Store Floating-Point Single Indexed
    Stfsx = 140,
    /// sthbrx: Store Half Word Byte-Reverse Indexed
    Sthbrx = 141,
    /// sthux: Store Half Word with Update Indexed
    Sthux = 142,
    /// sthx: Store Half Word Indexed
    Sthx = 143,
    /// stswi: Store String Word Immediate
    Stswi = 144,
    /// stswx: Store String Word Indexed
    Stswx = 145,
    /// stwbrx: Store Word Byte-Reverse Indexed
    Stwbrx = 146,
    /// stwcx.: Store Word Conditional Indexed
    Stwcx_ = 147,
    /// stwux: Store Word Indexed
    Stwux = 148,
    /// stwx: Store Word Indexed
    Stwx = 149,
    /// subf: Subtract From Carrying
    Subf = 150,
    /// subfc: Subtract from Carrying
    Subfc = 151,
    /// subfe: Subtract from Extended
    Subfe = 152,
    /// subfme: Subtract from Minus One Extended
    Subfme = 153,
    /// subfze: Subtract from Zero Extended
    Subfze = 154,
    /// sync: Synchronize
    Sync = 155,
    /// tlbie: Translation Lookaside Buffer Invalidate Entry
    Tlbie = 156,
    /// tlbsync: TLB Synchronize
    Tlbsync = 157,
    /// tw: Trap Word
    Tw = 158,
    /// xor: XOR
    Xor = 159,
    /// lwz: Load Word and Zero
    Lwz = 160,
    /// lwzu: Load Word and Zero with Update
    Lwzu = 161,
    /// lbz: Load Byte and Zero
    Lbz = 162,
    /// lbzu: Load Byte and Zero with Update
    Lbzu = 163,
    /// stw: Store Word
    Stw = 164,
    /// stwu: Store Word with Update
    Stwu = 165,
    /// stb: Store Byte
    Stb = 166,
    /// stbu: Store Byte with Update
    Stbu = 167,
    /// lhz: Load Half Word and Zero
    Lhz = 168,
    /// lhzu: Load Half Word and Zero with Update
    Lhzu = 169,
    /// lha: Load Half Word Algebraic
    Lha = 170,
    /// lhau: Load Half Word Algebraic with Update
    Lhau = 171,
    /// sth: Store Half Word
    Sth = 172,
    /// sthu: Store Half Word with Update
    Sthu = 173,
    /// lmw: Load Multiple Word
    Lmw = 174,
    /// stmw: Store Multiple Word
    Stmw = 175,
    /// lfs: Load Floating-Point Single
    Lfs = 176,
    /// lfsu: Load Floating-Point Single with Update
    Lfsu = 177,
    /// lfd: Load Floating-Point Double
    Lfd = 178,
    /// lfdu: Load Floating-Point Double with Update
    Lfdu = 179,
    /// stfs: Store Floating-Point Single
    Stfs = 180,
    /// stfsu: Store Floating-Point Single with Update
    Stfsu = 181,
    /// stfd: Store Floating-Point Double
    Stfd = 182,
    /// stfdu: Store Floating-Point Double with Update
    Stfdu = 183,
    /// psq_l: Paired Single Quantized Load
    PsqL = 184,
    /// psq_lu: Paired Single Quantized Load with Update
    PsqLu = 185,
    /// fadds: Floating Add (Single-Precision)
    Fadds = 186,
    /// fdivs: Floating Divide (Single-Precision)
    Fdivs = 187,
    /// fmadds: Floating Multiply-Add (Single-Precision)
    Fmadds = 188,
    /// fmsubs: Floating Multiply-Subtract (Single-Precision)
    Fmsubs = 189,
    /// fmuls: Floating Multiply (Single-Precision)
    Fmuls = 190,
    /// fnmadds: Floating Negative Multiply-Add (Single-Precision)
    Fnmadds = 191,
    /// fnmsubs: Floating Negative Multiply-Subtract (Single-Precision)
    Fnmsubs = 192,
    /// fres: Floating Reciprocal Estimate Single
    Fres = 193,
    /// fsubs: Floating Subtract (Single-Precision)
    Fsubs = 194,
    /// psq_st: Paired Single Quantized Store
    PsqSt = 195,
    /// psq_stu: Paired Single Quantized Store with Update
    PsqStu = 196,
    /// fabs: Floating Absolute Value
    Fabs = 197,
    /// fadd: Floating Add (Double-Precision)
    Fadd = 198,
    /// fcmpo: Floating Compare Ordered
    Fcmpo = 199,
    /// fcmpu: Floating Compare Unordered
    Fcmpu = 200,
    /// fctiw: Floating Convert to Integer Word
    Fctiw = 201,
    /// fctiwz: Floating Convert to Integer Word with Round toward Zero
    Fctiwz = 202,
    /// fdiv: Floating Divide (Double-Precision)
    Fdiv = 203,
    /// fmadd: Floating Multiply-Add (Double-Precision)
    Fmadd = 204,
    /// fmr: Floating Move Register (Double-Precision)
    Fmr = 205,
    /// fmsub: Floating Multiply-Subtract (Double-Precision)
    Fmsub = 206,
    /// fmul: Floating Multiply (Double-Precision)
    Fmul = 207,
    /// fnabs: Floating Negative Absolute Value
    Fnabs = 208,
    /// fneg: Floating Negate
    Fneg = 209,
    /// fnmadd: Floating Negative Multiply-Add (Double-Precision)
    Fnmadd = 210,
    /// fnmsub: Floating Negative Multiply-Subtract (Double-Precision)
    Fnmsub = 211,
    /// frsp: Floating Round to Single
    Frsp = 212,
    /// frsqrte: Floating Reciprocal Square Root Estimate
    Frsqrte = 213,
    /// fsel: Floating Select
    Fsel = 214,
    /// fsub: Floating Subtract (Double-Precision)
    Fsub = 215,
    /// mcrfs: Move to Condition Register from FPSCR
    Mcrfs = 216,
    /// mffs: Move from FPSCR
    Mffs = 217,
    /// mtfsb0: Move to FPSCR Bit 0
    Mtfsb0 = 218,
    /// mtfsb1: Move to FPSCR Bit 1
    Mtfsb1 = 219,
    /// mtfsf: Move to FPSCR Fields
    Mtfsf = 220,
    /// mtfsfi: Move to FPSCR Field Immediate
    Mtfsfi = 221,
}
impl Opcode {
    #[inline]
    pub fn _mnemonic(self) -> &'static str {
        OPCODE_NAMES[self as usize]
    }
    #[inline]
    pub fn _detect(code: u32) -> Self {
        let entry = OPCODE_ENTRIES[(code >> 26) as usize];
        for i in entry.0..entry.1 {
            let pattern = OPCODE_PATTERNS[i as usize];
            if (code & pattern.0) == pattern.1 {
                // Safety: The enum is repr(u8) and marked non_exhaustive
                return unsafe { core::mem::transmute(i) };
            }
        }
        Self::Illegal
    }
}
impl Ins {
    /// simm: Signed Immediate
    #[inline(always)]
    pub const fn field_simm(&self) -> i16 {
        (self.code & 0xffff) as i16
    }
    /// uimm: Unsigned Immediate
    #[inline(always)]
    pub const fn field_uimm(&self) -> u16 {
        (self.code & 0xffff) as u16
    }
    /// offset: Branch Offset
    #[inline(always)]
    pub const fn field_offset(&self) -> i16 {
        (self.code & 0xffff) as i16
    }
    /// ps_offset: Paired Single Offset
    #[inline(always)]
    pub const fn field_ps_offset(&self) -> i16 {
        (((self.code & 0xfff) << 4) as i16) >> 4
    }
    /// BO: Branch Options
    #[inline(always)]
    pub const fn field_bo(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// BI: Branch Condition Register Bit
    #[inline(always)]
    pub const fn field_bi(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// BD: Branch Destination (14-bit)
    #[inline(always)]
    pub const fn field_bd(&self) -> i16 {
        (self.code & 0xfffc) as i16
    }
    /// LI: Branch Destination (24-bit)
    #[inline(always)]
    pub const fn field_li(&self) -> i32 {
        (((self.code & 0x3fffffc) << 6) as i32) >> 6
    }
    /// SH: Shift Amount
    #[inline(always)]
    pub const fn field_sh(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// MB: Mask Begin
    #[inline(always)]
    pub const fn field_mb(&self) -> u8 {
        ((self.code >> 6) & 0x1f) as u8
    }
    /// ME: Mask End
    #[inline(always)]
    pub const fn field_me(&self) -> u8 {
        ((self.code >> 1) & 0x1f) as u8
    }
    /// rS: Source Register
    #[inline(always)]
    pub const fn field_rs(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// rD: Destination Register
    #[inline(always)]
    pub const fn field_rd(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// rA: Register A
    #[inline(always)]
    pub const fn field_ra(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// rB: Register B
    #[inline(always)]
    pub const fn field_rb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// sr: Segment Register
    #[inline(always)]
    pub const fn field_sr(&self) -> u8 {
        ((self.code >> 16) & 0xf) as u8
    }
    /// spr: Special Purpose Register
    #[inline(always)]
    pub const fn field_spr(&self) -> u16 {
        let value = ((self.code >> 11) & 0x3ff) as u16;
        ((value & 0b11111_00000) >> 5) | ((value & 0b00000_11111) << 5)
    }
    /// frS: Source Floating-Point Register
    #[inline(always)]
    pub const fn field_frs(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// frD: Destination Floating-Point Register
    #[inline(always)]
    pub const fn field_frd(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// frA: Floating-Point Register A
    #[inline(always)]
    pub const fn field_fra(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// frB: Floating-Point Register B
    #[inline(always)]
    pub const fn field_frb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// frC: Floating-Point Register C
    #[inline(always)]
    pub const fn field_frc(&self) -> u8 {
        ((self.code >> 6) & 0x1f) as u8
    }
    /// crbD: Condition Register Bit Destination
    #[inline(always)]
    pub const fn field_crbd(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// crbA: Condition Register Bit A
    #[inline(always)]
    pub const fn field_crba(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// crbB: Condition Register Bit B
    #[inline(always)]
    pub const fn field_crbb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// crfD: Condition Register Field Destination
    #[inline(always)]
    pub const fn field_crfd(&self) -> u8 {
        ((self.code >> 23) & 0x7) as u8
    }
    /// crfS: Condition Register Field Source
    #[inline(always)]
    pub const fn field_crfs(&self) -> u8 {
        ((self.code >> 18) & 0x7) as u8
    }
    /// crm: Condition Register Mask
    #[inline(always)]
    pub const fn field_crm(&self) -> u8 {
        ((self.code >> 12) & 0xff) as u8
    }
    /// ps_I
    #[inline(always)]
    pub const fn field_ps_i(&self) -> u8 {
        ((self.code >> 12) & 0x7) as u8
    }
    /// ps_IX
    #[inline(always)]
    pub const fn field_ps_ix(&self) -> u8 {
        ((self.code >> 7) & 0x7) as u8
    }
    /// ps_W
    #[inline(always)]
    pub const fn field_ps_w(&self) -> u8 {
        ((self.code >> 15) & 0x1) as u8
    }
    /// ps_WX
    #[inline(always)]
    pub const fn field_ps_wx(&self) -> u8 {
        ((self.code >> 10) & 0x1) as u8
    }
    /// NB
    #[inline(always)]
    pub const fn field_nb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// tbr: Time Base
    #[inline(always)]
    pub const fn field_tbr(&self) -> u16 {
        let value = ((self.code >> 11) & 0x3ff) as u16;
        ((value & 0b11111_00000) >> 5) | ((value & 0b00000_11111) << 5)
    }
    /// mtfsf_FM: Field Mask for mtfsf
    #[inline(always)]
    pub const fn field_mtfsf_fm(&self) -> u8 {
        ((self.code >> 17) & 0xff) as u8
    }
    /// mtfsf_IMM: Immediate for mtfsfi
    #[inline(always)]
    pub const fn field_mtfsf_imm(&self) -> u8 {
        ((self.code >> 12) & 0xf) as u8
    }
    /// spr_SPRG: SPRG index for m[tf]sprg
    #[inline(always)]
    pub const fn field_spr_sprg(&self) -> u8 {
        ((self.code >> 16) & 0x3) as u8
    }
    /// spr_BAT: IBAT/DBAT index for m[tf][id]bat[ul]
    #[inline(always)]
    pub const fn field_spr_bat(&self) -> u8 {
        ((self.code >> 17) & 0x3) as u8
    }
    /// TO: Bitset for tw and twi
    #[inline(always)]
    pub const fn field_to(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// L: Bitset for cmp, cmpi, cmpl, cmpli
    #[inline(always)]
    pub const fn field_l(&self) -> u8 {
        ((self.code >> 21) & 0x1) as u8
    }
    /// OE: Field used by XO-form instructions to enable setting OV and SO in the XER.
    #[inline(always)]
    pub const fn field_oe(&self) -> bool {
        (self.code & 0x400) == 0x400
    }
    /// Rc: Record Bit
    #[inline(always)]
    pub const fn field_rc(&self) -> bool {
        (self.code & 0x1) == 0x1
    }
    /// LK: Link Bit
    #[inline(always)]
    pub const fn field_lk(&self) -> bool {
        (self.code & 0x1) == 0x1
    }
    /// AA: Absolute Address Bit
    #[inline(always)]
    pub const fn field_aa(&self) -> bool {
        (self.code & 0x2) == 0x2
    }
    /// BP: Predict branch to be taken
    #[inline(always)]
    pub const fn field_bp(&self) -> bool {
        (self.code & 0x200000) == 0x200000 && self.field_bd() >= 0x0
    }
    /// BNP: Predict branch not to be taken (fall through)
    #[inline(always)]
    pub const fn field_bnp(&self) -> bool {
        (self.code & 0x200000) == 0x200000 && self.field_bd() < 0x0
    }
    /// BP_ND: Predict branch to be taken (implicit dest for LR/CTR)
    #[inline(always)]
    pub const fn field_bp_nd(&self) -> bool {
        (self.code & 0x200000) == 0x200000
    }
}
pub type Arguments = [Argument; 5];
pub const EMPTY_ARGS: Arguments = [
    Argument::None,
    Argument::None,
    Argument::None,
    Argument::None,
    Argument::None,
];
type MnemonicFunction = fn(&mut ParsedIns, Ins);
fn basic_twi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "twi",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_to() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_twi(out: &mut ParsedIns, ins: Ins) {
    if ins.field_to() == 0x8 {
        *out = ParsedIns {
            mnemonic: "twgti",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x6 {
        *out = ParsedIns {
            mnemonic: "twllei",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x1f {
        *out = ParsedIns {
            mnemonic: "twui",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_twi(out, ins)
}
fn basic_dcbz_l(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbz_l",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_psq_lux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_lux",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_wx() as _)),
            Argument::GQR(GQR(ins.field_ps_ix() as _)),
        ],
    };
}
fn basic_psq_lx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_lx",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_wx() as _)),
            Argument::GQR(GQR(ins.field_ps_ix() as _)),
        ],
    };
}
fn basic_psq_stux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_stux",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_wx() as _)),
            Argument::GQR(GQR(ins.field_ps_ix() as _)),
        ],
    };
}
fn basic_psq_stx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_stx",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_wx() as _)),
            Argument::GQR(GQR(ins.field_ps_ix() as _)),
        ],
    };
}
fn basic_ps_abs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_abs", "ps_abs."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_add(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_add", "ps_add."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_cmpo0(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ps_cmpo0",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_cmpo1(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ps_cmpo1",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_cmpu0(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ps_cmpu0",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_cmpu1(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ps_cmpu1",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_div(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_div", "ps_div."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_madd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_madd", "ps_madd."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_ps_madds0(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_madds0", "ps_madds0."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_ps_madds1(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_madds1", "ps_madds1."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_ps_merge00(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_merge00", "ps_merge00."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_merge01(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_merge01", "ps_merge01."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_merge10(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_merge10", "ps_merge10."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_merge11(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_merge11", "ps_merge11."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_mr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_mr", "ps_mr."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_msub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_msub", "ps_msub."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_ps_mul(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_mul", "ps_mul."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_muls0(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_muls0", "ps_muls0."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_muls1(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_muls1", "ps_muls1."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_nabs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_nabs", "ps_nabs."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_neg(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_neg", "ps_neg."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_nmadd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_nmadd", "ps_nmadd."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_ps_nmsub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_nmsub", "ps_nmsub."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_ps_res(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_res", "ps_res."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_rsqrte(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_rsqrte", "ps_rsqrte."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_sel(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_sel", "ps_sel."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_ps_sub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_sub", "ps_sub."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_sum0(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_sum0", "ps_sum0."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_ps_sum1(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["ps_sum1", "ps_sum1."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_mulli(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mulli",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_subfic(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "subfic",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_cmpli(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmpli",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_l() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
        ],
    };
}
fn simplified_cmpli(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmplwi",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmplwi",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpldi",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpldi",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cmpli(out, ins)
}
fn basic_cmpi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmpi",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_l() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
        ],
    };
}
fn simplified_cmpi(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmpwi",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmpwi",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpdi",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpdi",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cmpi(out, ins)
}
fn basic_addic(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "addic",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_addic(out: &mut ParsedIns, ins: Ins) {
    if ins.field_simm() < 0x0 && ins.field_simm() != -0x8000 {
        *out = ParsedIns {
            mnemonic: "subic",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm((-ins.field_simm()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_addic(out, ins)
}
fn basic_addic_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "addic.",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_addic_(out: &mut ParsedIns, ins: Ins) {
    if ins.field_simm() < 0x0 && ins.field_simm() != -0x8000 {
        *out = ParsedIns {
            mnemonic: "subic.",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm((-ins.field_simm()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_addic_(out, ins)
}
fn basic_addi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "addi",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_addi(out: &mut ParsedIns, ins: Ins) {
    if ins.field_ra() == 0x0 {
        *out = ParsedIns {
            mnemonic: "li",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_simm() < 0x0 && ins.field_simm() != -0x8000 {
        *out = ParsedIns {
            mnemonic: "subi",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm((-ins.field_simm()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_addi(out, ins)
}
fn basic_addis(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "addis",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_addis(out: &mut ParsedIns, ins: Ins) {
    if ins.field_ra() == 0x0 {
        *out = ParsedIns {
            mnemonic: "lis",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_simm() < 0x0 && ins.field_simm() != -0x8000 {
        *out = ParsedIns {
            mnemonic: "subis",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm((-ins.field_simm()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_addis(out, ins)
}
fn basic_bc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "bc",
            "bcl",
            "bca",
            "bcla",
            "bc+",
            "bcl+",
            "bca+",
            "bcla+",
            "bc-",
            "bcl-",
            "bca-",
            "bcla-",
            "<illegal>",
            "<illegal>",
            "<illegal>",
            "<illegal>",
        ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
            | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_bo() as _)),
            Argument::CRBit(CRBit(ins.field_bi() as _)),
            Argument::BranchDest(BranchDest(ins.field_bd() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_bc(out: &mut ParsedIns, ins: Ins) {
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "blt",
                "bltl",
                "blta",
                "bltla",
                "blt+",
                "bltl+",
                "blta+",
                "bltla+",
                "blt-",
                "bltl-",
                "blta-",
                "bltla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "blt",
                "bltl",
                "blta",
                "bltla",
                "blt+",
                "bltl+",
                "blta+",
                "bltla+",
                "blt-",
                "bltl-",
                "blta-",
                "bltla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x1 {
        *out = ParsedIns {
            mnemonic: [
                "ble",
                "blel",
                "blea",
                "blela",
                "ble+",
                "blel+",
                "blea+",
                "blela+",
                "ble-",
                "blel-",
                "blea-",
                "blela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x1 {
        *out = ParsedIns {
            mnemonic: [
                "ble",
                "blel",
                "blea",
                "blela",
                "ble+",
                "blel+",
                "blea+",
                "blela+",
                "ble-",
                "blel-",
                "blea-",
                "blela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "beq",
                "beql",
                "beqa",
                "beqla",
                "beq+",
                "beql+",
                "beqa+",
                "beqla+",
                "beq-",
                "beql-",
                "beqa-",
                "beqla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "beq",
                "beql",
                "beqa",
                "beqla",
                "beq+",
                "beql+",
                "beqa+",
                "beqla+",
                "beq-",
                "beql-",
                "beqa-",
                "beqla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bge",
                "bgel",
                "bgea",
                "bgela",
                "bge+",
                "bgel+",
                "bgea+",
                "bgela+",
                "bge-",
                "bgel-",
                "bgea-",
                "bgela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bge",
                "bgel",
                "bgea",
                "bgela",
                "bge+",
                "bgel+",
                "bgea+",
                "bgela+",
                "bge-",
                "bgel-",
                "bgea-",
                "bgela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x1 {
        *out = ParsedIns {
            mnemonic: [
                "bgt",
                "bgtl",
                "bgta",
                "bgtla",
                "bgt+",
                "bgtl+",
                "bgta+",
                "bgtla+",
                "bgt-",
                "bgtl-",
                "bgta-",
                "bgtla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x1 {
        *out = ParsedIns {
            mnemonic: [
                "bgt",
                "bgtl",
                "bgta",
                "bgtla",
                "bgt+",
                "bgtl+",
                "bgta+",
                "bgtla+",
                "bgt-",
                "bgtl-",
                "bgta-",
                "bgtla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "bne",
                "bnel",
                "bnea",
                "bnela",
                "bne+",
                "bnel+",
                "bnea+",
                "bnela+",
                "bne-",
                "bnel-",
                "bnea-",
                "bnela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "bne",
                "bnel",
                "bnea",
                "bnela",
                "bne+",
                "bnel+",
                "bnea+",
                "bnela+",
                "bne-",
                "bnel-",
                "bnea-",
                "bnela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x3 {
        *out = ParsedIns {
            mnemonic: [
                "bso",
                "bsol",
                "bsoa",
                "bsola",
                "bso+",
                "bsol+",
                "bsoa+",
                "bsola+",
                "bso-",
                "bsol-",
                "bsoa-",
                "bsola-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x3 {
        *out = ParsedIns {
            mnemonic: [
                "bso",
                "bsol",
                "bsoa",
                "bsola",
                "bso+",
                "bsol+",
                "bsoa+",
                "bsola+",
                "bso-",
                "bsol-",
                "bsoa-",
                "bsola-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x3 {
        *out = ParsedIns {
            mnemonic: [
                "bns",
                "bnsl",
                "bnsa",
                "bnsla",
                "bns+",
                "bnsl+",
                "bnsa+",
                "bnsla+",
                "bns-",
                "bnsl-",
                "bnsa-",
                "bnsla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x3 {
        *out = ParsedIns {
            mnemonic: [
                "bns",
                "bnsl",
                "bnsa",
                "bnsla",
                "bns+",
                "bnsl+",
                "bnsa+",
                "bnsla+",
                "bns-",
                "bnsl-",
                "bnsa-",
                "bnsla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x10 && ins.field_bi() == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bdnz",
                "bdnzl",
                "bdnza",
                "bdnzla",
                "bdnz+",
                "bdnzl+",
                "bdnza+",
                "bdnzla+",
                "bdnz-",
                "bdnzl-",
                "bdnza-",
                "bdnzla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x8 {
        *out = ParsedIns {
            mnemonic: [
                "bdnzt",
                "bdnztl",
                "bdnzta",
                "bdnztla",
                "bdnzt+",
                "bdnztl+",
                "bdnzta+",
                "bdnztla+",
                "bdnzt-",
                "bdnztl-",
                "bdnzta-",
                "bdnztla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bdnzf",
                "bdnzfl",
                "bdnzfa",
                "bdnzfla",
                "bdnzf+",
                "bdnzfl+",
                "bdnzfa+",
                "bdnzfla+",
                "bdnzf-",
                "bdnzfl-",
                "bdnzfa-",
                "bdnzfla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x12 && ins.field_bi() == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bdz",
                "bdzl",
                "bdza",
                "bdzla",
                "bdz+",
                "bdzl+",
                "bdza+",
                "bdzla+",
                "bdz-",
                "bdzl-",
                "bdza-",
                "bdzla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xa {
        *out = ParsedIns {
            mnemonic: [
                "bdzt",
                "bdztl",
                "bdzta",
                "bdztla",
                "bdzt+",
                "bdztl+",
                "bdzta+",
                "bdztla+",
                "bdzt-",
                "bdztl-",
                "bdzta-",
                "bdztla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "bdzf",
                "bdzfl",
                "bdzfa",
                "bdzfla",
                "bdzf+",
                "bdzfl+",
                "bdzfa+",
                "bdzfla+",
                "bdzf-",
                "bdzfl-",
                "bdzfa-",
                "bdzfla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_bc(out, ins)
}
fn basic_sc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sc",
        args: EMPTY_ARGS,
    };
}
fn basic_b(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "b",
            "bl",
            "ba",
            "bla",
        ][ins.field_lk() as usize | (ins.field_aa() as usize) << 1],
        args: [
            Argument::BranchDest(BranchDest(ins.field_li() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_bcctr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "bcctr",
            "bcctrl",
            "bcctr+",
            "bcctrl+",
        ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_bo() as _)),
            Argument::CRBit(CRBit(ins.field_bi() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_bcctr(out: &mut ParsedIns, ins: Ins) {
    if ins.field_bo() == 0x14 && ins.field_bi() == 0x0 {
        *out = ParsedIns {
            mnemonic: ["bctr", "bctrl"][ins.field_lk() as usize],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bltctr",
                "bltctrl",
                "bltctr+",
                "bltctrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bltctr",
                "bltctrl",
                "bltctr+",
                "bltctrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x1 {
        *out = ParsedIns {
            mnemonic: [
                "blectr",
                "blectrl",
                "blectr+",
                "blectrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x1 {
        *out = ParsedIns {
            mnemonic: [
                "blectr",
                "blectrl",
                "blectr+",
                "blectrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "beqctr",
                "beqctrl",
                "beqctr+",
                "beqctrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "beqctr",
                "beqctrl",
                "beqctr+",
                "beqctrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bgectr",
                "bgectrl",
                "bgectr+",
                "bgectrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bgectr",
                "bgectrl",
                "bgectr+",
                "bgectrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x1 {
        *out = ParsedIns {
            mnemonic: [
                "bgtctr",
                "bgtctrl",
                "bgtctr+",
                "bgtctrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x1 {
        *out = ParsedIns {
            mnemonic: [
                "bgtctr",
                "bgtctrl",
                "bgtctr+",
                "bgtctrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "bnectr",
                "bnectrl",
                "bnectr+",
                "bnectrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "bnectr",
                "bnectrl",
                "bnectr+",
                "bnectrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x3 {
        *out = ParsedIns {
            mnemonic: [
                "bsoctr",
                "bsoctrl",
                "bsoctr+",
                "bsoctrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x3 {
        *out = ParsedIns {
            mnemonic: [
                "bsoctr",
                "bsoctrl",
                "bsoctr+",
                "bsoctrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x3 {
        *out = ParsedIns {
            mnemonic: [
                "bnsctr",
                "bnsctrl",
                "bnsctr+",
                "bnsctrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x3 {
        *out = ParsedIns {
            mnemonic: [
                "bnsctr",
                "bnsctrl",
                "bnsctr+",
                "bnsctrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_bcctr(out, ins)
}
fn basic_bclr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "bclr",
            "bclrl",
            "bclr+",
            "bclrl+",
        ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_bo() as _)),
            Argument::CRBit(CRBit(ins.field_bi() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_bclr(out: &mut ParsedIns, ins: Ins) {
    if ins.field_bo() == 0x14 && ins.field_bi() == 0x0 {
        *out = ParsedIns {
            mnemonic: ["blr", "blrl"][ins.field_lk() as usize],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bltlr",
                "bltlrl",
                "bltlr+",
                "bltlrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bltlr",
                "bltlrl",
                "bltlr+",
                "bltlrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x1 {
        *out = ParsedIns {
            mnemonic: [
                "blelr",
                "blelrl",
                "blelr+",
                "blelrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x1 {
        *out = ParsedIns {
            mnemonic: [
                "blelr",
                "blelrl",
                "blelr+",
                "blelrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "beqlr",
                "beqlrl",
                "beqlr+",
                "beqlrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "beqlr",
                "beqlrl",
                "beqlr+",
                "beqlrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bgelr",
                "bgelrl",
                "bgelr+",
                "bgelrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bgelr",
                "bgelrl",
                "bgelr+",
                "bgelrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x1 {
        *out = ParsedIns {
            mnemonic: [
                "bgtlr",
                "bgtlrl",
                "bgtlr+",
                "bgtlrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x1 {
        *out = ParsedIns {
            mnemonic: [
                "bgtlr",
                "bgtlrl",
                "bgtlr+",
                "bgtlrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "bnelr",
                "bnelrl",
                "bnelr+",
                "bnelrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x2 {
        *out = ParsedIns {
            mnemonic: [
                "bnelr",
                "bnelrl",
                "bnelr+",
                "bnelrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x3 {
        *out = ParsedIns {
            mnemonic: [
                "bsolr",
                "bsolrl",
                "bsolr+",
                "bsolrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x3 {
        *out = ParsedIns {
            mnemonic: [
                "bsolr",
                "bsolrl",
                "bsolr+",
                "bsolrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x3 {
        *out = ParsedIns {
            mnemonic: [
                "bnslr",
                "bnslrl",
                "bnslr+",
                "bnslrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x3 {
        *out = ParsedIns {
            mnemonic: [
                "bnslr",
                "bnslrl",
                "bnslr+",
                "bnslrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRField(CRField(ins.field_crfs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x10 && ins.field_bi() == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bdnzlr",
                "bdnzlrl",
                "bdnzlr+",
                "bdnzlrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x8 {
        *out = ParsedIns {
            mnemonic: [
                "bdnztlr",
                "bdnztlrl",
                "bdnztlr+",
                "bdnztlrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bdnzflr",
                "bdnzflrl",
                "bdnzflr+",
                "bdnzflrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x12 && ins.field_bi() == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bdzlr",
                "bdzlrl",
                "bdzlr+",
                "bdzlrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: EMPTY_ARGS,
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xa {
        *out = ParsedIns {
            mnemonic: [
                "bdztlr",
                "bdztlrl",
                "bdztlr+",
                "bdztlrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x0 {
        *out = ParsedIns {
            mnemonic: [
                "bdzflr",
                "bdzflrl",
                "bdzflr+",
                "bdzflrl+",
            ][ins.field_lk() as usize | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_bclr(out, ins)
}
fn basic_crand(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crand",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_crandc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crandc",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_creqv(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "creqv",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_creqv(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crba() == ins.field_crbd() && ins.field_crbb() == ins.field_crbd() {
        *out = ParsedIns {
            mnemonic: "crset",
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_creqv(out, ins)
}
fn basic_crnand(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crnand",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_crnor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crnor",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_crnor(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crbb() == ins.field_crba() {
        *out = ParsedIns {
            mnemonic: "crnot",
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::CRBit(CRBit(ins.field_crba() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_crnor(out, ins)
}
fn basic_cror(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cror",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_cror(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crbb() == ins.field_crba() {
        *out = ParsedIns {
            mnemonic: "crmove",
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::CRBit(CRBit(ins.field_crba() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cror(out, ins)
}
fn basic_crorc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crorc",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_crxor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crxor",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_crxor(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crba() == ins.field_crbd() && ins.field_crbb() == ins.field_crbd() {
        *out = ParsedIns {
            mnemonic: "crclr",
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_crxor(out, ins)
}
fn basic_isync(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "isync",
        args: EMPTY_ARGS,
    };
}
fn basic_mcrf(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mcrf",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::CRField(CRField(ins.field_crfs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_rfi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "rfi",
        args: EMPTY_ARGS,
    };
}
fn basic_rlwimi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["rlwimi", "rlwimi."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_me() as _)),
        ],
    };
}
fn basic_rlwinm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["rlwinm", "rlwinm."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_me() as _)),
        ],
    };
}
fn simplified_rlwinm(out: &mut ParsedIns, ins: Ins) {
    if ins.field_sh() == 0x0 && ins.field_mb() == 0x0 {
        *out = ParsedIns {
            mnemonic: ["clrrwi", "clrrwi."][ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU((31 - ins.field_me()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_sh() == 0x0 && ins.field_me() == 0x1f {
        *out = ParsedIns {
            mnemonic: ["clrlwi", "clrlwi."][ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_mb() == 0x0 && ins.field_me() == 0x1f && ins.field_sh() <= 0x10 {
        *out = ParsedIns {
            mnemonic: ["rotlwi", "rotlwi."][ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_mb() == 0x0 && ins.field_me() == 0x1f && ins.field_sh() > 0x10 {
        *out = ParsedIns {
            mnemonic: ["rotrwi", "rotrwi."][ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU((32 - ins.field_sh()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_mb() == 0x0 && ins.field_me() == 31 - ins.field_sh() {
        *out = ParsedIns {
            mnemonic: ["slwi", "slwi."][ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_me() == 0x1f && ins.field_sh() == 32 - ins.field_mb() {
        *out = ParsedIns {
            mnemonic: ["srwi", "srwi."][ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_sh() < 0x20 && ins.field_me() == 31 - ins.field_sh() {
        *out = ParsedIns {
            mnemonic: ["clrlslwi", "clrlslwi."][ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU((ins.field_mb() + ins.field_sh()) as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_mb() == 0x0 {
        *out = ParsedIns {
            mnemonic: ["extlwi", "extlwi."][ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU((ins.field_me() + 1) as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_me() == 0x1f && ins.field_sh() >= 32 - ins.field_mb() {
        *out = ParsedIns {
            mnemonic: ["extrwi", "extrwi."][ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU((32 - ins.field_mb()) as _)),
                Argument::OpaqueU(
                    OpaqueU((ins.field_sh() - (32 - ins.field_mb())) as _),
                ),
                Argument::None,
            ],
        };
        return;
    }
    basic_rlwinm(out, ins)
}
fn basic_rlwnm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["rlwnm", "rlwnm."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_me() as _)),
        ],
    };
}
fn simplified_rlwnm(out: &mut ParsedIns, ins: Ins) {
    if ins.field_mb() == 0x0 && ins.field_me() == 0x1f {
        *out = ParsedIns {
            mnemonic: ["rotlw", "rotlw."][ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_rlwnm(out, ins)
}
fn basic_ori(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ori",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_ori(out: &mut ParsedIns, ins: Ins) {
    if ins.field_ra() == 0x0 && ins.field_rs() == 0x0 && ins.field_uimm() == 0x0 {
        *out = ParsedIns {
            mnemonic: "nop",
            args: EMPTY_ARGS,
        };
        return;
    }
    basic_ori(out, ins)
}
fn basic_oris(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "oris",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_xori(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "xori",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_xoris(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "xoris",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_andi_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "andi.",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_andis_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "andis.",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_add(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "add",
            "addo",
            "add.",
            "addo.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_addc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "addc",
            "addco",
            "addc.",
            "addco.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_adde(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "adde",
            "addeo",
            "adde.",
            "addeo.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_addme(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "addme",
            "addmeo",
            "addme.",
            "addmeo.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_addze(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "addze",
            "addzeo",
            "addze.",
            "addzeo.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_and(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["and", "and."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_andc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["andc", "andc."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_cmp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmp",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_l() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
        ],
    };
}
fn simplified_cmp(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmpw",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmpw",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpd",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpd",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cmp(out, ins)
}
fn basic_cmpl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmpl",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_l() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
        ],
    };
}
fn simplified_cmpl(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmplw",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmplw",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpld",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpld",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cmpl(out, ins)
}
fn basic_cntlzw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["cntlzw", "cntlzw."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbf(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbf",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbi",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbst(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbst",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbt(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbt",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbtst(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbtst",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbz",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_divw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "divw",
            "divwo",
            "divw.",
            "divwo.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_divwu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "divwu",
            "divwuo",
            "divwu.",
            "divwuo.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_eciwx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "eciwx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ecowx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ecowx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_eieio(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "eieio",
        args: EMPTY_ARGS,
    };
}
fn basic_eqv(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["eqv", "eqv."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_extsb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["extsb", "extsb."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_extsh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["extsh", "extsh."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_icbi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["icbi", "icbi."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lbzux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lbzux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lbzx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lbzx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfdux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfdux",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfdx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfdx",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfsux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfsux",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfsx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfsx",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhaux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhaux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhax(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhax",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhbrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhbrx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhzux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhzux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhzx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhzx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lswi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lswi",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_nb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lswx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lswx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwarx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwarx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwbrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwbrx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwzux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwzux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwzx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwzx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mcrxr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mcrxr",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfcr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfcr",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfmsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfmsr",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfspr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfspr",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::SPR(SPR(ins.field_spr() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_mfspr(out: &mut ParsedIns, ins: Ins) {
    if ins.field_spr() == 0x1 {
        *out = ParsedIns {
            mnemonic: "mfxer",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x8 {
        *out = ParsedIns {
            mnemonic: "mflr",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x9 {
        *out = ParsedIns {
            mnemonic: "mfctr",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x12 {
        *out = ParsedIns {
            mnemonic: "mfdsisr",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x13 {
        *out = ParsedIns {
            mnemonic: "mfdar",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x16 {
        *out = ParsedIns {
            mnemonic: "mfdec",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x19 {
        *out = ParsedIns {
            mnemonic: "mfsdr1",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x1a {
        *out = ParsedIns {
            mnemonic: "mfsrr0",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x1b {
        *out = ParsedIns {
            mnemonic: "mfsrr1",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3fc) == 0x110 {
        *out = ParsedIns {
            mnemonic: "mfsprg",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_sprg() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x11a {
        *out = ParsedIns {
            mnemonic: "mfear",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x210 {
        *out = ParsedIns {
            mnemonic: "mfibatu",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x211 {
        *out = ParsedIns {
            mnemonic: "mfibatl",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x218 {
        *out = ParsedIns {
            mnemonic: "mfdbatu",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x219 {
        *out = ParsedIns {
            mnemonic: "mfdbatl",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_mfspr(out, ins)
}
fn basic_mfsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfsr",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::SR(SR(ins.field_sr() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfsrin(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfsrin",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mftb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mftb",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_tbr() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtcrf(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtcrf",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_crm() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtmsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtmsr",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtspr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtspr",
        args: [
            Argument::SPR(SPR(ins.field_spr() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_mtspr(out: &mut ParsedIns, ins: Ins) {
    if ins.field_spr() == 0x1 {
        *out = ParsedIns {
            mnemonic: "mtxer",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x8 {
        *out = ParsedIns {
            mnemonic: "mtlr",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x9 {
        *out = ParsedIns {
            mnemonic: "mtctr",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x12 {
        *out = ParsedIns {
            mnemonic: "mtdsisr",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x13 {
        *out = ParsedIns {
            mnemonic: "mtdar",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x16 {
        *out = ParsedIns {
            mnemonic: "mtdec",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x19 {
        *out = ParsedIns {
            mnemonic: "mtsdr1",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x1a {
        *out = ParsedIns {
            mnemonic: "mtsrr0",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x1b {
        *out = ParsedIns {
            mnemonic: "mtsrr1",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3fc) == 0x110 {
        *out = ParsedIns {
            mnemonic: "mtsprg",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_sprg() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x11a {
        *out = ParsedIns {
            mnemonic: "mtear",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x11c {
        *out = ParsedIns {
            mnemonic: "mttbl",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x11d {
        *out = ParsedIns {
            mnemonic: "mttbu",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x210 {
        *out = ParsedIns {
            mnemonic: "mtibatu",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x211 {
        *out = ParsedIns {
            mnemonic: "mtibatl",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x218 {
        *out = ParsedIns {
            mnemonic: "mtdbatu",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x219 {
        *out = ParsedIns {
            mnemonic: "mtdbatl",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_mtspr(out, ins)
}
fn basic_mtsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtsr",
        args: [
            Argument::SR(SR(ins.field_sr() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtsrin(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtsrin",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mulhw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["mulhw", "mulhw."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mulhwu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["mulhwu", "mulhwu."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mullw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "mullw",
            "mullwo",
            "mullw.",
            "mullwo.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_nand(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["nand", "nand."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_neg(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "neg",
            "nego",
            "neg.",
            "nego.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_nor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["nor", "nor."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_or(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["or", "or."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_or(out: &mut ParsedIns, ins: Ins) {
    if ins.field_rb() == ins.field_rs() {
        *out = ParsedIns {
            mnemonic: ["mr", "mr."][ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_or(out, ins)
}
fn basic_orc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["orc", "orc."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_slw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["slw", "slw."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sraw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["sraw", "sraw."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_srawi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["srawi", "srawi."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_srw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["srw", "srw."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stbux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stbux",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stbx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stbx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfdux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfdux",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfdx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfdx",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfiwx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfiwx",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfsux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfsux",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfsx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfsx",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sthbrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sthbrx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sthux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sthux",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sthx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sthx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stswi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stswi",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_nb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stswx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stswx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwbrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwbrx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwcx_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwcx.",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwux",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_subf(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "subf",
            "subfo",
            "subf.",
            "subfo.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_subfc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "subfc",
            "subfco",
            "subfc.",
            "subfco.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_subfe(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "subfe",
            "subfeo",
            "subfe.",
            "subfeo.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_subfme(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "subfme",
            "subfmeo",
            "subfme.",
            "subfmeo.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_subfze(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: [
            "subfze",
            "subfzeo",
            "subfze.",
            "subfzeo.",
        ][ins.field_oe() as usize | (ins.field_rc() as usize) << 1],
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sync(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sync",
        args: EMPTY_ARGS,
    };
}
fn basic_tlbie(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "tlbie",
        args: [
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_tlbsync(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "tlbsync",
        args: EMPTY_ARGS,
    };
}
fn basic_tw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "tw",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_to() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_tw(out: &mut ParsedIns, ins: Ins) {
    if ins.field_to() == 0x4 {
        *out = ParsedIns {
            mnemonic: "tweq",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x5 {
        *out = ParsedIns {
            mnemonic: "twlge",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x1f && ins.field_ra() == 0x0 && ins.field_rb() == 0x0 {
        *out = ParsedIns {
            mnemonic: "trap",
            args: EMPTY_ARGS,
        };
        return;
    }
    basic_tw(out, ins)
}
fn basic_xor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["xor", "xor."][ins.field_rc() as usize],
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwz",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwzu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwzu",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lbz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lbz",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lbzu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lbzu",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stw",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwu",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stb",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stbu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stbu",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhz",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhzu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhzu",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lha(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lha",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhau(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhau",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sth(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sth",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sthu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sthu",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lmw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lmw",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stmw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stmw",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfs",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfsu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfsu",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfd",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfdu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfdu",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfs",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfsu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfsu",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfd",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfdu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfdu",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_psq_l(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_l",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_ps_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_w() as _)),
            Argument::GQR(GQR(ins.field_ps_i() as _)),
        ],
    };
}
fn basic_psq_lu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_lu",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_ps_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_w() as _)),
            Argument::GQR(GQR(ins.field_ps_i() as _)),
        ],
    };
}
fn basic_fadds(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fadds", "fadds."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fdivs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fdivs", "fdivs."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fmadds(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fmadds", "fmadds."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_fmsubs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fmsubs", "fmsubs."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_fmuls(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fmuls", "fmuls."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fnmadds(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fnmadds", "fnmadds."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_fnmsubs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fnmsubs", "fnmsubs."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_fres(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fres", "fres."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fsubs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fsubs", "fsubs."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_psq_st(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_st",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_ps_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_w() as _)),
            Argument::GQR(GQR(ins.field_ps_i() as _)),
        ],
    };
}
fn basic_psq_stu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_stu",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_ps_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_w() as _)),
            Argument::GQR(GQR(ins.field_ps_i() as _)),
        ],
    };
}
fn basic_fabs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fabs", "fabs."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fadd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fadd", "fadd."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fcmpo(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "fcmpo",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fcmpu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "fcmpu",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fctiw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fctiw", "fctiw."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fctiwz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fctiwz", "fctiwz."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fdiv(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fdiv", "fdiv."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fmadd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fmadd", "fmadd."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_fmr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fmr", "fmr."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fmsub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fmsub", "fmsub."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_fmul(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fmul", "fmul."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fnabs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fnabs", "fnabs."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fneg(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fneg", "fneg."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fnmadd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fnmadd", "fnmadd."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_fnmsub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fnmsub", "fnmsub."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_frsp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["frsp", "frsp."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_frsqrte(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["frsqrte", "frsqrte."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fsel(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fsel", "fsel."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frc() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
        ],
    };
}
fn basic_fsub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["fsub", "fsub."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mcrfs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mcrfs",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::CRField(CRField(ins.field_crfs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mffs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["mffs", "mffs."][ins.field_rc() as usize],
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtfsb0(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["mtfsb0", "mtfsb0."][ins.field_rc() as usize],
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtfsb1(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["mtfsb1", "mtfsb1."][ins.field_rc() as usize],
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtfsf(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["mtfsf", "mtfsf."][ins.field_rc() as usize],
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_mtfsf_fm() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtfsfi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: ["mtfsfi", "mtfsfi."][ins.field_rc() as usize],
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_mtfsf_imm() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn mnemonic_illegal(out: &mut ParsedIns, _ins: Ins) {
    *out = ParsedIns::new();
}
static BASIC_MNEMONICS: [MnemonicFunction; 256] = [
    basic_twi,
    basic_dcbz_l,
    basic_psq_lux,
    basic_psq_lx,
    basic_psq_stux,
    basic_psq_stx,
    basic_ps_abs,
    basic_ps_add,
    basic_ps_cmpo0,
    basic_ps_cmpo1,
    basic_ps_cmpu0,
    basic_ps_cmpu1,
    basic_ps_div,
    basic_ps_madd,
    basic_ps_madds0,
    basic_ps_madds1,
    basic_ps_merge00,
    basic_ps_merge01,
    basic_ps_merge10,
    basic_ps_merge11,
    basic_ps_mr,
    basic_ps_msub,
    basic_ps_mul,
    basic_ps_muls0,
    basic_ps_muls1,
    basic_ps_nabs,
    basic_ps_neg,
    basic_ps_nmadd,
    basic_ps_nmsub,
    basic_ps_res,
    basic_ps_rsqrte,
    basic_ps_sel,
    basic_ps_sub,
    basic_ps_sum0,
    basic_ps_sum1,
    basic_mulli,
    basic_subfic,
    basic_cmpli,
    basic_cmpi,
    basic_addic,
    basic_addic_,
    basic_addi,
    basic_addis,
    basic_bc,
    basic_sc,
    basic_b,
    basic_bcctr,
    basic_bclr,
    basic_crand,
    basic_crandc,
    basic_creqv,
    basic_crnand,
    basic_crnor,
    basic_cror,
    basic_crorc,
    basic_crxor,
    basic_isync,
    basic_mcrf,
    basic_rfi,
    basic_rlwimi,
    basic_rlwinm,
    basic_rlwnm,
    basic_ori,
    basic_oris,
    basic_xori,
    basic_xoris,
    basic_andi_,
    basic_andis_,
    basic_add,
    basic_addc,
    basic_adde,
    basic_addme,
    basic_addze,
    basic_and,
    basic_andc,
    basic_cmp,
    basic_cmpl,
    basic_cntlzw,
    basic_dcbf,
    basic_dcbi,
    basic_dcbst,
    basic_dcbt,
    basic_dcbtst,
    basic_dcbz,
    basic_divw,
    basic_divwu,
    basic_eciwx,
    basic_ecowx,
    basic_eieio,
    basic_eqv,
    basic_extsb,
    basic_extsh,
    basic_icbi,
    basic_lbzux,
    basic_lbzx,
    basic_lfdux,
    basic_lfdx,
    basic_lfsux,
    basic_lfsx,
    basic_lhaux,
    basic_lhax,
    basic_lhbrx,
    basic_lhzux,
    basic_lhzx,
    basic_lswi,
    basic_lswx,
    basic_lwarx,
    basic_lwbrx,
    basic_lwzux,
    basic_lwzx,
    basic_mcrxr,
    basic_mfcr,
    basic_mfmsr,
    basic_mfspr,
    basic_mfsr,
    basic_mfsrin,
    basic_mftb,
    basic_mtcrf,
    basic_mtmsr,
    basic_mtspr,
    basic_mtsr,
    basic_mtsrin,
    basic_mulhw,
    basic_mulhwu,
    basic_mullw,
    basic_nand,
    basic_neg,
    basic_nor,
    basic_or,
    basic_orc,
    basic_slw,
    basic_sraw,
    basic_srawi,
    basic_srw,
    basic_stbux,
    basic_stbx,
    basic_stfdux,
    basic_stfdx,
    basic_stfiwx,
    basic_stfsux,
    basic_stfsx,
    basic_sthbrx,
    basic_sthux,
    basic_sthx,
    basic_stswi,
    basic_stswx,
    basic_stwbrx,
    basic_stwcx_,
    basic_stwux,
    basic_stwx,
    basic_subf,
    basic_subfc,
    basic_subfe,
    basic_subfme,
    basic_subfze,
    basic_sync,
    basic_tlbie,
    basic_tlbsync,
    basic_tw,
    basic_xor,
    basic_lwz,
    basic_lwzu,
    basic_lbz,
    basic_lbzu,
    basic_stw,
    basic_stwu,
    basic_stb,
    basic_stbu,
    basic_lhz,
    basic_lhzu,
    basic_lha,
    basic_lhau,
    basic_sth,
    basic_sthu,
    basic_lmw,
    basic_stmw,
    basic_lfs,
    basic_lfsu,
    basic_lfd,
    basic_lfdu,
    basic_stfs,
    basic_stfsu,
    basic_stfd,
    basic_stfdu,
    basic_psq_l,
    basic_psq_lu,
    basic_fadds,
    basic_fdivs,
    basic_fmadds,
    basic_fmsubs,
    basic_fmuls,
    basic_fnmadds,
    basic_fnmsubs,
    basic_fres,
    basic_fsubs,
    basic_psq_st,
    basic_psq_stu,
    basic_fabs,
    basic_fadd,
    basic_fcmpo,
    basic_fcmpu,
    basic_fctiw,
    basic_fctiwz,
    basic_fdiv,
    basic_fmadd,
    basic_fmr,
    basic_fmsub,
    basic_fmul,
    basic_fnabs,
    basic_fneg,
    basic_fnmadd,
    basic_fnmsub,
    basic_frsp,
    basic_frsqrte,
    basic_fsel,
    basic_fsub,
    basic_mcrfs,
    basic_mffs,
    basic_mtfsb0,
    basic_mtfsb1,
    basic_mtfsf,
    basic_mtfsfi,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
];
#[inline]
pub fn parse_basic(out: &mut ParsedIns, ins: Ins) {
    BASIC_MNEMONICS[ins.op as usize](out, ins)
}
static SIMPLIFIED_MNEMONICS: [MnemonicFunction; 256] = [
    simplified_twi,
    basic_dcbz_l,
    basic_psq_lux,
    basic_psq_lx,
    basic_psq_stux,
    basic_psq_stx,
    basic_ps_abs,
    basic_ps_add,
    basic_ps_cmpo0,
    basic_ps_cmpo1,
    basic_ps_cmpu0,
    basic_ps_cmpu1,
    basic_ps_div,
    basic_ps_madd,
    basic_ps_madds0,
    basic_ps_madds1,
    basic_ps_merge00,
    basic_ps_merge01,
    basic_ps_merge10,
    basic_ps_merge11,
    basic_ps_mr,
    basic_ps_msub,
    basic_ps_mul,
    basic_ps_muls0,
    basic_ps_muls1,
    basic_ps_nabs,
    basic_ps_neg,
    basic_ps_nmadd,
    basic_ps_nmsub,
    basic_ps_res,
    basic_ps_rsqrte,
    basic_ps_sel,
    basic_ps_sub,
    basic_ps_sum0,
    basic_ps_sum1,
    basic_mulli,
    basic_subfic,
    simplified_cmpli,
    simplified_cmpi,
    simplified_addic,
    simplified_addic_,
    simplified_addi,
    simplified_addis,
    simplified_bc,
    basic_sc,
    basic_b,
    simplified_bcctr,
    simplified_bclr,
    basic_crand,
    basic_crandc,
    simplified_creqv,
    basic_crnand,
    simplified_crnor,
    simplified_cror,
    basic_crorc,
    simplified_crxor,
    basic_isync,
    basic_mcrf,
    basic_rfi,
    basic_rlwimi,
    simplified_rlwinm,
    simplified_rlwnm,
    simplified_ori,
    basic_oris,
    basic_xori,
    basic_xoris,
    basic_andi_,
    basic_andis_,
    basic_add,
    basic_addc,
    basic_adde,
    basic_addme,
    basic_addze,
    basic_and,
    basic_andc,
    simplified_cmp,
    simplified_cmpl,
    basic_cntlzw,
    basic_dcbf,
    basic_dcbi,
    basic_dcbst,
    basic_dcbt,
    basic_dcbtst,
    basic_dcbz,
    basic_divw,
    basic_divwu,
    basic_eciwx,
    basic_ecowx,
    basic_eieio,
    basic_eqv,
    basic_extsb,
    basic_extsh,
    basic_icbi,
    basic_lbzux,
    basic_lbzx,
    basic_lfdux,
    basic_lfdx,
    basic_lfsux,
    basic_lfsx,
    basic_lhaux,
    basic_lhax,
    basic_lhbrx,
    basic_lhzux,
    basic_lhzx,
    basic_lswi,
    basic_lswx,
    basic_lwarx,
    basic_lwbrx,
    basic_lwzux,
    basic_lwzx,
    basic_mcrxr,
    basic_mfcr,
    basic_mfmsr,
    simplified_mfspr,
    basic_mfsr,
    basic_mfsrin,
    basic_mftb,
    basic_mtcrf,
    basic_mtmsr,
    simplified_mtspr,
    basic_mtsr,
    basic_mtsrin,
    basic_mulhw,
    basic_mulhwu,
    basic_mullw,
    basic_nand,
    basic_neg,
    basic_nor,
    simplified_or,
    basic_orc,
    basic_slw,
    basic_sraw,
    basic_srawi,
    basic_srw,
    basic_stbux,
    basic_stbx,
    basic_stfdux,
    basic_stfdx,
    basic_stfiwx,
    basic_stfsux,
    basic_stfsx,
    basic_sthbrx,
    basic_sthux,
    basic_sthx,
    basic_stswi,
    basic_stswx,
    basic_stwbrx,
    basic_stwcx_,
    basic_stwux,
    basic_stwx,
    basic_subf,
    basic_subfc,
    basic_subfe,
    basic_subfme,
    basic_subfze,
    basic_sync,
    basic_tlbie,
    basic_tlbsync,
    simplified_tw,
    basic_xor,
    basic_lwz,
    basic_lwzu,
    basic_lbz,
    basic_lbzu,
    basic_stw,
    basic_stwu,
    basic_stb,
    basic_stbu,
    basic_lhz,
    basic_lhzu,
    basic_lha,
    basic_lhau,
    basic_sth,
    basic_sthu,
    basic_lmw,
    basic_stmw,
    basic_lfs,
    basic_lfsu,
    basic_lfd,
    basic_lfdu,
    basic_stfs,
    basic_stfsu,
    basic_stfd,
    basic_stfdu,
    basic_psq_l,
    basic_psq_lu,
    basic_fadds,
    basic_fdivs,
    basic_fmadds,
    basic_fmsubs,
    basic_fmuls,
    basic_fnmadds,
    basic_fnmsubs,
    basic_fres,
    basic_fsubs,
    basic_psq_st,
    basic_psq_stu,
    basic_fabs,
    basic_fadd,
    basic_fcmpo,
    basic_fcmpu,
    basic_fctiw,
    basic_fctiwz,
    basic_fdiv,
    basic_fmadd,
    basic_fmr,
    basic_fmsub,
    basic_fmul,
    basic_fnabs,
    basic_fneg,
    basic_fnmadd,
    basic_fnmsub,
    basic_frsp,
    basic_frsqrte,
    basic_fsel,
    basic_fsub,
    basic_mcrfs,
    basic_mffs,
    basic_mtfsb0,
    basic_mtfsb1,
    basic_mtfsf,
    basic_mtfsfi,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
    mnemonic_illegal,
];
#[inline]
pub fn parse_simplified(out: &mut ParsedIns, ins: Ins) {
    SIMPLIFIED_MNEMONICS[ins.op as usize](out, ins)
}
type DefsUsesFunction = fn(&mut Arguments, Ins);
fn uses_twi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbz_l(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_psq_lux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_psq_lux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_psq_lx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_psq_lx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_psq_stux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_psq_stux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_psq_stx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_abs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_abs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_add(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_add(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_cmpo0(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_cmpo0(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_fra() != 0 {
            Argument::FPR(FPR(ins.field_fra() as _))
        } else {
            Argument::None
        },
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_cmpo1(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_cmpo1(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_fra() != 0 {
            Argument::FPR(FPR(ins.field_fra() as _))
        } else {
            Argument::None
        },
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_cmpu0(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_cmpu0(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_fra() != 0 {
            Argument::FPR(FPR(ins.field_fra() as _))
        } else {
            Argument::None
        },
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_cmpu1(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_cmpu1(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_fra() != 0 {
            Argument::FPR(FPR(ins.field_fra() as _))
        } else {
            Argument::None
        },
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_div(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_div(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_madd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_madd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_madds0(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_madds0(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_madds1(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_madds1(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_merge00(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_merge00(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_merge01(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_merge01(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_merge10(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_merge10(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_merge11(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_merge11(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_mr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_mr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_msub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_msub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_mul(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_mul(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_muls0(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_muls0(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_muls1(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_muls1(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_nabs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_nabs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_neg(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_neg(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_nmadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_nmadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_nmsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_nmsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_res(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_res(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_rsqrte(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_rsqrte(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_sel(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_sel(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_sub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_sub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_sum0(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_sum0(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_sum1(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_sum1(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_mulli(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mulli(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_subfic(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_subfic(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cmpli(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cmpli(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cmpi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cmpi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addic(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addic(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addic_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addic_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addi(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addis(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addis(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crandc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crandc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_creqv(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_creqv(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crnand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crnand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crnor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crnor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cror(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cror(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crorc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crorc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crxor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crxor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mcrf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mcrf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_rlwimi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rlwimi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_rlwinm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rlwinm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_rlwnm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rlwnm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ori(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ori(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_oris(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_oris(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_xori(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_xori(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_xoris(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_xoris(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_andi_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_andi_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_andis_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_andis_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_add(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_add(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_adde(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_adde(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addme(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addme(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_addze(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addze(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_and(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_and(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_andc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_andc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cmp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cmp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cmpl(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cmpl(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_cntlzw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_cntlzw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbf(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbi(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbst(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbt(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbtst(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbz(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_divw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_divw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_divwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_divwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_eciwx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_eciwx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ecowx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_eqv(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_eqv(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_extsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_extsb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_extsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_extsh(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_icbi(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lbzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lbzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lbzx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lbzx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfdux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfdux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfdx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfdx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfsux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfsux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfsx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfsx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhaux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhaux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhax(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhax(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhbrx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhbrx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhzx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhzx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lswi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lswi(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lswx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lswx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwarx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwarx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwbrx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwbrx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwzx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwzx(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mcrxr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mfcr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mfmsr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mfspr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mfsr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mfsrin(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mfsrin(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mftb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtcrf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtmsr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtspr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtsr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtsrin(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mulhw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mulhw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mulhwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mulhwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mullw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mullw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_nand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_nand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_neg(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_neg(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_nor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_nor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_or(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_or(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_orc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_orc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_slw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_slw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_sraw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_sraw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_srawi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_srawi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_srw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_srw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_stbux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stbux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stbx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_stfdux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfdux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfdx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfiwx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_stfsux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfsux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfsx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_sthbrx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_sthux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_sthux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_sthx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stswi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stswx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stwbrx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stwcx_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_stwux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stwux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stwx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_subf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_subf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_subfc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_subfc(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_subfe(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_subfe(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_subfme(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_subfme(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_subfze(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_subfze(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_tlbie(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_tw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_xor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_xor(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lwzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lbz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lbz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lbzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lbzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_stwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_stbu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stbu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lha(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lha(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lhau(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lhau(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_sth(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_sthu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_sthu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lmw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lmw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stmw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfsu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfsu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lfdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lfdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_stfsu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfsu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_stfdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfdu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_psq_l(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_psq_l(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_psq_lu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_psq_lu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fadds(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fadds(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fdivs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fdivs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmadds(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmadds(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmsubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmsubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmuls(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmuls(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fnmadds(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fnmadds(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fnmsubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fnmsubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fres(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fres(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fsubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fsubs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_psq_st(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_psq_stu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_psq_stu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fabs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fabs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fcmpo(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fcmpo(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fcmpu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fcmpu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fctiw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fctiw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fctiwz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fctiwz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fdiv(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fdiv(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fmul(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fmul(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fnabs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fnabs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fneg(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fneg(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fnmadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fnmadd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fnmsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fnmsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_frsp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_frsp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_frsqrte(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_frsqrte(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_fsel(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fsel(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_fsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_fsub(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mcrfs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mcrfs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mffs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mtfsb0(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mtfsb1(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtfsf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mtfsfi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_uses_empty(out: &mut Arguments, _ins: Ins) {
    *out = EMPTY_ARGS;
}
static DEFS_FUNCTIONS: [DefsUsesFunction; 256] = [
    defs_uses_empty,
    defs_uses_empty,
    defs_psq_lux,
    defs_psq_lx,
    defs_psq_stux,
    defs_uses_empty,
    defs_ps_abs,
    defs_ps_add,
    defs_ps_cmpo0,
    defs_ps_cmpo1,
    defs_ps_cmpu0,
    defs_ps_cmpu1,
    defs_ps_div,
    defs_ps_madd,
    defs_ps_madds0,
    defs_ps_madds1,
    defs_ps_merge00,
    defs_ps_merge01,
    defs_ps_merge10,
    defs_ps_merge11,
    defs_ps_mr,
    defs_ps_msub,
    defs_ps_mul,
    defs_ps_muls0,
    defs_ps_muls1,
    defs_ps_nabs,
    defs_ps_neg,
    defs_ps_nmadd,
    defs_ps_nmsub,
    defs_ps_res,
    defs_ps_rsqrte,
    defs_ps_sel,
    defs_ps_sub,
    defs_ps_sum0,
    defs_ps_sum1,
    defs_mulli,
    defs_subfic,
    defs_cmpli,
    defs_cmpi,
    defs_addic,
    defs_addic_,
    defs_addi,
    defs_addis,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_crand,
    defs_crandc,
    defs_creqv,
    defs_crnand,
    defs_crnor,
    defs_cror,
    defs_crorc,
    defs_crxor,
    defs_uses_empty,
    defs_mcrf,
    defs_uses_empty,
    defs_rlwimi,
    defs_rlwinm,
    defs_rlwnm,
    defs_ori,
    defs_oris,
    defs_xori,
    defs_xoris,
    defs_andi_,
    defs_andis_,
    defs_add,
    defs_addc,
    defs_adde,
    defs_addme,
    defs_addze,
    defs_and,
    defs_andc,
    defs_cmp,
    defs_cmpl,
    defs_cntlzw,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_divw,
    defs_divwu,
    defs_eciwx,
    defs_uses_empty,
    defs_uses_empty,
    defs_eqv,
    defs_extsb,
    defs_extsh,
    defs_uses_empty,
    defs_lbzux,
    defs_lbzx,
    defs_lfdux,
    defs_lfdx,
    defs_lfsux,
    defs_lfsx,
    defs_lhaux,
    defs_lhax,
    defs_lhbrx,
    defs_lhzux,
    defs_lhzx,
    defs_lswi,
    defs_lswx,
    defs_lwarx,
    defs_lwbrx,
    defs_lwzux,
    defs_lwzx,
    defs_mcrxr,
    defs_mfcr,
    defs_mfmsr,
    defs_mfspr,
    defs_mfsr,
    defs_mfsrin,
    defs_mftb,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_mulhw,
    defs_mulhwu,
    defs_mullw,
    defs_nand,
    defs_neg,
    defs_nor,
    defs_or,
    defs_orc,
    defs_slw,
    defs_sraw,
    defs_srawi,
    defs_srw,
    defs_stbux,
    defs_uses_empty,
    defs_stfdux,
    defs_uses_empty,
    defs_uses_empty,
    defs_stfsux,
    defs_uses_empty,
    defs_uses_empty,
    defs_sthux,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_stwux,
    defs_uses_empty,
    defs_subf,
    defs_subfc,
    defs_subfe,
    defs_subfme,
    defs_subfze,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_xor,
    defs_lwz,
    defs_lwzu,
    defs_lbz,
    defs_lbzu,
    defs_uses_empty,
    defs_stwu,
    defs_uses_empty,
    defs_stbu,
    defs_lhz,
    defs_lhzu,
    defs_lha,
    defs_lhau,
    defs_uses_empty,
    defs_sthu,
    defs_lmw,
    defs_uses_empty,
    defs_lfs,
    defs_lfsu,
    defs_lfd,
    defs_lfdu,
    defs_uses_empty,
    defs_stfsu,
    defs_uses_empty,
    defs_stfdu,
    defs_psq_l,
    defs_psq_lu,
    defs_fadds,
    defs_fdivs,
    defs_fmadds,
    defs_fmsubs,
    defs_fmuls,
    defs_fnmadds,
    defs_fnmsubs,
    defs_fres,
    defs_fsubs,
    defs_uses_empty,
    defs_psq_stu,
    defs_fabs,
    defs_fadd,
    defs_fcmpo,
    defs_fcmpu,
    defs_fctiw,
    defs_fctiwz,
    defs_fdiv,
    defs_fmadd,
    defs_fmr,
    defs_fmsub,
    defs_fmul,
    defs_fnabs,
    defs_fneg,
    defs_fnmadd,
    defs_fnmsub,
    defs_frsp,
    defs_frsqrte,
    defs_fsel,
    defs_fsub,
    defs_mcrfs,
    defs_mffs,
    defs_mtfsb0,
    defs_mtfsb1,
    defs_uses_empty,
    defs_mtfsfi,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
];
#[inline]
pub fn parse_defs(out: &mut Arguments, ins: Ins) {
    DEFS_FUNCTIONS[ins.op as usize](out, ins)
}
static USES_FUNCTIONS: [DefsUsesFunction; 256] = [
    uses_twi,
    uses_dcbz_l,
    uses_psq_lux,
    uses_psq_lx,
    uses_psq_stux,
    uses_psq_stx,
    uses_ps_abs,
    uses_ps_add,
    uses_ps_cmpo0,
    uses_ps_cmpo1,
    uses_ps_cmpu0,
    uses_ps_cmpu1,
    uses_ps_div,
    uses_ps_madd,
    uses_ps_madds0,
    uses_ps_madds1,
    uses_ps_merge00,
    uses_ps_merge01,
    uses_ps_merge10,
    uses_ps_merge11,
    uses_ps_mr,
    uses_ps_msub,
    uses_ps_mul,
    uses_ps_muls0,
    uses_ps_muls1,
    uses_ps_nabs,
    uses_ps_neg,
    uses_ps_nmadd,
    uses_ps_nmsub,
    uses_ps_res,
    uses_ps_rsqrte,
    uses_ps_sel,
    uses_ps_sub,
    uses_ps_sum0,
    uses_ps_sum1,
    uses_mulli,
    uses_subfic,
    uses_cmpli,
    uses_cmpi,
    uses_addic,
    uses_addic_,
    uses_addi,
    uses_addis,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    uses_crand,
    uses_crandc,
    uses_creqv,
    uses_crnand,
    uses_crnor,
    uses_cror,
    uses_crorc,
    uses_crxor,
    defs_uses_empty,
    uses_mcrf,
    defs_uses_empty,
    uses_rlwimi,
    uses_rlwinm,
    uses_rlwnm,
    uses_ori,
    uses_oris,
    uses_xori,
    uses_xoris,
    uses_andi_,
    uses_andis_,
    uses_add,
    uses_addc,
    uses_adde,
    uses_addme,
    uses_addze,
    uses_and,
    uses_andc,
    uses_cmp,
    uses_cmpl,
    uses_cntlzw,
    uses_dcbf,
    uses_dcbi,
    uses_dcbst,
    uses_dcbt,
    uses_dcbtst,
    uses_dcbz,
    uses_divw,
    uses_divwu,
    uses_eciwx,
    uses_ecowx,
    defs_uses_empty,
    uses_eqv,
    uses_extsb,
    uses_extsh,
    uses_icbi,
    uses_lbzux,
    uses_lbzx,
    uses_lfdux,
    uses_lfdx,
    uses_lfsux,
    uses_lfsx,
    uses_lhaux,
    uses_lhax,
    uses_lhbrx,
    uses_lhzux,
    uses_lhzx,
    uses_lswi,
    uses_lswx,
    uses_lwarx,
    uses_lwbrx,
    uses_lwzux,
    uses_lwzx,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    uses_mfsrin,
    defs_uses_empty,
    uses_mtcrf,
    uses_mtmsr,
    uses_mtspr,
    uses_mtsr,
    uses_mtsrin,
    uses_mulhw,
    uses_mulhwu,
    uses_mullw,
    uses_nand,
    uses_neg,
    uses_nor,
    uses_or,
    uses_orc,
    uses_slw,
    uses_sraw,
    uses_srawi,
    uses_srw,
    uses_stbux,
    uses_stbx,
    uses_stfdux,
    uses_stfdx,
    uses_stfiwx,
    uses_stfsux,
    uses_stfsx,
    uses_sthbrx,
    uses_sthux,
    uses_sthx,
    uses_stswi,
    uses_stswx,
    uses_stwbrx,
    uses_stwcx_,
    uses_stwux,
    uses_stwx,
    uses_subf,
    uses_subfc,
    uses_subfe,
    uses_subfme,
    uses_subfze,
    defs_uses_empty,
    uses_tlbie,
    defs_uses_empty,
    uses_tw,
    uses_xor,
    uses_lwz,
    uses_lwzu,
    uses_lbz,
    uses_lbzu,
    uses_stw,
    uses_stwu,
    uses_stb,
    uses_stbu,
    uses_lhz,
    uses_lhzu,
    uses_lha,
    uses_lhau,
    uses_sth,
    uses_sthu,
    uses_lmw,
    uses_stmw,
    uses_lfs,
    uses_lfsu,
    uses_lfd,
    uses_lfdu,
    uses_stfs,
    uses_stfsu,
    uses_stfd,
    uses_stfdu,
    uses_psq_l,
    uses_psq_lu,
    uses_fadds,
    uses_fdivs,
    uses_fmadds,
    uses_fmsubs,
    uses_fmuls,
    uses_fnmadds,
    uses_fnmsubs,
    uses_fres,
    uses_fsubs,
    uses_psq_st,
    uses_psq_stu,
    uses_fabs,
    uses_fadd,
    uses_fcmpo,
    uses_fcmpu,
    uses_fctiw,
    uses_fctiwz,
    uses_fdiv,
    uses_fmadd,
    uses_fmr,
    uses_fmsub,
    uses_fmul,
    uses_fnabs,
    uses_fneg,
    uses_fnmadd,
    uses_fnmsub,
    uses_frsp,
    uses_frsqrte,
    uses_fsel,
    uses_fsub,
    uses_mcrfs,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    uses_mtfsf,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
];
#[inline]
pub fn parse_uses(out: &mut Arguments, ins: Ins) {
    USES_FUNCTIONS[ins.op as usize](out, ins)
}
