#![allow(unused)]
#![cfg_attr(rustfmt, rustfmt_skip)]
// Code generated by powerpc-genisa. DO NOT EDIT.
use crate::disasm::*;
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum Extension {
    /// PowerPC 64-bit
    Ppc64,
    /// Paired Singles
    PairedSingles,
    /// AltiVec
    AltiVec,
    /// VMX128
    Vmx128,
}
impl Extension {
    #[inline]
    pub const fn bitmask(self) -> u32 {
        (1 << (self as u32))
            | match self {
                Extension::Vmx128 => Extension::AltiVec.bitmask(),
                _ => 0,
            }
    }
    pub const fn name(self) -> &'static str {
        match self {
            Extension::Ppc64 => "PowerPC 64-bit",
            Extension::PairedSingles => "Paired Singles",
            Extension::AltiVec => "AltiVec",
            Extension::Vmx128 => "VMX128",
        }
    }
}
/// The entry table allows us to quickly find the range of possible opcodes for a
/// given 6-bit prefix. 2*64 bytes should fit in a cache line (or two).
static OPCODE_ENTRIES: [(u16, u16); 64] = [
    (0, 0),
    (0, 0),
    (0, 1),
    (1, 2),
    (2, 197),
    (197, 222),
    (222, 257),
    (257, 258),
    (258, 259),
    (0, 0),
    (259, 260),
    (260, 261),
    (261, 262),
    (262, 263),
    (263, 264),
    (264, 265),
    (265, 266),
    (266, 267),
    (267, 268),
    (268, 282),
    (282, 283),
    (283, 284),
    (0, 0),
    (284, 285),
    (285, 286),
    (286, 287),
    (287, 288),
    (288, 289),
    (289, 290),
    (290, 291),
    (291, 297),
    (297, 439),
    (439, 440),
    (440, 441),
    (441, 442),
    (442, 443),
    (443, 444),
    (444, 445),
    (445, 446),
    (446, 447),
    (447, 448),
    (448, 449),
    (449, 450),
    (450, 451),
    (451, 452),
    (452, 453),
    (453, 454),
    (454, 455),
    (455, 456),
    (456, 457),
    (457, 458),
    (458, 459),
    (459, 460),
    (460, 461),
    (461, 462),
    (462, 463),
    (463, 464),
    (464, 465),
    (465, 468),
    (468, 478),
    (478, 479),
    (479, 480),
    (480, 482),
    (482, 511),
];
#[derive(Copy, Clone)]
struct OpcodePattern {
    bitmask: u32,
    pattern: u32,
    extensions: Extensions,
}
impl OpcodePattern {
    const fn base(bitmask: u32, pattern: u32) -> Self {
        Self {
            bitmask,
            pattern,
            extensions: Extensions::none(),
        }
    }
    const fn extension(bitmask: u32, pattern: u32, extension: Extension) -> Self {
        Self {
            bitmask,
            pattern,
            extensions: Extensions::from_extension(extension),
        }
    }
}
/// The bitmask and pattern for each opcode.
static OPCODE_PATTERNS: [OpcodePattern; 511] = [
    // tdi
    OpcodePattern::extension(0xfc000000, 0x8000000, Extension::Ppc64),
    // twi
    OpcodePattern::base(0xfc000000, 0xc000000),
    // dcbz_l
    OpcodePattern::extension(0xffe007ff, 0x100007ec, Extension::PairedSingles),
    // psq_lux
    OpcodePattern::extension(0xfc00007f, 0x1000004c, Extension::PairedSingles),
    // psq_lx
    OpcodePattern::extension(0xfc00007f, 0x1000000c, Extension::PairedSingles),
    // psq_stux
    OpcodePattern::extension(0xfc00007f, 0x1000004e, Extension::PairedSingles),
    // psq_stx
    OpcodePattern::extension(0xfc00007f, 0x1000000e, Extension::PairedSingles),
    // ps_abs
    OpcodePattern::extension(0xfc1f07fe, 0x10000210, Extension::PairedSingles),
    // ps_add
    OpcodePattern::extension(0xfc0007fe, 0x1000002a, Extension::PairedSingles),
    // ps_cmpo0
    OpcodePattern::extension(0xfc6007ff, 0x10000040, Extension::PairedSingles),
    // ps_cmpo1
    OpcodePattern::extension(0xfc6007ff, 0x100000c0, Extension::PairedSingles),
    // ps_cmpu0
    OpcodePattern::extension(0xfc6007ff, 0x10000000, Extension::PairedSingles),
    // ps_cmpu1
    OpcodePattern::extension(0xfc6007ff, 0x10000080, Extension::PairedSingles),
    // ps_div
    OpcodePattern::extension(0xfc0007fe, 0x10000024, Extension::PairedSingles),
    // ps_madd
    OpcodePattern::extension(0xfc00003e, 0x1000003a, Extension::PairedSingles),
    // ps_madds0
    OpcodePattern::extension(0xfc00003e, 0x1000001c, Extension::PairedSingles),
    // ps_madds1
    OpcodePattern::extension(0xfc00003e, 0x1000001e, Extension::PairedSingles),
    // ps_merge00
    OpcodePattern::extension(0xfc0007fe, 0x10000420, Extension::PairedSingles),
    // ps_merge01
    OpcodePattern::extension(0xfc0007fe, 0x10000460, Extension::PairedSingles),
    // ps_merge10
    OpcodePattern::extension(0xfc0007fe, 0x100004a0, Extension::PairedSingles),
    // ps_merge11
    OpcodePattern::extension(0xfc0007fe, 0x100004e0, Extension::PairedSingles),
    // ps_mr
    OpcodePattern::extension(0xfc1f07fe, 0x10000090, Extension::PairedSingles),
    // ps_msub
    OpcodePattern::extension(0xfc00003e, 0x10000038, Extension::PairedSingles),
    // ps_mul
    OpcodePattern::extension(0xfc00f83e, 0x10000032, Extension::PairedSingles),
    // ps_muls0
    OpcodePattern::extension(0xfc00f83e, 0x10000018, Extension::PairedSingles),
    // ps_muls1
    OpcodePattern::extension(0xfc00f83e, 0x1000001a, Extension::PairedSingles),
    // ps_nabs
    OpcodePattern::extension(0xfc1f07fe, 0x10000110, Extension::PairedSingles),
    // ps_neg
    OpcodePattern::extension(0xfc1f07fe, 0x10000050, Extension::PairedSingles),
    // ps_nmadd
    OpcodePattern::extension(0xfc00003e, 0x1000003e, Extension::PairedSingles),
    // ps_nmsub
    OpcodePattern::extension(0xfc00003e, 0x1000003c, Extension::PairedSingles),
    // ps_res
    OpcodePattern::extension(0xfc1f07fe, 0x10000030, Extension::PairedSingles),
    // ps_rsqrte
    OpcodePattern::extension(0xfc1f07fe, 0x10000034, Extension::PairedSingles),
    // ps_sel
    OpcodePattern::extension(0xfc00003e, 0x1000002e, Extension::PairedSingles),
    // ps_sub
    OpcodePattern::extension(0xfc0007fe, 0x10000028, Extension::PairedSingles),
    // ps_sum0
    OpcodePattern::extension(0xfc00003e, 0x10000014, Extension::PairedSingles),
    // ps_sum1
    OpcodePattern::extension(0xfc00003e, 0x10000016, Extension::PairedSingles),
    // mfvscr
    OpcodePattern::extension(0xfc1fffff, 0x10000604, Extension::AltiVec),
    // mtvscr
    OpcodePattern::extension(0xffff07ff, 0x10000644, Extension::AltiVec),
    // vaddcuw
    OpcodePattern::extension(0xfc0007ff, 0x10000180, Extension::AltiVec),
    // vaddfp
    OpcodePattern::extension(0xfc0007ff, 0x1000000a, Extension::AltiVec),
    // vaddsbs
    OpcodePattern::extension(0xfc0007ff, 0x10000300, Extension::AltiVec),
    // vaddshs
    OpcodePattern::extension(0xfc0007ff, 0x10000340, Extension::AltiVec),
    // vaddsws
    OpcodePattern::extension(0xfc0007ff, 0x10000380, Extension::AltiVec),
    // vaddubm
    OpcodePattern::extension(0xfc0007ff, 0x10000000, Extension::AltiVec),
    // vaddubs
    OpcodePattern::extension(0xfc0007ff, 0x10000200, Extension::AltiVec),
    // vadduhm
    OpcodePattern::extension(0xfc0007ff, 0x10000040, Extension::AltiVec),
    // vadduhs
    OpcodePattern::extension(0xfc0007ff, 0x10000240, Extension::AltiVec),
    // vadduwm
    OpcodePattern::extension(0xfc0007ff, 0x10000080, Extension::AltiVec),
    // vadduws
    OpcodePattern::extension(0xfc0007ff, 0x10000280, Extension::AltiVec),
    // vand
    OpcodePattern::extension(0xfc0007ff, 0x10000404, Extension::AltiVec),
    // vandc
    OpcodePattern::extension(0xfc0007ff, 0x10000444, Extension::AltiVec),
    // vavgsb
    OpcodePattern::extension(0xfc0007ff, 0x10000502, Extension::AltiVec),
    // vavgsh
    OpcodePattern::extension(0xfc0007ff, 0x10000542, Extension::AltiVec),
    // vavgsw
    OpcodePattern::extension(0xfc0007ff, 0x10000582, Extension::AltiVec),
    // vavgub
    OpcodePattern::extension(0xfc0007ff, 0x10000402, Extension::AltiVec),
    // vavguh
    OpcodePattern::extension(0xfc0007ff, 0x10000442, Extension::AltiVec),
    // vavguw
    OpcodePattern::extension(0xfc0007ff, 0x10000482, Extension::AltiVec),
    // vcfsx
    OpcodePattern::extension(0xfc0007ff, 0x1000034a, Extension::AltiVec),
    // vcfux
    OpcodePattern::extension(0xfc0007ff, 0x1000030a, Extension::AltiVec),
    // vcmpbfp
    OpcodePattern::extension(0xfc0003ff, 0x100003c6, Extension::AltiVec),
    // vcmpeqfp
    OpcodePattern::extension(0xfc0003ff, 0x100000c6, Extension::AltiVec),
    // vcmpequb
    OpcodePattern::extension(0xfc0003ff, 0x10000006, Extension::AltiVec),
    // vcmpequh
    OpcodePattern::extension(0xfc0003ff, 0x10000046, Extension::AltiVec),
    // vcmpequw
    OpcodePattern::extension(0xfc0003ff, 0x10000086, Extension::AltiVec),
    // vcmpgefp
    OpcodePattern::extension(0xfc0003ff, 0x100001c6, Extension::AltiVec),
    // vcmpgtfp
    OpcodePattern::extension(0xfc0003ff, 0x100002c6, Extension::AltiVec),
    // vcmpgtsb
    OpcodePattern::extension(0xfc0003ff, 0x10000306, Extension::AltiVec),
    // vcmpgtsh
    OpcodePattern::extension(0xfc0003ff, 0x10000346, Extension::AltiVec),
    // vcmpgtsw
    OpcodePattern::extension(0xfc0003ff, 0x10000386, Extension::AltiVec),
    // vcmpgtub
    OpcodePattern::extension(0xfc0003ff, 0x10000206, Extension::AltiVec),
    // vcmpgtuh
    OpcodePattern::extension(0xfc0003ff, 0x10000246, Extension::AltiVec),
    // vcmpgtuw
    OpcodePattern::extension(0xfc0003ff, 0x10000286, Extension::AltiVec),
    // vctsxs
    OpcodePattern::extension(0xfc0007ff, 0x100003ca, Extension::AltiVec),
    // vctuxs
    OpcodePattern::extension(0xfc0007ff, 0x1000038a, Extension::AltiVec),
    // vexptefp
    OpcodePattern::extension(0xfc1f07ff, 0x1000018a, Extension::AltiVec),
    // vlogefp
    OpcodePattern::extension(0xfc1f07ff, 0x100001ca, Extension::AltiVec),
    // vmaddfp
    OpcodePattern::extension(0xfc00003f, 0x1000002e, Extension::AltiVec),
    // vmaxfp
    OpcodePattern::extension(0xfc0007ff, 0x1000040a, Extension::AltiVec),
    // vmaxsb
    OpcodePattern::extension(0xfc0007ff, 0x10000102, Extension::AltiVec),
    // vmaxsh
    OpcodePattern::extension(0xfc0007ff, 0x10000142, Extension::AltiVec),
    // vmaxsw
    OpcodePattern::extension(0xfc0007ff, 0x10000182, Extension::AltiVec),
    // vmaxub
    OpcodePattern::extension(0xfc0007ff, 0x10000002, Extension::AltiVec),
    // vmaxuh
    OpcodePattern::extension(0xfc0007ff, 0x10000042, Extension::AltiVec),
    // vmaxuw
    OpcodePattern::extension(0xfc0007ff, 0x10000082, Extension::AltiVec),
    // vmhaddshs
    OpcodePattern::extension(0xfc00003f, 0x10000020, Extension::AltiVec),
    // vmhraddshs
    OpcodePattern::extension(0xfc00003f, 0x10000021, Extension::AltiVec),
    // vminfp
    OpcodePattern::extension(0xfc0007ff, 0x1000044a, Extension::AltiVec),
    // vminsb
    OpcodePattern::extension(0xfc0007ff, 0x10000302, Extension::AltiVec),
    // vminsh
    OpcodePattern::extension(0xfc0007ff, 0x10000342, Extension::AltiVec),
    // vminsw
    OpcodePattern::extension(0xfc0007ff, 0x10000382, Extension::AltiVec),
    // vminub
    OpcodePattern::extension(0xfc0007ff, 0x10000202, Extension::AltiVec),
    // vminuh
    OpcodePattern::extension(0xfc0007ff, 0x10000242, Extension::AltiVec),
    // vminuw
    OpcodePattern::extension(0xfc0007ff, 0x10000282, Extension::AltiVec),
    // vmladduhm
    OpcodePattern::extension(0xfc00003f, 0x10000022, Extension::AltiVec),
    // vmrghb
    OpcodePattern::extension(0xfc0007ff, 0x1000000c, Extension::AltiVec),
    // vmrghh
    OpcodePattern::extension(0xfc0007ff, 0x1000004c, Extension::AltiVec),
    // vmrghw
    OpcodePattern::extension(0xfc0007ff, 0x1000008c, Extension::AltiVec),
    // vmrglb
    OpcodePattern::extension(0xfc0007ff, 0x1000010c, Extension::AltiVec),
    // vmrglh
    OpcodePattern::extension(0xfc0007ff, 0x1000014c, Extension::AltiVec),
    // vmrglw
    OpcodePattern::extension(0xfc0007ff, 0x1000018c, Extension::AltiVec),
    // vmsummbm
    OpcodePattern::extension(0xfc00003f, 0x10000025, Extension::AltiVec),
    // vmsumshm
    OpcodePattern::extension(0xfc00003f, 0x10000028, Extension::AltiVec),
    // vmsumshs
    OpcodePattern::extension(0xfc00003f, 0x10000029, Extension::AltiVec),
    // vmsumubm
    OpcodePattern::extension(0xfc00003f, 0x10000024, Extension::AltiVec),
    // vmsumuhm
    OpcodePattern::extension(0xfc00003f, 0x10000026, Extension::AltiVec),
    // vmsumuhs
    OpcodePattern::extension(0xfc00003f, 0x10000027, Extension::AltiVec),
    // vmulesb
    OpcodePattern::extension(0xfc0007ff, 0x10000308, Extension::AltiVec),
    // vmulesh
    OpcodePattern::extension(0xfc0007ff, 0x10000348, Extension::AltiVec),
    // vmuleub
    OpcodePattern::extension(0xfc0007ff, 0x10000208, Extension::AltiVec),
    // vmuleuh
    OpcodePattern::extension(0xfc0007ff, 0x10000248, Extension::AltiVec),
    // vmulosb
    OpcodePattern::extension(0xfc0007ff, 0x10000108, Extension::AltiVec),
    // vmulosh
    OpcodePattern::extension(0xfc0007ff, 0x10000148, Extension::AltiVec),
    // vmuloub
    OpcodePattern::extension(0xfc0007ff, 0x10000008, Extension::AltiVec),
    // vmulouh
    OpcodePattern::extension(0xfc0007ff, 0x10000048, Extension::AltiVec),
    // vnmsubfp
    OpcodePattern::extension(0xfc00003f, 0x1000002f, Extension::AltiVec),
    // vnor
    OpcodePattern::extension(0xfc0007ff, 0x10000504, Extension::AltiVec),
    // vor
    OpcodePattern::extension(0xfc0007ff, 0x10000484, Extension::AltiVec),
    // vperm
    OpcodePattern::extension(0xfc00003f, 0x1000002b, Extension::AltiVec),
    // vpkpx
    OpcodePattern::extension(0xfc0007ff, 0x1000030e, Extension::AltiVec),
    // vpkshss
    OpcodePattern::extension(0xfc0007ff, 0x1000018e, Extension::AltiVec),
    // vpkshus
    OpcodePattern::extension(0xfc0007ff, 0x1000010e, Extension::AltiVec),
    // vpkswss
    OpcodePattern::extension(0xfc0007ff, 0x100001ce, Extension::AltiVec),
    // vpkswus
    OpcodePattern::extension(0xfc0007ff, 0x1000014e, Extension::AltiVec),
    // vpkuhum
    OpcodePattern::extension(0xfc0007ff, 0x1000000e, Extension::AltiVec),
    // vpkuhus
    OpcodePattern::extension(0xfc0007ff, 0x1000008e, Extension::AltiVec),
    // vpkuwum
    OpcodePattern::extension(0xfc0007ff, 0x1000004e, Extension::AltiVec),
    // vpkuwus
    OpcodePattern::extension(0xfc0007ff, 0x100000ce, Extension::AltiVec),
    // vrefp
    OpcodePattern::extension(0xfc1f07ff, 0x1000010a, Extension::AltiVec),
    // vrfim
    OpcodePattern::extension(0xfc1f07ff, 0x100002ca, Extension::AltiVec),
    // vrfin
    OpcodePattern::extension(0xfc1f07ff, 0x1000020a, Extension::AltiVec),
    // vrfip
    OpcodePattern::extension(0xfc1f07ff, 0x1000028a, Extension::AltiVec),
    // vrfiz
    OpcodePattern::extension(0xfc1f07ff, 0x1000024a, Extension::AltiVec),
    // vrlb
    OpcodePattern::extension(0xfc0007ff, 0x10000004, Extension::AltiVec),
    // vrlh
    OpcodePattern::extension(0xfc0007ff, 0x10000044, Extension::AltiVec),
    // vrlw
    OpcodePattern::extension(0xfc0007ff, 0x10000084, Extension::AltiVec),
    // vrsqrtefp
    OpcodePattern::extension(0xfc1f07ff, 0x1000014a, Extension::AltiVec),
    // vsel
    OpcodePattern::extension(0xfc00003f, 0x1000002a, Extension::AltiVec),
    // vsl
    OpcodePattern::extension(0xfc0007ff, 0x100001c4, Extension::AltiVec),
    // vslb
    OpcodePattern::extension(0xfc0007ff, 0x10000104, Extension::AltiVec),
    // vsldoi
    OpcodePattern::extension(0xfc00043f, 0x1000002c, Extension::AltiVec),
    // vslh
    OpcodePattern::extension(0xfc0007ff, 0x10000144, Extension::AltiVec),
    // vslo
    OpcodePattern::extension(0xfc0007ff, 0x1000040c, Extension::AltiVec),
    // vslw
    OpcodePattern::extension(0xfc0007ff, 0x10000184, Extension::AltiVec),
    // vspltb
    OpcodePattern::extension(0xfc0007ff, 0x1000020c, Extension::AltiVec),
    // vsplth
    OpcodePattern::extension(0xfc0007ff, 0x1000024c, Extension::AltiVec),
    // vspltisb
    OpcodePattern::extension(0xfc00ffff, 0x1000030c, Extension::AltiVec),
    // vspltish
    OpcodePattern::extension(0xfc00ffff, 0x1000034c, Extension::AltiVec),
    // vspltisw
    OpcodePattern::extension(0xfc00ffff, 0x1000038c, Extension::AltiVec),
    // vspltw
    OpcodePattern::extension(0xfc0007ff, 0x1000028c, Extension::AltiVec),
    // vsr
    OpcodePattern::extension(0xfc0007ff, 0x100002c4, Extension::AltiVec),
    // vsrab
    OpcodePattern::extension(0xfc0007ff, 0x10000304, Extension::AltiVec),
    // vsrah
    OpcodePattern::extension(0xfc0007ff, 0x10000344, Extension::AltiVec),
    // vsraw
    OpcodePattern::extension(0xfc0007ff, 0x10000384, Extension::AltiVec),
    // vsrb
    OpcodePattern::extension(0xfc0007ff, 0x10000204, Extension::AltiVec),
    // vsrh
    OpcodePattern::extension(0xfc0007ff, 0x10000244, Extension::AltiVec),
    // vsro
    OpcodePattern::extension(0xfc0007ff, 0x1000044c, Extension::AltiVec),
    // vsrw
    OpcodePattern::extension(0xfc0007ff, 0x10000284, Extension::AltiVec),
    // vsubcuw
    OpcodePattern::extension(0xfc0007ff, 0x10000580, Extension::AltiVec),
    // vsubfp
    OpcodePattern::extension(0xfc0007ff, 0x1000004a, Extension::AltiVec),
    // vsubsbs
    OpcodePattern::extension(0xfc0007ff, 0x10000700, Extension::AltiVec),
    // vsubshs
    OpcodePattern::extension(0xfc0007ff, 0x10000740, Extension::AltiVec),
    // vsubsws
    OpcodePattern::extension(0xfc0007ff, 0x10000780, Extension::AltiVec),
    // vsububm
    OpcodePattern::extension(0xfc0007ff, 0x10000400, Extension::AltiVec),
    // vsububs
    OpcodePattern::extension(0xfc0007ff, 0x10000600, Extension::AltiVec),
    // vsubuhm
    OpcodePattern::extension(0xfc0007ff, 0x10000440, Extension::AltiVec),
    // vsubuhs
    OpcodePattern::extension(0xfc0007ff, 0x10000640, Extension::AltiVec),
    // vsubuwm
    OpcodePattern::extension(0xfc0007ff, 0x10000480, Extension::AltiVec),
    // vsubuws
    OpcodePattern::extension(0xfc0007ff, 0x10000680, Extension::AltiVec),
    // vsumsws
    OpcodePattern::extension(0xfc0007ff, 0x10000788, Extension::AltiVec),
    // vsum2sws
    OpcodePattern::extension(0xfc0007ff, 0x10000688, Extension::AltiVec),
    // vsum4sbs
    OpcodePattern::extension(0xfc0007ff, 0x10000708, Extension::AltiVec),
    // vsum4shs
    OpcodePattern::extension(0xfc0007ff, 0x10000648, Extension::AltiVec),
    // vsum4ubs
    OpcodePattern::extension(0xfc0007ff, 0x10000608, Extension::AltiVec),
    // vupkhpx
    OpcodePattern::extension(0xfc1f07ff, 0x1000034e, Extension::AltiVec),
    // vupkhsb
    OpcodePattern::extension(0xfc1f07ff, 0x1000020e, Extension::AltiVec),
    // vupkhsh
    OpcodePattern::extension(0xfc1f07ff, 0x1000024e, Extension::AltiVec),
    // vupklpx
    OpcodePattern::extension(0xfc1f07ff, 0x100003ce, Extension::AltiVec),
    // vupklsb
    OpcodePattern::extension(0xfc1f07ff, 0x1000028e, Extension::AltiVec),
    // vupklsh
    OpcodePattern::extension(0xfc1f07ff, 0x100002ce, Extension::AltiVec),
    // vxor
    OpcodePattern::extension(0xfc0007ff, 0x100004c4, Extension::AltiVec),
    // lvewx128
    OpcodePattern::extension(0xfc0007f3, 0x10000083, Extension::Vmx128),
    // lvlx128
    OpcodePattern::extension(0xfc0007f3, 0x10000403, Extension::Vmx128),
    // lvlxl128
    OpcodePattern::extension(0xfc0007f3, 0x10000603, Extension::Vmx128),
    // lvrx128
    OpcodePattern::extension(0xfc0007f3, 0x10000443, Extension::Vmx128),
    // lvrxl128
    OpcodePattern::extension(0xfc0007f3, 0x10000643, Extension::Vmx128),
    // lvsl128
    OpcodePattern::extension(0xfc0007f3, 0x10000003, Extension::Vmx128),
    // lvsr128
    OpcodePattern::extension(0xfc0007f3, 0x10000043, Extension::Vmx128),
    // lvx128
    OpcodePattern::extension(0xfc0007f3, 0x100000c3, Extension::Vmx128),
    // lvxl128
    OpcodePattern::extension(0xfc0007f3, 0x100002c3, Extension::Vmx128),
    // stvewx128
    OpcodePattern::extension(0xfc0007f3, 0x10000183, Extension::Vmx128),
    // stvlx128
    OpcodePattern::extension(0xfc0007f3, 0x10000503, Extension::Vmx128),
    // stvlxl128
    OpcodePattern::extension(0xfc0007f3, 0x10000703, Extension::Vmx128),
    // stvrx128
    OpcodePattern::extension(0xfc0007f3, 0x10000543, Extension::Vmx128),
    // stvrxl128
    OpcodePattern::extension(0xfc0007f3, 0x10000743, Extension::Vmx128),
    // stvx128
    OpcodePattern::extension(0xfc0007f3, 0x100001c3, Extension::Vmx128),
    // stvxl128
    OpcodePattern::extension(0xfc0007f3, 0x100003c3, Extension::Vmx128),
    // vsldoi128
    OpcodePattern::extension(0xfc000010, 0x10000010, Extension::Vmx128),
    // vaddfp128
    OpcodePattern::extension(0xfc0003d0, 0x14000010, Extension::Vmx128),
    // vand128
    OpcodePattern::extension(0xfc0003d0, 0x14000210, Extension::Vmx128),
    // vandc128
    OpcodePattern::extension(0xfc0003d0, 0x14000250, Extension::Vmx128),
    // vmaddcfp128
    OpcodePattern::extension(0xfc0003d0, 0x14000110, Extension::Vmx128),
    // vmaddfp128
    OpcodePattern::extension(0xfc0003d0, 0x140000d0, Extension::Vmx128),
    // vmsum3fp128
    OpcodePattern::extension(0xfc0003d0, 0x14000190, Extension::Vmx128),
    // vmsum4fp128
    OpcodePattern::extension(0xfc0003d0, 0x140001d0, Extension::Vmx128),
    // vmulfp128
    OpcodePattern::extension(0xfc0003d0, 0x14000090, Extension::Vmx128),
    // vnmsubfp128
    OpcodePattern::extension(0xfc0003d0, 0x14000150, Extension::Vmx128),
    // vnor128
    OpcodePattern::extension(0xfc0003d0, 0x14000290, Extension::Vmx128),
    // vor128
    OpcodePattern::extension(0xfc0003d0, 0x140002d0, Extension::Vmx128),
    // vperm128
    OpcodePattern::extension(0xfc000210, 0x14000000, Extension::Vmx128),
    // vpkshss128
    OpcodePattern::extension(0xfc0003d0, 0x14000200, Extension::Vmx128),
    // vpkshus128
    OpcodePattern::extension(0xfc0003d0, 0x14000240, Extension::Vmx128),
    // vpkswss128
    OpcodePattern::extension(0xfc0003d0, 0x14000280, Extension::Vmx128),
    // vpkswus128
    OpcodePattern::extension(0xfc0003d0, 0x140002c0, Extension::Vmx128),
    // vpkuhum128
    OpcodePattern::extension(0xfc0003d0, 0x14000300, Extension::Vmx128),
    // vpkuhus128
    OpcodePattern::extension(0xfc0003d0, 0x14000340, Extension::Vmx128),
    // vpkuwum128
    OpcodePattern::extension(0xfc0003d0, 0x14000380, Extension::Vmx128),
    // vpkuwus128
    OpcodePattern::extension(0xfc0003d0, 0x140003c0, Extension::Vmx128),
    // vsel128
    OpcodePattern::extension(0xfc0003d0, 0x14000350, Extension::Vmx128),
    // vslo128
    OpcodePattern::extension(0xfc0003d0, 0x14000390, Extension::Vmx128),
    // vsro128
    OpcodePattern::extension(0xfc0003d0, 0x140003d0, Extension::Vmx128),
    // vsubfp128
    OpcodePattern::extension(0xfc0003d0, 0x14000050, Extension::Vmx128),
    // vxor128
    OpcodePattern::extension(0xfc0003d0, 0x14000310, Extension::Vmx128),
    // vctsxs128
    OpcodePattern::extension(0xfc0007f0, 0x18000230, Extension::Vmx128),
    // vctuxs128
    OpcodePattern::extension(0xfc0007f0, 0x18000270, Extension::Vmx128),
    // vcmpbfp128
    OpcodePattern::extension(0xfc000390, 0x18000180, Extension::Vmx128),
    // vcmpeqfp128
    OpcodePattern::extension(0xfc000390, 0x18000000, Extension::Vmx128),
    // vcmpequw128
    OpcodePattern::extension(0xfc000390, 0x18000200, Extension::Vmx128),
    // vcmpgefp128
    OpcodePattern::extension(0xfc000390, 0x18000080, Extension::Vmx128),
    // vcmpgtfp128
    OpcodePattern::extension(0xfc000390, 0x18000100, Extension::Vmx128),
    // vcfsx128
    OpcodePattern::extension(0xfc0007f0, 0x180002b0, Extension::Vmx128),
    // vcfux128
    OpcodePattern::extension(0xfc0007f0, 0x180002f0, Extension::Vmx128),
    // vexptefp128
    OpcodePattern::extension(0xfc1f07f0, 0x180006b0, Extension::Vmx128),
    // vlogefp128
    OpcodePattern::extension(0xfc1f07f0, 0x180006f0, Extension::Vmx128),
    // vmaxfp128
    OpcodePattern::extension(0xfc0003d0, 0x18000280, Extension::Vmx128),
    // vminfp128
    OpcodePattern::extension(0xfc0003d0, 0x180002c0, Extension::Vmx128),
    // vmrghw128
    OpcodePattern::extension(0xfc0003d0, 0x18000300, Extension::Vmx128),
    // vmrglw128
    OpcodePattern::extension(0xfc0003d0, 0x18000340, Extension::Vmx128),
    // vpermwi128
    OpcodePattern::extension(0xfc000630, 0x18000210, Extension::Vmx128),
    // vpkd3d128
    OpcodePattern::extension(0xfc000730, 0x18000610, Extension::Vmx128),
    // vrefp128
    OpcodePattern::extension(0xfc1f07f0, 0x18000630, Extension::Vmx128),
    // vrfim128
    OpcodePattern::extension(0xfc1f07f0, 0x18000330, Extension::Vmx128),
    // vrfin128
    OpcodePattern::extension(0xfc1f07f0, 0x18000370, Extension::Vmx128),
    // vrfip128
    OpcodePattern::extension(0xfc1f07f0, 0x180003b0, Extension::Vmx128),
    // vrfiz128
    OpcodePattern::extension(0xfc1f07f0, 0x180003f0, Extension::Vmx128),
    // vrlimi128
    OpcodePattern::extension(0xfc000730, 0x18000710, Extension::Vmx128),
    // vrlw128
    OpcodePattern::extension(0xfc0003d0, 0x18000050, Extension::Vmx128),
    // vrsqrtefp128
    OpcodePattern::extension(0xfc1f07f0, 0x18000670, Extension::Vmx128),
    // vslw128
    OpcodePattern::extension(0xfc0003d0, 0x180000d0, Extension::Vmx128),
    // vspltisw128
    OpcodePattern::extension(0xfc0007f0, 0x18000770, Extension::Vmx128),
    // vspltw128
    OpcodePattern::extension(0xfc0007f0, 0x18000730, Extension::Vmx128),
    // vsraw128
    OpcodePattern::extension(0xfc0003d0, 0x18000150, Extension::Vmx128),
    // vsrw128
    OpcodePattern::extension(0xfc0003d0, 0x180001d0, Extension::Vmx128),
    // vupkd3d128
    OpcodePattern::extension(0xfc0007f0, 0x180007f0, Extension::Vmx128),
    // vupkhsb128
    OpcodePattern::extension(0xfc1f07f0, 0x18000380, Extension::Vmx128),
    // vupkhsh128
    OpcodePattern::extension(0xfc1f07f0, 0x180007a0, Extension::Vmx128),
    // vupklsb128
    OpcodePattern::extension(0xfc1f07f0, 0x180003c0, Extension::Vmx128),
    // vupklsh128
    OpcodePattern::extension(0xfc1f07f0, 0x180007e0, Extension::Vmx128),
    // mulli
    OpcodePattern::base(0xfc000000, 0x1c000000),
    // subfic
    OpcodePattern::base(0xfc000000, 0x20000000),
    // cmpli
    OpcodePattern::base(0xfc400000, 0x28000000),
    // cmpi
    OpcodePattern::base(0xfc400000, 0x2c000000),
    // addic
    OpcodePattern::base(0xfc000000, 0x30000000),
    // addic.
    OpcodePattern::base(0xfc000000, 0x34000000),
    // addi
    OpcodePattern::base(0xfc000000, 0x38000000),
    // addis
    OpcodePattern::base(0xfc000000, 0x3c000000),
    // bc
    OpcodePattern::base(0xfc000000, 0x40000000),
    // sc
    OpcodePattern::base(0xffffffff, 0x44000002),
    // b
    OpcodePattern::base(0xfc000000, 0x48000000),
    // bcctr
    OpcodePattern::base(0xfc00fffe, 0x4c000420),
    // bclr
    OpcodePattern::base(0xfc00fffe, 0x4c000020),
    // crand
    OpcodePattern::base(0xfc0007ff, 0x4c000202),
    // crandc
    OpcodePattern::base(0xfc0007ff, 0x4c000102),
    // creqv
    OpcodePattern::base(0xfc0007ff, 0x4c000242),
    // crnand
    OpcodePattern::base(0xfc0007ff, 0x4c0001c2),
    // crnor
    OpcodePattern::base(0xfc0007ff, 0x4c000042),
    // cror
    OpcodePattern::base(0xfc0007ff, 0x4c000382),
    // crorc
    OpcodePattern::base(0xfc0007ff, 0x4c000342),
    // crxor
    OpcodePattern::base(0xfc0007ff, 0x4c000182),
    // isync
    OpcodePattern::base(0xffffffff, 0x4c00012c),
    // mcrf
    OpcodePattern::base(0xfc63ffff, 0x4c000000),
    // rfi
    OpcodePattern::base(0xffffffff, 0x4c000064),
    // rfid
    OpcodePattern::extension(0xffffffff, 0x4c000024, Extension::Ppc64),
    // rlwimi
    OpcodePattern::base(0xfc000000, 0x50000000),
    // rlwinm
    OpcodePattern::base(0xfc000000, 0x54000000),
    // rlwnm
    OpcodePattern::base(0xfc000000, 0x5c000000),
    // ori
    OpcodePattern::base(0xfc000000, 0x60000000),
    // oris
    OpcodePattern::base(0xfc000000, 0x64000000),
    // xori
    OpcodePattern::base(0xfc000000, 0x68000000),
    // xoris
    OpcodePattern::base(0xfc000000, 0x6c000000),
    // andi.
    OpcodePattern::base(0xfc000000, 0x70000000),
    // andis.
    OpcodePattern::base(0xfc000000, 0x74000000),
    // rldcl
    OpcodePattern::extension(0xfc00001e, 0x78000010, Extension::Ppc64),
    // rldcr
    OpcodePattern::extension(0xfc00001e, 0x78000012, Extension::Ppc64),
    // rldic
    OpcodePattern::extension(0xfc00001c, 0x78000008, Extension::Ppc64),
    // rldicl
    OpcodePattern::extension(0xfc00001c, 0x78000000, Extension::Ppc64),
    // rldicr
    OpcodePattern::extension(0xfc00001c, 0x78000004, Extension::Ppc64),
    // rldimi
    OpcodePattern::extension(0xfc00001c, 0x7800000c, Extension::Ppc64),
    // add
    OpcodePattern::base(0xfc0003fe, 0x7c000214),
    // addc
    OpcodePattern::base(0xfc0003fe, 0x7c000014),
    // adde
    OpcodePattern::base(0xfc0003fe, 0x7c000114),
    // addme
    OpcodePattern::base(0xfc00fbfe, 0x7c0001d4),
    // addze
    OpcodePattern::base(0xfc00fbfe, 0x7c000194),
    // and
    OpcodePattern::base(0xfc0007fe, 0x7c000038),
    // andc
    OpcodePattern::base(0xfc0007fe, 0x7c000078),
    // cmp
    OpcodePattern::base(0xfc4007ff, 0x7c000000),
    // cmpl
    OpcodePattern::base(0xfc4007ff, 0x7c000040),
    // cntlzw
    OpcodePattern::base(0xfc00fffe, 0x7c000034),
    // dcbf
    OpcodePattern::base(0xffe007ff, 0x7c0000ac),
    // dcbi
    OpcodePattern::base(0xffe007ff, 0x7c0003ac),
    // dcbst
    OpcodePattern::base(0xffe007ff, 0x7c00006c),
    // dcbt
    OpcodePattern::base(0xffe007ff, 0x7c00022c),
    // dcbtst
    OpcodePattern::base(0xffe007ff, 0x7c0001ec),
    // dcbz
    OpcodePattern::base(0xffe007ff, 0x7c0007ec),
    // divw
    OpcodePattern::base(0xfc0003fe, 0x7c0003d6),
    // divwu
    OpcodePattern::base(0xfc0003fe, 0x7c000396),
    // eciwx
    OpcodePattern::base(0xfc0007ff, 0x7c00026c),
    // ecowx
    OpcodePattern::base(0xfc0007ff, 0x7c00036c),
    // eieio
    OpcodePattern::base(0xffffffff, 0x7c0006ac),
    // eqv
    OpcodePattern::base(0xfc0007fe, 0x7c000238),
    // extsb
    OpcodePattern::base(0xfc00fffe, 0x7c000774),
    // extsh
    OpcodePattern::base(0xfc00fffe, 0x7c000734),
    // icbi
    OpcodePattern::base(0xffe007fe, 0x7c0007ac),
    // lbzux
    OpcodePattern::base(0xfc0007ff, 0x7c0000ee),
    // lbzx
    OpcodePattern::base(0xfc0007ff, 0x7c0000ae),
    // lfdux
    OpcodePattern::base(0xfc0007ff, 0x7c0004ee),
    // lfdx
    OpcodePattern::base(0xfc0007ff, 0x7c0004ae),
    // lfsux
    OpcodePattern::base(0xfc0007ff, 0x7c00046e),
    // lfsx
    OpcodePattern::base(0xfc0007ff, 0x7c00042e),
    // lhaux
    OpcodePattern::base(0xfc0007ff, 0x7c0002ee),
    // lhax
    OpcodePattern::base(0xfc0007ff, 0x7c0002ae),
    // lhbrx
    OpcodePattern::base(0xfc0007ff, 0x7c00062c),
    // lhzux
    OpcodePattern::base(0xfc0007ff, 0x7c00026e),
    // lhzx
    OpcodePattern::base(0xfc0007ff, 0x7c00022e),
    // lswi
    OpcodePattern::base(0xfc0007ff, 0x7c0004aa),
    // lswx
    OpcodePattern::base(0xfc0007ff, 0x7c00042a),
    // lwarx
    OpcodePattern::base(0xfc0007ff, 0x7c000028),
    // lwbrx
    OpcodePattern::base(0xfc0007ff, 0x7c00042c),
    // lwzux
    OpcodePattern::base(0xfc0007ff, 0x7c00006e),
    // lwzx
    OpcodePattern::base(0xfc0007ff, 0x7c00002e),
    // mcrxr
    OpcodePattern::base(0xfc7fffff, 0x7c000400),
    // mfcr
    OpcodePattern::base(0xfc1fffff, 0x7c000026),
    // mfmsr
    OpcodePattern::base(0xfc1fffff, 0x7c0000a6),
    // mfspr
    OpcodePattern::base(0xfc0007ff, 0x7c0002a6),
    // mfsr
    OpcodePattern::base(0xfc10ffff, 0x7c0004a6),
    // mfsrin
    OpcodePattern::base(0xfc1f07ff, 0x7c000526),
    // mftb
    OpcodePattern::base(0xfc0007ff, 0x7c0002e6),
    // mtcrf
    OpcodePattern::base(0xfc100fff, 0x7c000120),
    // mtmsr
    OpcodePattern::base(0xfc1fffff, 0x7c000124),
    // mtspr
    OpcodePattern::base(0xfc0007ff, 0x7c0003a6),
    // mtsr
    OpcodePattern::base(0xfc10ffff, 0x7c0001a4),
    // mtsrin
    OpcodePattern::base(0xfc1f07ff, 0x7c0001e4),
    // mulhw
    OpcodePattern::base(0xfc0007fe, 0x7c000096),
    // mulhwu
    OpcodePattern::base(0xfc0007fe, 0x7c000016),
    // mullw
    OpcodePattern::base(0xfc0003fe, 0x7c0001d6),
    // nand
    OpcodePattern::base(0xfc0007fe, 0x7c0003b8),
    // neg
    OpcodePattern::base(0xfc00fbfe, 0x7c0000d0),
    // nor
    OpcodePattern::base(0xfc0007fe, 0x7c0000f8),
    // or
    OpcodePattern::base(0xfc0007fe, 0x7c000378),
    // orc
    OpcodePattern::base(0xfc0007fe, 0x7c000338),
    // slw
    OpcodePattern::base(0xfc0007fe, 0x7c000030),
    // sraw
    OpcodePattern::base(0xfc0007fe, 0x7c000630),
    // srawi
    OpcodePattern::base(0xfc0007fe, 0x7c000670),
    // srw
    OpcodePattern::base(0xfc0007fe, 0x7c000430),
    // stbux
    OpcodePattern::base(0xfc0007ff, 0x7c0001ee),
    // stbx
    OpcodePattern::base(0xfc0007ff, 0x7c0001ae),
    // stfdux
    OpcodePattern::base(0xfc0007ff, 0x7c0005ee),
    // stfdx
    OpcodePattern::base(0xfc0007ff, 0x7c0005ae),
    // stfiwx
    OpcodePattern::base(0xfc0007ff, 0x7c0007ae),
    // stfsux
    OpcodePattern::base(0xfc0007ff, 0x7c00056e),
    // stfsx
    OpcodePattern::base(0xfc0007ff, 0x7c00052e),
    // sthbrx
    OpcodePattern::base(0xfc0007ff, 0x7c00072c),
    // sthux
    OpcodePattern::base(0xfc0007ff, 0x7c00036e),
    // sthx
    OpcodePattern::base(0xfc0007ff, 0x7c00032e),
    // stswi
    OpcodePattern::base(0xfc0007ff, 0x7c0005aa),
    // stswx
    OpcodePattern::base(0xfc0007ff, 0x7c00052a),
    // stwbrx
    OpcodePattern::base(0xfc0007ff, 0x7c00052c),
    // stwcx.
    OpcodePattern::base(0xfc0007ff, 0x7c00012d),
    // stwux
    OpcodePattern::base(0xfc0007ff, 0x7c00016e),
    // stwx
    OpcodePattern::base(0xfc0007ff, 0x7c00012e),
    // subf
    OpcodePattern::base(0xfc0003fe, 0x7c000050),
    // subfc
    OpcodePattern::base(0xfc0003fe, 0x7c000010),
    // subfe
    OpcodePattern::base(0xfc0003fe, 0x7c000110),
    // subfme
    OpcodePattern::base(0xfc00fbfe, 0x7c0001d0),
    // subfze
    OpcodePattern::base(0xfc00fbfe, 0x7c000190),
    // sync
    OpcodePattern::base(0xff9fffff, 0x7c0004ac),
    // tlbie
    OpcodePattern::base(0xffff07ff, 0x7c000264),
    // tlbsync
    OpcodePattern::base(0xffffffff, 0x7c00046c),
    // tw
    OpcodePattern::base(0xfc0007ff, 0x7c000008),
    // xor
    OpcodePattern::base(0xfc0007fe, 0x7c000278),
    // cntlzd
    OpcodePattern::extension(0xfc00fffe, 0x7c000074, Extension::Ppc64),
    // dcbzl
    OpcodePattern::extension(0xffe007ff, 0x7c2007ec, Extension::Ppc64),
    // divd
    OpcodePattern::extension(0xfc0003fe, 0x7c0003d2, Extension::Ppc64),
    // divdu
    OpcodePattern::extension(0xfc0003fe, 0x7c000392, Extension::Ppc64),
    // extsw
    OpcodePattern::extension(0xfc00fffe, 0x7c0007b4, Extension::Ppc64),
    // ldarx
    OpcodePattern::extension(0xfc0007ff, 0x7c0000a8, Extension::Ppc64),
    // ldux
    OpcodePattern::extension(0xfc0007ff, 0x7c00006a, Extension::Ppc64),
    // ldx
    OpcodePattern::extension(0xfc0007ff, 0x7c00002a, Extension::Ppc64),
    // lwaux
    OpcodePattern::extension(0xfc0007ff, 0x7c0002ea, Extension::Ppc64),
    // lwax
    OpcodePattern::extension(0xfc0007ff, 0x7c0002aa, Extension::Ppc64),
    // mfocrf
    OpcodePattern::extension(0xfc100fff, 0x7c100026, Extension::Ppc64),
    // mtmsrd
    OpcodePattern::extension(0xfc1effff, 0x7c000164, Extension::Ppc64),
    // mtsrd
    OpcodePattern::extension(0xfc10ffff, 0x7c0000a4, Extension::Ppc64),
    // mtsrdin
    OpcodePattern::extension(0xfc1f07ff, 0x7c0000e4, Extension::Ppc64),
    // mulhd
    OpcodePattern::extension(0xfc0007fe, 0x7c000092, Extension::Ppc64),
    // mulhdu
    OpcodePattern::extension(0xfc0007fe, 0x7c000012, Extension::Ppc64),
    // mulld
    OpcodePattern::extension(0xfc0003fe, 0x7c0001d2, Extension::Ppc64),
    // slbia
    OpcodePattern::extension(0xffffffff, 0x7c0003e4, Extension::Ppc64),
    // slbie
    OpcodePattern::extension(0xffff07ff, 0x7c000364, Extension::Ppc64),
    // sld
    OpcodePattern::extension(0xfc0007fe, 0x7c000036, Extension::Ppc64),
    // srad
    OpcodePattern::extension(0xfc0007fe, 0x7c000634, Extension::Ppc64),
    // sradi
    OpcodePattern::extension(0xfc0007fc, 0x7c000674, Extension::Ppc64),
    // srd
    OpcodePattern::extension(0xfc0007fe, 0x7c000436, Extension::Ppc64),
    // stdcx.
    OpcodePattern::extension(0xfc0007ff, 0x7c0001ad, Extension::Ppc64),
    // stdux
    OpcodePattern::extension(0xfc0007ff, 0x7c00016a, Extension::Ppc64),
    // stdx
    OpcodePattern::extension(0xfc0007ff, 0x7c00012a, Extension::Ppc64),
    // td
    OpcodePattern::extension(0xfc0007ff, 0x7c000088, Extension::Ppc64),
    // dss
    OpcodePattern::extension(0xfd9fffff, 0x7c00066c, Extension::AltiVec),
    // dst
    OpcodePattern::extension(0xfd8007ff, 0x7c0002ac, Extension::AltiVec),
    // dstst
    OpcodePattern::extension(0xfd8007ff, 0x7c0002ec, Extension::AltiVec),
    // lvebx
    OpcodePattern::extension(0xfc0007ff, 0x7c00000e, Extension::AltiVec),
    // lvehx
    OpcodePattern::extension(0xfc0007ff, 0x7c00004e, Extension::AltiVec),
    // lvewx
    OpcodePattern::extension(0xfc0007ff, 0x7c00008e, Extension::AltiVec),
    // lvlx
    OpcodePattern::extension(0xfc0007ff, 0x7c00040e, Extension::AltiVec),
    // lvlxl
    OpcodePattern::extension(0xfc0007ff, 0x7c00060e, Extension::AltiVec),
    // lvrx
    OpcodePattern::extension(0xfc0007ff, 0x7c00044e, Extension::AltiVec),
    // lvrxl
    OpcodePattern::extension(0xfc0007ff, 0x7c00064e, Extension::AltiVec),
    // lvsl
    OpcodePattern::extension(0xfc0007ff, 0x7c00000c, Extension::AltiVec),
    // lvsr
    OpcodePattern::extension(0xfc0007ff, 0x7c00004c, Extension::AltiVec),
    // lvx
    OpcodePattern::extension(0xfc0007ff, 0x7c0000ce, Extension::AltiVec),
    // lvxl
    OpcodePattern::extension(0xfc0007ff, 0x7c0002ce, Extension::AltiVec),
    // stvebx
    OpcodePattern::extension(0xfc0007ff, 0x7c00010e, Extension::AltiVec),
    // stvehx
    OpcodePattern::extension(0xfc0007ff, 0x7c00014e, Extension::AltiVec),
    // stvewx
    OpcodePattern::extension(0xfc0007ff, 0x7c00018e, Extension::AltiVec),
    // stvlx
    OpcodePattern::extension(0xfc0007ff, 0x7c00050e, Extension::AltiVec),
    // stvlxl
    OpcodePattern::extension(0xfc0007ff, 0x7c00070e, Extension::AltiVec),
    // stvrx
    OpcodePattern::extension(0xfc0007ff, 0x7c00054e, Extension::AltiVec),
    // stvrxl
    OpcodePattern::extension(0xfc0007ff, 0x7c00074e, Extension::AltiVec),
    // stvx
    OpcodePattern::extension(0xfc0007ff, 0x7c0001ce, Extension::AltiVec),
    // stvxl
    OpcodePattern::extension(0xfc0007ff, 0x7c0003ce, Extension::AltiVec),
    // lwz
    OpcodePattern::base(0xfc000000, 0x80000000),
    // lwzu
    OpcodePattern::base(0xfc000000, 0x84000000),
    // lbz
    OpcodePattern::base(0xfc000000, 0x88000000),
    // lbzu
    OpcodePattern::base(0xfc000000, 0x8c000000),
    // stw
    OpcodePattern::base(0xfc000000, 0x90000000),
    // stwu
    OpcodePattern::base(0xfc000000, 0x94000000),
    // stb
    OpcodePattern::base(0xfc000000, 0x98000000),
    // stbu
    OpcodePattern::base(0xfc000000, 0x9c000000),
    // lhz
    OpcodePattern::base(0xfc000000, 0xa0000000),
    // lhzu
    OpcodePattern::base(0xfc000000, 0xa4000000),
    // lha
    OpcodePattern::base(0xfc000000, 0xa8000000),
    // lhau
    OpcodePattern::base(0xfc000000, 0xac000000),
    // sth
    OpcodePattern::base(0xfc000000, 0xb0000000),
    // sthu
    OpcodePattern::base(0xfc000000, 0xb4000000),
    // lmw
    OpcodePattern::base(0xfc000000, 0xb8000000),
    // stmw
    OpcodePattern::base(0xfc000000, 0xbc000000),
    // lfs
    OpcodePattern::base(0xfc000000, 0xc0000000),
    // lfsu
    OpcodePattern::base(0xfc000000, 0xc4000000),
    // lfd
    OpcodePattern::base(0xfc000000, 0xc8000000),
    // lfdu
    OpcodePattern::base(0xfc000000, 0xcc000000),
    // stfs
    OpcodePattern::base(0xfc000000, 0xd0000000),
    // stfsu
    OpcodePattern::base(0xfc000000, 0xd4000000),
    // stfd
    OpcodePattern::base(0xfc000000, 0xd8000000),
    // stfdu
    OpcodePattern::base(0xfc000000, 0xdc000000),
    // psq_l
    OpcodePattern::extension(0xfc000000, 0xe0000000, Extension::PairedSingles),
    // psq_lu
    OpcodePattern::extension(0xfc000000, 0xe4000000, Extension::PairedSingles),
    // ld
    OpcodePattern::extension(0xfc000003, 0xe8000000, Extension::Ppc64),
    // ldu
    OpcodePattern::extension(0xfc000003, 0xe8000001, Extension::Ppc64),
    // lwa
    OpcodePattern::extension(0xfc000003, 0xe8000002, Extension::Ppc64),
    // fadds
    OpcodePattern::base(0xfc0007fe, 0xec00002a),
    // fdivs
    OpcodePattern::base(0xfc0007fe, 0xec000024),
    // fmadds
    OpcodePattern::base(0xfc00003e, 0xec00003a),
    // fmsubs
    OpcodePattern::base(0xfc00003e, 0xec000038),
    // fmuls
    OpcodePattern::base(0xfc00f83e, 0xec000032),
    // fnmadds
    OpcodePattern::base(0xfc00003e, 0xec00003e),
    // fnmsubs
    OpcodePattern::base(0xfc00003e, 0xec00003c),
    // fres
    OpcodePattern::base(0xfc1f07fe, 0xec000030),
    // fsubs
    OpcodePattern::base(0xfc0007fe, 0xec000028),
    // fsqrts
    OpcodePattern::extension(0xfc1f07fe, 0xec00002c, Extension::Ppc64),
    // psq_st
    OpcodePattern::extension(0xfc000000, 0xf0000000, Extension::PairedSingles),
    // psq_stu
    OpcodePattern::extension(0xfc000000, 0xf4000000, Extension::PairedSingles),
    // std
    OpcodePattern::extension(0xfc000003, 0xf8000000, Extension::Ppc64),
    // stdu
    OpcodePattern::extension(0xfc000003, 0xf8000001, Extension::Ppc64),
    // fabs
    OpcodePattern::base(0xfc1f07fe, 0xfc000210),
    // fadd
    OpcodePattern::base(0xfc0007fe, 0xfc00002a),
    // fcmpo
    OpcodePattern::base(0xfc6007ff, 0xfc000040),
    // fcmpu
    OpcodePattern::base(0xfc6007ff, 0xfc000000),
    // fctiw
    OpcodePattern::base(0xfc1f07fe, 0xfc00001c),
    // fctiwz
    OpcodePattern::base(0xfc1f07fe, 0xfc00001e),
    // fdiv
    OpcodePattern::base(0xfc0007fe, 0xfc000024),
    // fmadd
    OpcodePattern::base(0xfc00003e, 0xfc00003a),
    // fmr
    OpcodePattern::base(0xfc1f07fe, 0xfc000090),
    // fmsub
    OpcodePattern::base(0xfc00003e, 0xfc000038),
    // fmul
    OpcodePattern::base(0xfc00f83e, 0xfc000032),
    // fnabs
    OpcodePattern::base(0xfc1f07fe, 0xfc000110),
    // fneg
    OpcodePattern::base(0xfc1f07fe, 0xfc000050),
    // fnmadd
    OpcodePattern::base(0xfc00003e, 0xfc00003e),
    // fnmsub
    OpcodePattern::base(0xfc00003e, 0xfc00003c),
    // frsp
    OpcodePattern::base(0xfc1f07fe, 0xfc000018),
    // frsqrte
    OpcodePattern::base(0xfc1f07fe, 0xfc000034),
    // fsel
    OpcodePattern::base(0xfc00003e, 0xfc00002e),
    // fsub
    OpcodePattern::base(0xfc0007fe, 0xfc000028),
    // mcrfs
    OpcodePattern::base(0xfc63ffff, 0xfc000080),
    // mffs
    OpcodePattern::base(0xfc1ffffe, 0xfc00048e),
    // mtfsb0
    OpcodePattern::base(0xfc1ffffe, 0xfc00008c),
    // mtfsb1
    OpcodePattern::base(0xfc1ffffe, 0xfc00004c),
    // mtfsf
    OpcodePattern::base(0xfe0107fe, 0xfc00058e),
    // mtfsfi
    OpcodePattern::base(0xfc7f0ffe, 0xfc00010c),
    // fcfid
    OpcodePattern::extension(0xfc1f07fe, 0xfc00069c, Extension::Ppc64),
    // fctid
    OpcodePattern::extension(0xfc1f07fe, 0xfc00065c, Extension::Ppc64),
    // fctidz
    OpcodePattern::extension(0xfc1f07fe, 0xfc00065e, Extension::Ppc64),
    // fsqrt
    OpcodePattern::extension(0xfc1f07fe, 0xfc00002c, Extension::Ppc64),
];
/// The name of each opcode.
static OPCODE_NAMES: [&str; 511] = [
    "tdi",
    "twi",
    "dcbz_l",
    "psq_lux",
    "psq_lx",
    "psq_stux",
    "psq_stx",
    "ps_abs",
    "ps_add",
    "ps_cmpo0",
    "ps_cmpo1",
    "ps_cmpu0",
    "ps_cmpu1",
    "ps_div",
    "ps_madd",
    "ps_madds0",
    "ps_madds1",
    "ps_merge00",
    "ps_merge01",
    "ps_merge10",
    "ps_merge11",
    "ps_mr",
    "ps_msub",
    "ps_mul",
    "ps_muls0",
    "ps_muls1",
    "ps_nabs",
    "ps_neg",
    "ps_nmadd",
    "ps_nmsub",
    "ps_res",
    "ps_rsqrte",
    "ps_sel",
    "ps_sub",
    "ps_sum0",
    "ps_sum1",
    "mfvscr",
    "mtvscr",
    "vaddcuw",
    "vaddfp",
    "vaddsbs",
    "vaddshs",
    "vaddsws",
    "vaddubm",
    "vaddubs",
    "vadduhm",
    "vadduhs",
    "vadduwm",
    "vadduws",
    "vand",
    "vandc",
    "vavgsb",
    "vavgsh",
    "vavgsw",
    "vavgub",
    "vavguh",
    "vavguw",
    "vcfsx",
    "vcfux",
    "vcmpbfp",
    "vcmpeqfp",
    "vcmpequb",
    "vcmpequh",
    "vcmpequw",
    "vcmpgefp",
    "vcmpgtfp",
    "vcmpgtsb",
    "vcmpgtsh",
    "vcmpgtsw",
    "vcmpgtub",
    "vcmpgtuh",
    "vcmpgtuw",
    "vctsxs",
    "vctuxs",
    "vexptefp",
    "vlogefp",
    "vmaddfp",
    "vmaxfp",
    "vmaxsb",
    "vmaxsh",
    "vmaxsw",
    "vmaxub",
    "vmaxuh",
    "vmaxuw",
    "vmhaddshs",
    "vmhraddshs",
    "vminfp",
    "vminsb",
    "vminsh",
    "vminsw",
    "vminub",
    "vminuh",
    "vminuw",
    "vmladduhm",
    "vmrghb",
    "vmrghh",
    "vmrghw",
    "vmrglb",
    "vmrglh",
    "vmrglw",
    "vmsummbm",
    "vmsumshm",
    "vmsumshs",
    "vmsumubm",
    "vmsumuhm",
    "vmsumuhs",
    "vmulesb",
    "vmulesh",
    "vmuleub",
    "vmuleuh",
    "vmulosb",
    "vmulosh",
    "vmuloub",
    "vmulouh",
    "vnmsubfp",
    "vnor",
    "vor",
    "vperm",
    "vpkpx",
    "vpkshss",
    "vpkshus",
    "vpkswss",
    "vpkswus",
    "vpkuhum",
    "vpkuhus",
    "vpkuwum",
    "vpkuwus",
    "vrefp",
    "vrfim",
    "vrfin",
    "vrfip",
    "vrfiz",
    "vrlb",
    "vrlh",
    "vrlw",
    "vrsqrtefp",
    "vsel",
    "vsl",
    "vslb",
    "vsldoi",
    "vslh",
    "vslo",
    "vslw",
    "vspltb",
    "vsplth",
    "vspltisb",
    "vspltish",
    "vspltisw",
    "vspltw",
    "vsr",
    "vsrab",
    "vsrah",
    "vsraw",
    "vsrb",
    "vsrh",
    "vsro",
    "vsrw",
    "vsubcuw",
    "vsubfp",
    "vsubsbs",
    "vsubshs",
    "vsubsws",
    "vsububm",
    "vsububs",
    "vsubuhm",
    "vsubuhs",
    "vsubuwm",
    "vsubuws",
    "vsumsws",
    "vsum2sws",
    "vsum4sbs",
    "vsum4shs",
    "vsum4ubs",
    "vupkhpx",
    "vupkhsb",
    "vupkhsh",
    "vupklpx",
    "vupklsb",
    "vupklsh",
    "vxor",
    "lvewx128",
    "lvlx128",
    "lvlxl128",
    "lvrx128",
    "lvrxl128",
    "lvsl128",
    "lvsr128",
    "lvx128",
    "lvxl128",
    "stvewx128",
    "stvlx128",
    "stvlxl128",
    "stvrx128",
    "stvrxl128",
    "stvx128",
    "stvxl128",
    "vsldoi128",
    "vaddfp128",
    "vand128",
    "vandc128",
    "vmaddcfp128",
    "vmaddfp128",
    "vmsum3fp128",
    "vmsum4fp128",
    "vmulfp128",
    "vnmsubfp128",
    "vnor128",
    "vor128",
    "vperm128",
    "vpkshss128",
    "vpkshus128",
    "vpkswss128",
    "vpkswus128",
    "vpkuhum128",
    "vpkuhus128",
    "vpkuwum128",
    "vpkuwus128",
    "vsel128",
    "vslo128",
    "vsro128",
    "vsubfp128",
    "vxor128",
    "vctsxs128",
    "vctuxs128",
    "vcmpbfp128",
    "vcmpeqfp128",
    "vcmpequw128",
    "vcmpgefp128",
    "vcmpgtfp128",
    "vcfsx128",
    "vcfux128",
    "vexptefp128",
    "vlogefp128",
    "vmaxfp128",
    "vminfp128",
    "vmrghw128",
    "vmrglw128",
    "vpermwi128",
    "vpkd3d128",
    "vrefp128",
    "vrfim128",
    "vrfin128",
    "vrfip128",
    "vrfiz128",
    "vrlimi128",
    "vrlw128",
    "vrsqrtefp128",
    "vslw128",
    "vspltisw128",
    "vspltw128",
    "vsraw128",
    "vsrw128",
    "vupkd3d128",
    "vupkhsb128",
    "vupkhsh128",
    "vupklsb128",
    "vupklsh128",
    "mulli",
    "subfic",
    "cmpli",
    "cmpi",
    "addic",
    "addic.",
    "addi",
    "addis",
    "bc",
    "sc",
    "b",
    "bcctr",
    "bclr",
    "crand",
    "crandc",
    "creqv",
    "crnand",
    "crnor",
    "cror",
    "crorc",
    "crxor",
    "isync",
    "mcrf",
    "rfi",
    "rfid",
    "rlwimi",
    "rlwinm",
    "rlwnm",
    "ori",
    "oris",
    "xori",
    "xoris",
    "andi.",
    "andis.",
    "rldcl",
    "rldcr",
    "rldic",
    "rldicl",
    "rldicr",
    "rldimi",
    "add",
    "addc",
    "adde",
    "addme",
    "addze",
    "and",
    "andc",
    "cmp",
    "cmpl",
    "cntlzw",
    "dcbf",
    "dcbi",
    "dcbst",
    "dcbt",
    "dcbtst",
    "dcbz",
    "divw",
    "divwu",
    "eciwx",
    "ecowx",
    "eieio",
    "eqv",
    "extsb",
    "extsh",
    "icbi",
    "lbzux",
    "lbzx",
    "lfdux",
    "lfdx",
    "lfsux",
    "lfsx",
    "lhaux",
    "lhax",
    "lhbrx",
    "lhzux",
    "lhzx",
    "lswi",
    "lswx",
    "lwarx",
    "lwbrx",
    "lwzux",
    "lwzx",
    "mcrxr",
    "mfcr",
    "mfmsr",
    "mfspr",
    "mfsr",
    "mfsrin",
    "mftb",
    "mtcrf",
    "mtmsr",
    "mtspr",
    "mtsr",
    "mtsrin",
    "mulhw",
    "mulhwu",
    "mullw",
    "nand",
    "neg",
    "nor",
    "or",
    "orc",
    "slw",
    "sraw",
    "srawi",
    "srw",
    "stbux",
    "stbx",
    "stfdux",
    "stfdx",
    "stfiwx",
    "stfsux",
    "stfsx",
    "sthbrx",
    "sthux",
    "sthx",
    "stswi",
    "stswx",
    "stwbrx",
    "stwcx.",
    "stwux",
    "stwx",
    "subf",
    "subfc",
    "subfe",
    "subfme",
    "subfze",
    "sync",
    "tlbie",
    "tlbsync",
    "tw",
    "xor",
    "cntlzd",
    "dcbzl",
    "divd",
    "divdu",
    "extsw",
    "ldarx",
    "ldux",
    "ldx",
    "lwaux",
    "lwax",
    "mfocrf",
    "mtmsrd",
    "mtsrd",
    "mtsrdin",
    "mulhd",
    "mulhdu",
    "mulld",
    "slbia",
    "slbie",
    "sld",
    "srad",
    "sradi",
    "srd",
    "stdcx.",
    "stdux",
    "stdx",
    "td",
    "dss",
    "dst",
    "dstst",
    "lvebx",
    "lvehx",
    "lvewx",
    "lvlx",
    "lvlxl",
    "lvrx",
    "lvrxl",
    "lvsl",
    "lvsr",
    "lvx",
    "lvxl",
    "stvebx",
    "stvehx",
    "stvewx",
    "stvlx",
    "stvlxl",
    "stvrx",
    "stvrxl",
    "stvx",
    "stvxl",
    "lwz",
    "lwzu",
    "lbz",
    "lbzu",
    "stw",
    "stwu",
    "stb",
    "stbu",
    "lhz",
    "lhzu",
    "lha",
    "lhau",
    "sth",
    "sthu",
    "lmw",
    "stmw",
    "lfs",
    "lfsu",
    "lfd",
    "lfdu",
    "stfs",
    "stfsu",
    "stfd",
    "stfdu",
    "psq_l",
    "psq_lu",
    "ld",
    "ldu",
    "lwa",
    "fadds",
    "fdivs",
    "fmadds",
    "fmsubs",
    "fmuls",
    "fnmadds",
    "fnmsubs",
    "fres",
    "fsubs",
    "fsqrts",
    "psq_st",
    "psq_stu",
    "std",
    "stdu",
    "fabs",
    "fadd",
    "fcmpo",
    "fcmpu",
    "fctiw",
    "fctiwz",
    "fdiv",
    "fmadd",
    "fmr",
    "fmsub",
    "fmul",
    "fnabs",
    "fneg",
    "fnmadd",
    "fnmsub",
    "frsp",
    "frsqrte",
    "fsel",
    "fsub",
    "mcrfs",
    "mffs",
    "mtfsb0",
    "mtfsb1",
    "mtfsf",
    "mtfsfi",
    "fcfid",
    "fctid",
    "fctidz",
    "fsqrt",
];
#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]
#[repr(u16)]
#[non_exhaustive]
pub enum Opcode {
    /// An illegal or unknown opcode
    #[default]
    Illegal = u16::MAX,
    /// tdi: Trap Double Word Immediate
    Tdi = 0,
    /// twi: Trap Word Immediate
    Twi = 1,
    /// dcbz_l: Data Cache Block Set to Zero Locked
    DcbzL = 2,
    /// psq_lux: Paired Single Quantized Load with Update Indexed
    PsqLux = 3,
    /// psq_lx: Paired Single Quantized Load Indexed
    PsqLx = 4,
    /// psq_stux: Paired Single Quantized Store with Update Indexed
    PsqStux = 5,
    /// psq_stx: Paired Single Quantized Store Indexed
    PsqStx = 6,
    /// ps_abs: Paired Single Absolute Value
    PsAbs = 7,
    /// ps_add: Paired Single Add
    PsAdd = 8,
    /// ps_cmpo0: Paired Singles Compare Ordered High
    PsCmpo0 = 9,
    /// ps_cmpo1: Paired Singles Compare Ordered Low
    PsCmpo1 = 10,
    /// ps_cmpu0: Paired Singles Compare Unordered High
    PsCmpu0 = 11,
    /// ps_cmpu1: Paired Singles Compare Unordered Low
    PsCmpu1 = 12,
    /// ps_div: Paired Single Divide
    PsDiv = 13,
    /// ps_madd: Paired Single Multiply-Add
    PsMadd = 14,
    /// ps_madds0: Paired Single Multiply-Add Scalar high
    PsMadds0 = 15,
    /// ps_madds1: Paired Single Multiply-Add Scalar low
    PsMadds1 = 16,
    /// ps_merge00: Paired Single MERGE high
    PsMerge00 = 17,
    /// ps_merge01: Paired Single MERGE direct
    PsMerge01 = 18,
    /// ps_merge10: Paired Single MERGE swapped
    PsMerge10 = 19,
    /// ps_merge11: Paired Single MERGE low
    PsMerge11 = 20,
    /// ps_mr: Paired Single Move Register
    PsMr = 21,
    /// ps_msub: Paired Single Multiply-Subtract
    PsMsub = 22,
    /// ps_mul: Paired Single Multiply
    PsMul = 23,
    /// ps_muls0: Paired Single Multiply Scalar high
    PsMuls0 = 24,
    /// ps_muls1: Paired Single Multiply Scalar low
    PsMuls1 = 25,
    /// ps_nabs: Paired Single Negative Absolute Value
    PsNabs = 26,
    /// ps_neg: Paired Single Negate
    PsNeg = 27,
    /// ps_nmadd: Paired Single Negative Multiply-Add
    PsNmadd = 28,
    /// ps_nmsub: Paired Single Negative Multiply-Subtract
    PsNmsub = 29,
    /// ps_res: Paired Single Reciprocal Estimate
    PsRes = 30,
    /// ps_rsqrte: Paired Single Reciprocal Square Root Estimate
    PsRsqrte = 31,
    /// ps_sel: Paired Single Select
    PsSel = 32,
    /// ps_sub: Paired Single Subtract
    PsSub = 33,
    /// ps_sum0: Paired Single vector SUM high
    PsSum0 = 34,
    /// ps_sum1: Paired Single vector SUM low
    PsSum1 = 35,
    /// mfvscr: Move from Vector Status and Control Register
    Mfvscr = 36,
    /// mtvscr: Move to Vector Status and Control Register
    Mtvscr = 37,
    /// vaddcuw: Vector Add Carryout Unsigned Word
    Vaddcuw = 38,
    /// vaddfp: Vector Add Floating Point
    Vaddfp = 39,
    /// vaddsbs: Vector Add Signed Byte Saturate
    Vaddsbs = 40,
    /// vaddshs: Vector Add Signed Half Word Saturate
    Vaddshs = 41,
    /// vaddsws: Vector Add Signed Word Saturate
    Vaddsws = 42,
    /// vaddubm: Vector Add Unsigned Byte Modulo
    Vaddubm = 43,
    /// vaddubs: Vector Add Unsigned Byte Saturate
    Vaddubs = 44,
    /// vadduhm: Vector Add Unsigned Half Word Modulo
    Vadduhm = 45,
    /// vadduhs: Vector Add Unsigned Half Word Saturate
    Vadduhs = 46,
    /// vadduwm: Vector Add Unsigned Word Modulo
    Vadduwm = 47,
    /// vadduws: Vector Add Unsigned Word Saturate
    Vadduws = 48,
    /// vand: Vector Logical AND
    Vand = 49,
    /// vandc: Vector Logical AND with Complement
    Vandc = 50,
    /// vavgsb: Vector Average Signed Byte
    Vavgsb = 51,
    /// vavgsh: Vector Average Signed Half Word
    Vavgsh = 52,
    /// vavgsw: Vector Average Signed Word
    Vavgsw = 53,
    /// vavgub: Vector Average Unsigned Byte
    Vavgub = 54,
    /// vavguh: Vector Average Unsigned Half Word
    Vavguh = 55,
    /// vavguw: Vector Average Unsigned Word
    Vavguw = 56,
    /// vcfsx: Vector Convert from Signed Fixed-Point Word
    Vcfsx = 57,
    /// vcfux: Vector Convert from Unsigned Fixed-Point Word
    Vcfux = 58,
    /// vcmpbfp: Vector Compare Bounds Floating Point
    Vcmpbfp = 59,
    /// vcmpeqfp: Vector Compare Equal-to-Floating Point
    Vcmpeqfp = 60,
    /// vcmpequb: Vector Compare Equal-to Unsigned Byte
    Vcmpequb = 61,
    /// vcmpequh: Vector Compare Equal-to Unsigned Half Word
    Vcmpequh = 62,
    /// vcmpequw: Vector Compare Equal-to Unsigned Word
    Vcmpequw = 63,
    /// vcmpgefp: Vector Compare Greater-Than-or-Equal-to Floating Point
    Vcmpgefp = 64,
    /// vcmpgtfp: Vector Compare Greater-Than Floating Point
    Vcmpgtfp = 65,
    /// vcmpgtsb: Vector Compare Greater-Than Signed Byte
    Vcmpgtsb = 66,
    /// vcmpgtsh: Vector Compare Greater-Than Condition Register Signed Half Word
    Vcmpgtsh = 67,
    /// vcmpgtsw: Vector Compare Greater-Than Signed Word
    Vcmpgtsw = 68,
    /// vcmpgtub: Vector Compare Greater-Than Unsigned Byte
    Vcmpgtub = 69,
    /// vcmpgtuh: Vector Compare Greater-Than Unsigned Half Word
    Vcmpgtuh = 70,
    /// vcmpgtuw: Vector Compare Greater-Than Unsigned Word
    Vcmpgtuw = 71,
    /// vctsxs: Vector Convert to Signed Fixed-Point Word Saturate
    Vctsxs = 72,
    /// vctuxs: Vector Convert to Unsigned Fixed-Point Word Saturate
    Vctuxs = 73,
    /// vexptefp: Vector 2 Raised to the Exponent Estimate Floating Point
    Vexptefp = 74,
    /// vlogefp: Vector Log2 Estimate Floating Point
    Vlogefp = 75,
    /// vmaddfp: Vector Multiply Add Floating Point
    Vmaddfp = 76,
    /// vmaxfp: Vector Maximum Floating Point
    Vmaxfp = 77,
    /// vmaxsb: Vector Maximum Signed Byte
    Vmaxsb = 78,
    /// vmaxsh: Vector Maximum Signed Half Word
    Vmaxsh = 79,
    /// vmaxsw: Vector Maximum Signed Word
    Vmaxsw = 80,
    /// vmaxub: Vector Maximum Unsigned Byte
    Vmaxub = 81,
    /// vmaxuh: Vector Maximum Unsigned Half Word
    Vmaxuh = 82,
    /// vmaxuw: Vector Maximum Unsigned Word
    Vmaxuw = 83,
    /// vmhaddshs: Vector Multiply High and Add Signed Half Word Saturate
    Vmhaddshs = 84,
    /// vmhraddshs: Vector Multiply High Round and Add Signed Half Word Saturate
    Vmhraddshs = 85,
    /// vminfp: Vector Minimum Floating Point
    Vminfp = 86,
    /// vminsb: Vector Minimum Signed Byte
    Vminsb = 87,
    /// vminsh: Vector Minimum Signed Half Word
    Vminsh = 88,
    /// vminsw: Vector Minimum Signed Word
    Vminsw = 89,
    /// vminub: Vector Minimum Unsigned Byte
    Vminub = 90,
    /// vminuh: Vector Minimum Unsigned Half Word
    Vminuh = 91,
    /// vminuw: Vector Minimum Unsigned Word
    Vminuw = 92,
    /// vmladduhm: Vector Multiply Low and Add Unsigned Half Word Modulo
    Vmladduhm = 93,
    /// vmrghb: Vector Merge High Byte
    Vmrghb = 94,
    /// vmrghh: Vector Merge High Half Word
    Vmrghh = 95,
    /// vmrghw: Vector Merge High Word
    Vmrghw = 96,
    /// vmrglb: Vector Merge Low Byte
    Vmrglb = 97,
    /// vmrglh: Vector Merge Low Half Word
    Vmrglh = 98,
    /// vmrglw: Vector Merge Low Word
    Vmrglw = 99,
    /// vmsummbm: Vector Multiply Sum Mixed-Sign Byte Modulo
    Vmsummbm = 100,
    /// vmsumshm: Vector Multiply Sum Signed Half Word Modulo
    Vmsumshm = 101,
    /// vmsumshs: Vector Multiply Sum Signed Half Word Saturate
    Vmsumshs = 102,
    /// vmsumubm: Vector Multiply Sum Unsigned Byte Modulo
    Vmsumubm = 103,
    /// vmsumuhm: Vector Multiply Sum Unsigned Half Word Modulo
    Vmsumuhm = 104,
    /// vmsumuhs: Vector Multiply Sum Unsigned Half Word Saturate
    Vmsumuhs = 105,
    /// vmulesb: Vector Multiply Even Signed Byte
    Vmulesb = 106,
    /// vmulesh: Vector Multiply Even Signed Half Word
    Vmulesh = 107,
    /// vmuleub: Vector Multiply Even Unsigned Byte
    Vmuleub = 108,
    /// vmuleuh: Vector Multiply Even Unsigned Half Word
    Vmuleuh = 109,
    /// vmulosb: Vector Multiply Odd Signed Byte
    Vmulosb = 110,
    /// vmulosh: Vector Multiply Odd Signed Half Word
    Vmulosh = 111,
    /// vmuloub: Vector Multiply Odd Unsigned Byte
    Vmuloub = 112,
    /// vmulouh: Vector Multiply Odd Unsigned Half Word
    Vmulouh = 113,
    /// vnmsubfp: Vector Negative Multiply-Subtract Floating Point
    Vnmsubfp = 114,
    /// vnor: Vector Logical NOR
    Vnor = 115,
    /// vor: Vector Logical OR
    Vor = 116,
    /// vperm: Vector Permute
    Vperm = 117,
    /// vpkpx: Vector Pack Pixel32
    Vpkpx = 118,
    /// vpkshss: Vector Pack Signed Half Word Signed Saturate
    Vpkshss = 119,
    /// vpkshus: Vector Pack Signed Half Word Unsigned Saturate
    Vpkshus = 120,
    /// vpkswss: Vector Pack Signed Word Signed Saturate
    Vpkswss = 121,
    /// vpkswus: Vector Pack Signed Word Unsigned Saturate
    Vpkswus = 122,
    /// vpkuhum: Vector Pack Unsigned Half Word Unsigned Modulo
    Vpkuhum = 123,
    /// vpkuhus: Vector Pack Unsigned Half Word Unsigned Saturate
    Vpkuhus = 124,
    /// vpkuwum: Vector Pack Unsigned Word Unsigned Modulo
    Vpkuwum = 125,
    /// vpkuwus: Vector Pack Unsigned Word Unsigned Saturate
    Vpkuwus = 126,
    /// vrefp: Vector Reciprocal Estimate Floating Point
    Vrefp = 127,
    /// vrfim: Vector Round to Floating-Point Integer toward Minus Infinity
    Vrfim = 128,
    /// vrfin: Vector Round to Floating-Point Integer Nearest
    Vrfin = 129,
    /// vrfip: Vector Round to Floating-Point Integer toward Plus Infinity
    Vrfip = 130,
    /// vrfiz: Vector Round to Floating-Point Integer toward Zero
    Vrfiz = 131,
    /// vrlb: Vector Rotate Left Integer Byte
    Vrlb = 132,
    /// vrlh: Vector Rotate Left Integer Half Word
    Vrlh = 133,
    /// vrlw: Vector Rotate Left Integer Word
    Vrlw = 134,
    /// vrsqrtefp: Vector Reciprocal Square Root Estimate Floating Point
    Vrsqrtefp = 135,
    /// vsel: Vector Conditional Select
    Vsel = 136,
    /// vsl: Vector Shift Left
    Vsl = 137,
    /// vslb: Vector Shift Left Integer Byte
    Vslb = 138,
    /// vsldoi: Vector Shift Left Double by Octet Immediate
    Vsldoi = 139,
    /// vslh: Vector Shift Left Integer Half Word
    Vslh = 140,
    /// vslo: Vector Shift Left by Octet
    Vslo = 141,
    /// vslw: Vector Shift Left Integer Word
    Vslw = 142,
    /// vspltb: Vector Splat Byte
    Vspltb = 143,
    /// vsplth: Vector Splat Half Word
    Vsplth = 144,
    /// vspltisb: Vector Splat Immediate Signed Byte
    Vspltisb = 145,
    /// vspltish: Vector Splat Immediate Signed Half Word
    Vspltish = 146,
    /// vspltisw: Vector Splat Immediate Signed Word
    Vspltisw = 147,
    /// vspltw: Vector Splat Word
    Vspltw = 148,
    /// vsr: Vector Shift Right
    Vsr = 149,
    /// vsrab: Vector Shift Right Algebraic Byte
    Vsrab = 150,
    /// vsrah: Vector Shift Right Algebraic Half Word
    Vsrah = 151,
    /// vsraw: Vector Shift Right Algebraic Word
    Vsraw = 152,
    /// vsrb: Vector Shift Right Byte
    Vsrb = 153,
    /// vsrh: Vector Shift Right Half Word
    Vsrh = 154,
    /// vsro: Vector Shift Right by Octet
    Vsro = 155,
    /// vsrw: Vector Shift Right Word
    Vsrw = 156,
    /// vsubcuw: Vector Subtract Carryout Unsigned Word
    Vsubcuw = 157,
    /// vsubfp: Vector Subtract Floating Point
    Vsubfp = 158,
    /// vsubsbs: Vector Subtract Signed Byte Saturate
    Vsubsbs = 159,
    /// vsubshs: Vector Subtract Signed Half Word Saturate
    Vsubshs = 160,
    /// vsubsws: Vector Subtract Signed Word Saturate
    Vsubsws = 161,
    /// vsububm: Vector Subtract Unsigned Byte Modulo
    Vsububm = 162,
    /// vsububs: Vector Subtract Unsigned Byte Saturate
    Vsububs = 163,
    /// vsubuhm: Vector Subtract Unsigned Half Word Modulo
    Vsubuhm = 164,
    /// vsubuhs: Vector Subtract Unsigned Half Word Saturate
    Vsubuhs = 165,
    /// vsubuwm: Vector Subtract Unsigned Word Modulo
    Vsubuwm = 166,
    /// vsubuws: Vector Subtract Unsigned Word Saturate
    Vsubuws = 167,
    /// vsumsws: Vector Sum Across Signed Word Saturate
    Vsumsws = 168,
    /// vsum2sws: Vector Sum Across Partial (1/2) Signed Word Saturate
    Vsum2sws = 169,
    /// vsum4sbs: Vector Sum Across Partial (1/4) Signed Byte Saturate
    Vsum4sbs = 170,
    /// vsum4shs: Vector Sum Across Partial (1/4) Signed Half Word Saturate
    Vsum4shs = 171,
    /// vsum4ubs: Vector Sum Across Partial (1/4) Unsigned Byte Saturate
    Vsum4ubs = 172,
    /// vupkhpx: Vector Unpack High Pixel16
    Vupkhpx = 173,
    /// vupkhsb: Vector Unpack High Signed Byte
    Vupkhsb = 174,
    /// vupkhsh: Vector Unpack High Signed Half Word
    Vupkhsh = 175,
    /// vupklpx: Vector Unpack Low Pixel16
    Vupklpx = 176,
    /// vupklsb: Vector Unpack Low Signed Byte
    Vupklsb = 177,
    /// vupklsh: Vector Unpack Low Signed Half Word
    Vupklsh = 178,
    /// vxor: Vector Logical XOR
    Vxor = 179,
    /// lvewx128: Load Vector128 Element Word Indexed
    Lvewx128 = 180,
    /// lvlx128: Load Vector128 Left Indexed
    Lvlx128 = 181,
    /// lvlxl128: Load Vector128 Left Indexed LRU
    Lvlxl128 = 182,
    /// lvrx128: Load Vector128 Right Indexed
    Lvrx128 = 183,
    /// lvrxl128: Load Vector128 Right Indexed LRU
    Lvrxl128 = 184,
    /// lvsl128: Load Vector128 for Shift Left
    Lvsl128 = 185,
    /// lvsr128: Load Vector128 for Shift Right
    Lvsr128 = 186,
    /// lvx128: Load Vector128 Indexed
    Lvx128 = 187,
    /// lvxl128: Load Vector128 Indexed LRU
    Lvxl128 = 188,
    /// stvewx128: Store Vector128 Element Word Indexed
    Stvewx128 = 189,
    /// stvlx128: Store Vector128 Left Indexed
    Stvlx128 = 190,
    /// stvlxl128: Store Vector128 Left Indexed LRU
    Stvlxl128 = 191,
    /// stvrx128: Store Vector128 Right Indexed
    Stvrx128 = 192,
    /// stvrxl128: Store Vector128 Right Indexed LRU
    Stvrxl128 = 193,
    /// stvx128: Store Vector128 Indexed
    Stvx128 = 194,
    /// stvxl128: Store Vector128 Indexed LRU
    Stvxl128 = 195,
    /// vsldoi128: Vector128 Shift Left Double by Octet Immediate
    Vsldoi128 = 196,
    /// vaddfp128: Vector128 Add Floating Point
    Vaddfp128 = 197,
    /// vand128: Vector128 Logical AND
    Vand128 = 198,
    /// vandc128: Vector128 Logical AND with Complement
    Vandc128 = 199,
    /// vmaddcfp128: Vector128 Multiply Add Carryout Floating Point
    Vmaddcfp128 = 200,
    /// vmaddfp128: Vector128 Multiply Add Floating Point
    Vmaddfp128 = 201,
    /// vmsum3fp128: Vector128 Multiply Sum 3-way Floating Point
    Vmsum3fp128 = 202,
    /// vmsum4fp128: Vector128 Multiply Sum 4-way Floating Point
    Vmsum4fp128 = 203,
    /// vmulfp128: Vector128 Multiply Floating-Point
    Vmulfp128 = 204,
    /// vnmsubfp128: Vector128 Negative Multiply-Subtract Floating Point
    Vnmsubfp128 = 205,
    /// vnor128: Vector128 Logical NOR
    Vnor128 = 206,
    /// vor128: Vector128 Logical OR
    Vor128 = 207,
    /// vperm128: Vector128 Permutation
    Vperm128 = 208,
    /// vpkshss128: Vector128 Pack Signed Half Word Signed Saturate
    Vpkshss128 = 209,
    /// vpkshus128: Vector128 Pack Signed Half Word Unsigned Saturate
    Vpkshus128 = 210,
    /// vpkswss128: Vector128 Pack Signed Word Signed Saturate
    Vpkswss128 = 211,
    /// vpkswus128: Vector128 Pack Signed Word Unsigned Saturate
    Vpkswus128 = 212,
    /// vpkuhum128: Vector128 Pack Unsigned Half Word Unsigned Modulo
    Vpkuhum128 = 213,
    /// vpkuhus128: Vector128 Pack Unsigned Half Word Unsigned Saturate
    Vpkuhus128 = 214,
    /// vpkuwum128: Vector128 Pack Unsigned Word Unsigned Modulo
    Vpkuwum128 = 215,
    /// vpkuwus128: Vector128 Pack Unsigned Word Unsigned Saturate
    Vpkuwus128 = 216,
    /// vsel128: Vector128 Select
    Vsel128 = 217,
    /// vslo128: Vector128 Shift Left Octet
    Vslo128 = 218,
    /// vsro128: Vector128 Shift Right Octet
    Vsro128 = 219,
    /// vsubfp128: Vector128 Subtract Floating Point
    Vsubfp128 = 220,
    /// vxor128: Vector128 Logical XOR
    Vxor128 = 221,
    /// vctsxs128: Vector128 Convert to Signed Fixed-Point Word Saturate
    Vctsxs128 = 222,
    /// vctuxs128: Vector128 Convert to Unsigned Fixed-Point Word Saturate
    Vctuxs128 = 223,
    /// vcmpbfp128: Vector128 Compare Bounds Floating Point
    Vcmpbfp128 = 224,
    /// vcmpeqfp128: Vector128 Compare Equal-to Floating Point
    Vcmpeqfp128 = 225,
    /// vcmpequw128: Vector128 Compare Equal-to Unsigned Word
    Vcmpequw128 = 226,
    /// vcmpgefp128: Vector128 Compare Greater-Than-or-Equal-to Floating Point
    Vcmpgefp128 = 227,
    /// vcmpgtfp128: Vector128 Compare Greater-Than Floating-Point
    Vcmpgtfp128 = 228,
    /// vcfsx128: Vector128 Convert From Signed Fixed-Point Word
    Vcfsx128 = 229,
    /// vcfux128: Vector128 Convert From Unsigned Fixed-Point Word
    Vcfux128 = 230,
    /// vexptefp128: Vector128 2 Raised to the Exponent Estimate Floating Point
    Vexptefp128 = 231,
    /// vlogefp128: Vector128 Log2 Estimate Floating Point
    Vlogefp128 = 232,
    /// vmaxfp128: Vector128 Maximum Floating Point
    Vmaxfp128 = 233,
    /// vminfp128: Vector128 Minimum Floating Point
    Vminfp128 = 234,
    /// vmrghw128: Vector128 Merge High Word
    Vmrghw128 = 235,
    /// vmrglw128: Vector128 Merge Low Word
    Vmrglw128 = 236,
    /// vpermwi128: Vector128 Permutate Word Immediate
    Vpermwi128 = 237,
    /// vpkd3d128: Vector128 Pack D3Dtype, Rotate Left Immediate and Mask Insert
    Vpkd3d128 = 238,
    /// vrefp128: Vector128 Reciprocal Estimate Floating Point
    Vrefp128 = 239,
    /// vrfim128: Vector128 Round to Floating-Point Integer toward Minus Infinity
    Vrfim128 = 240,
    /// vrfin128: Vector128 Round to Floating-Point Integer toward Nearest
    Vrfin128 = 241,
    /// vrfip128: Vector128 Round to Floating-Point Integer toward Plus Infinity
    Vrfip128 = 242,
    /// vrfiz128: Vector128 Round to Floating-Point Integer toward Zero
    Vrfiz128 = 243,
    /// vrlimi128: Vector128 Rotate Left Immediate and Mask Insert
    Vrlimi128 = 244,
    /// vrlw128: Vector128 Rotate Left Word
    Vrlw128 = 245,
    /// vrsqrtefp128: Vector128 Reciprocal Square Root Estimate Floating Point
    Vrsqrtefp128 = 246,
    /// vslw128: Vector128 Shift Left Word
    Vslw128 = 247,
    /// vspltisw128: Vector128 Splat Immediate Signed Word
    Vspltisw128 = 248,
    /// vspltw128: Vector128 Splat Word
    Vspltw128 = 249,
    /// vsraw128: Vector128 Shift Right Arithmetic Word
    Vsraw128 = 250,
    /// vsrw128: Vector128 Shift Right Word
    Vsrw128 = 251,
    /// vupkd3d128: Vector128 Unpack D3Dtype
    Vupkd3d128 = 252,
    /// vupkhsb128: Vector128 Unpack High Signed Byte
    Vupkhsb128 = 253,
    /// vupkhsh128: Vector128 Unpack High Signed Half Word
    Vupkhsh128 = 254,
    /// vupklsb128: Vector128 Unpack Low Signed Byte
    Vupklsb128 = 255,
    /// vupklsh128: Vector128 Unpack Low Signed Half Word
    Vupklsh128 = 256,
    /// mulli: Multiply Low Immediate
    Mulli = 257,
    /// subfic: Subtract from Immediate Carrying
    Subfic = 258,
    /// cmpli: Compare Logical Immediate
    Cmpli = 259,
    /// cmpi: Compare Immediate
    Cmpi = 260,
    /// addic: Add Immediate Carrying
    Addic = 261,
    /// addic.: Add Immediate Carrying and Record
    Addic_ = 262,
    /// addi: Add Immediate
    Addi = 263,
    /// addis: Add Immediate Shifted
    Addis = 264,
    /// bc: Branch Conditional
    Bc = 265,
    /// sc: System Call
    Sc = 266,
    /// b: Branch
    B = 267,
    /// bcctr: Branch Conditional to Count Register
    Bcctr = 268,
    /// bclr: Branch Conditional to Link Register
    Bclr = 269,
    /// crand: Condition Register AND
    Crand = 270,
    /// crandc: Condition Register AND with Complement
    Crandc = 271,
    /// creqv: Condition Register Equivalent
    Creqv = 272,
    /// crnand: Condition Register NAND
    Crnand = 273,
    /// crnor: Condition Register NOR
    Crnor = 274,
    /// cror: Condition Register OR
    Cror = 275,
    /// crorc: Condition Register OR with Complement
    Crorc = 276,
    /// crxor: Condition Register XOR
    Crxor = 277,
    /// isync: Instruction Synchronize
    Isync = 278,
    /// mcrf: Move Condition Register Field
    Mcrf = 279,
    /// rfi: Return from Interrupt
    Rfi = 280,
    /// rfid: Return from Interrupt Double Word
    Rfid = 281,
    /// rlwimi: Rotate Left Word Immediate then Mask Insert
    Rlwimi = 282,
    /// rlwinm: Rotate Left Word Immediate then AND with Mask
    Rlwinm = 283,
    /// rlwnm: Rotate Left Word then AND with Mask
    Rlwnm = 284,
    /// ori: OR Immediate
    Ori = 285,
    /// oris: OR Immediate Shifted
    Oris = 286,
    /// xori: XOR Immediate
    Xori = 287,
    /// xoris: XOR Immediate Shifted
    Xoris = 288,
    /// andi.: AND Immediate
    Andi_ = 289,
    /// andis.: AND Immediate Shifted
    Andis_ = 290,
    /// rldcl: Rotate Left Double Word then Clear Left
    Rldcl = 291,
    /// rldcr: Rotate Left Double Word then Clear Right
    Rldcr = 292,
    /// rldic: Rotate Left Double Word Immediate then Clear
    Rldic = 293,
    /// rldicl: Rotate Left Double Word Immediate then Clear Left
    Rldicl = 294,
    /// rldicr: Rotate Left Double Word Immediate then Clear Right
    Rldicr = 295,
    /// rldimi: Rotate Left Double Word Immediate then Mask Insert
    Rldimi = 296,
    /// add: Add
    Add = 297,
    /// addc: Add Carrying
    Addc = 298,
    /// adde: Add Extended
    Adde = 299,
    /// addme: Add to Minus One Extended
    Addme = 300,
    /// addze: Add to Zero Extended
    Addze = 301,
    /// and: AND
    And = 302,
    /// andc: AND with Complement
    Andc = 303,
    /// cmp: Compare
    Cmp = 304,
    /// cmpl: Compare Logical
    Cmpl = 305,
    /// cntlzw: Count Leading Zeros Word
    Cntlzw = 306,
    /// dcbf: Data Cache Block Flush
    Dcbf = 307,
    /// dcbi: Data Cache Block Invalidate
    Dcbi = 308,
    /// dcbst: Data Cache Block Store
    Dcbst = 309,
    /// dcbt: Data Cache Block Touch
    Dcbt = 310,
    /// dcbtst: Data Cache Block Touch for Store
    Dcbtst = 311,
    /// dcbz: Data Cache Block Clear to Zero
    Dcbz = 312,
    /// divw: Divide Word
    Divw = 313,
    /// divwu: Divide Word Unsigned
    Divwu = 314,
    /// eciwx: External Control In Word Indexed
    Eciwx = 315,
    /// ecowx: External Control Out Word Indexed
    Ecowx = 316,
    /// eieio: Enforce In-Order Execution of I/O
    Eieio = 317,
    /// eqv: Equivalent
    Eqv = 318,
    /// extsb: Extend Sign Byte
    Extsb = 319,
    /// extsh: Extend Sign Half Word
    Extsh = 320,
    /// icbi: Instruction Cache Block Invalidate
    Icbi = 321,
    /// lbzux: Load Byte and Zero with Update Indexed
    Lbzux = 322,
    /// lbzx: Load Byte and Zero Indexed
    Lbzx = 323,
    /// lfdux: Load Floating-Point Double with Update Indexed
    Lfdux = 324,
    /// lfdx: Load Floating-Point Double Indexed
    Lfdx = 325,
    /// lfsux: Load Floating-Point Single with Update Indexed
    Lfsux = 326,
    /// lfsx: Load Floating-Point Single Indexed
    Lfsx = 327,
    /// lhaux: Load Half Word Algebraic with Update Indexed
    Lhaux = 328,
    /// lhax: Load Half Word Algebraic Indexed
    Lhax = 329,
    /// lhbrx: Load Half Word Byte-Reverse Indexed
    Lhbrx = 330,
    /// lhzux: Load Half Word and Zero with Update Indexed
    Lhzux = 331,
    /// lhzx: Load Half Word and Zero Indexed
    Lhzx = 332,
    /// lswi: Load String Word Immediate
    Lswi = 333,
    /// lswx: Load String Word Indexed
    Lswx = 334,
    /// lwarx: Load String Word and Reverse Indexed
    Lwarx = 335,
    /// lwbrx: Load String Word and Byte-Reverse Indexed
    Lwbrx = 336,
    /// lwzux: Load Word and Zero with Update Indexed
    Lwzux = 337,
    /// lwzx: Load Word and Zero Indexed
    Lwzx = 338,
    /// mcrxr: Move to Condition Register from XER
    Mcrxr = 339,
    /// mfcr: Move from Condition Register
    Mfcr = 340,
    /// mfmsr: Move from Machine State Register
    Mfmsr = 341,
    /// mfspr: Move from Special-Purpose Register
    Mfspr = 342,
    /// mfsr: Move from Segment Register
    Mfsr = 343,
    /// mfsrin: Move from Segment Register Indirect
    Mfsrin = 344,
    /// mftb: Move from Time Base
    Mftb = 345,
    /// mtcrf: Move to Condition Register Fields
    Mtcrf = 346,
    /// mtmsr: Move to Machine State Register
    Mtmsr = 347,
    /// mtspr: Move to Special-Purpose Register
    Mtspr = 348,
    /// mtsr: Move to Segment Register
    Mtsr = 349,
    /// mtsrin: Move to Segment Register Indirect
    Mtsrin = 350,
    /// mulhw: Multiply High Word
    Mulhw = 351,
    /// mulhwu: Multiply High Word Unsigned
    Mulhwu = 352,
    /// mullw: Multiply Low Word
    Mullw = 353,
    /// nand: NAND
    Nand = 354,
    /// neg: Negate
    Neg = 355,
    /// nor: NOR
    Nor = 356,
    /// or: OR
    Or = 357,
    /// orc: OR with Complement
    Orc = 358,
    /// slw: Shift Left Word
    Slw = 359,
    /// sraw: Shift Right Algebraic Word
    Sraw = 360,
    /// srawi: Shift Right Algebraic Word Immediate
    Srawi = 361,
    /// srw: Shift Right Word
    Srw = 362,
    /// stbux: Store Byte with Update Indexed
    Stbux = 363,
    /// stbx: Store Byte Indexed
    Stbx = 364,
    /// stfdux: Store Floating-Point Double with Update Indexed
    Stfdux = 365,
    /// stfdx: Store Floating-Point Double Indexed
    Stfdx = 366,
    /// stfiwx: Store Floating-Point as Integer Word Indexed
    Stfiwx = 367,
    /// stfsux: Store Floating-Point Single with Update Indexed
    Stfsux = 368,
    /// stfsx: Store Floating-Point Single Indexed
    Stfsx = 369,
    /// sthbrx: Store Half Word Byte-Reverse Indexed
    Sthbrx = 370,
    /// sthux: Store Half Word with Update Indexed
    Sthux = 371,
    /// sthx: Store Half Word Indexed
    Sthx = 372,
    /// stswi: Store String Word Immediate
    Stswi = 373,
    /// stswx: Store String Word Indexed
    Stswx = 374,
    /// stwbrx: Store Word Byte-Reverse Indexed
    Stwbrx = 375,
    /// stwcx.: Store Word Conditional Indexed
    Stwcx_ = 376,
    /// stwux: Store Word Indexed
    Stwux = 377,
    /// stwx: Store Word Indexed
    Stwx = 378,
    /// subf: Subtract From Carrying
    Subf = 379,
    /// subfc: Subtract from Carrying
    Subfc = 380,
    /// subfe: Subtract from Extended
    Subfe = 381,
    /// subfme: Subtract from Minus One Extended
    Subfme = 382,
    /// subfze: Subtract from Zero Extended
    Subfze = 383,
    /// sync: Synchronize
    Sync = 384,
    /// tlbie: Translation Lookaside Buffer Invalidate Entry
    Tlbie = 385,
    /// tlbsync: TLB Synchronize
    Tlbsync = 386,
    /// tw: Trap Word
    Tw = 387,
    /// xor: XOR
    Xor = 388,
    /// cntlzd: Count Leading Zeros Double Word
    Cntlzd = 389,
    /// dcbzl: Data Cache Block Clear to Zero (128 bytes)
    Dcbzl = 390,
    /// divd: Divide Double Word
    Divd = 391,
    /// divdu: Divide Double Word Unsigned
    Divdu = 392,
    /// extsw: Extend Sign Word
    Extsw = 393,
    /// ldarx: Load Double Word and Reserve Indexed
    Ldarx = 394,
    /// ldux: Load Double Word with Update Indexed
    Ldux = 395,
    /// ldx: Load Double Word Indexed
    Ldx = 396,
    /// lwaux: Load Word Algebraic with Update Indexed
    Lwaux = 397,
    /// lwax: Load Word Algebraic Indexed
    Lwax = 398,
    /// mfocrf: Move from One Condition Register Field
    Mfocrf = 399,
    /// mtmsrd: Move to Machine State Register Double Word
    Mtmsrd = 400,
    /// mtsrd: Move to Segment Register Double Word
    Mtsrd = 401,
    /// mtsrdin: Move to Segment Register Double Word Indirect
    Mtsrdin = 402,
    /// mulhd: Multiply High Double Word
    Mulhd = 403,
    /// mulhdu: Multiply High Double Word Unsigned
    Mulhdu = 404,
    /// mulld: Multiply Low Double Word
    Mulld = 405,
    /// slbia: SLB Invalidate All
    Slbia = 406,
    /// slbie: SLB Invalidate Entry
    Slbie = 407,
    /// sld: Shift Left Double Word
    Sld = 408,
    /// srad: Shift Right Algebraic Double Word
    Srad = 409,
    /// sradi: Shift Right Algebraic Double Word Immediate
    Sradi = 410,
    /// srd: Shift Right Double Word
    Srd = 411,
    /// stdcx.: Store Double Word Conditional Indexed
    Stdcx_ = 412,
    /// stdux: Store Double Word with Update Indexed
    Stdux = 413,
    /// stdx: Store Double Word Indexed
    Stdx = 414,
    /// td: Trap Double Word
    Td = 415,
    /// dss: Data Stream Stop
    Dss = 416,
    /// dst: Data Stream Touch
    Dst = 417,
    /// dstst: Data Stream Touch for Store
    Dstst = 418,
    /// lvebx: Load Vector Element Byte Indexed
    Lvebx = 419,
    /// lvehx: Load Vector Element Half Word Indexed
    Lvehx = 420,
    /// lvewx: Load Vector Element Word Indexed
    Lvewx = 421,
    /// lvlx: Load Vector Left Indexed
    Lvlx = 422,
    /// lvlxl: Load Vector Left Indexed Last
    Lvlxl = 423,
    /// lvrx: Load Vector Right Indexed
    Lvrx = 424,
    /// lvrxl: Load Vector Right Indexed Last
    Lvrxl = 425,
    /// lvsl: Load Vector for Shift Left
    Lvsl = 426,
    /// lvsr: Load Vector for Shift Right
    Lvsr = 427,
    /// lvx: Load Vector Indexed
    Lvx = 428,
    /// lvxl: Load Vector Indexed LRU
    Lvxl = 429,
    /// stvebx: Store Vector Element Byte Indexed
    Stvebx = 430,
    /// stvehx: Store Vector Element Half Word Indexed
    Stvehx = 431,
    /// stvewx: Store Vector Element Word Indexed
    Stvewx = 432,
    /// stvlx: Store Vector Left Indexed
    Stvlx = 433,
    /// stvlxl: Store Vector Left Indexed Last
    Stvlxl = 434,
    /// stvrx: Store Vector Right Indexed
    Stvrx = 435,
    /// stvrxl: Store Vector Right Indexed Last
    Stvrxl = 436,
    /// stvx: Store Vector Indexed
    Stvx = 437,
    /// stvxl: Store Vector Indexed LRU
    Stvxl = 438,
    /// lwz: Load Word and Zero
    Lwz = 439,
    /// lwzu: Load Word and Zero with Update
    Lwzu = 440,
    /// lbz: Load Byte and Zero
    Lbz = 441,
    /// lbzu: Load Byte and Zero with Update
    Lbzu = 442,
    /// stw: Store Word
    Stw = 443,
    /// stwu: Store Word with Update
    Stwu = 444,
    /// stb: Store Byte
    Stb = 445,
    /// stbu: Store Byte with Update
    Stbu = 446,
    /// lhz: Load Half Word and Zero
    Lhz = 447,
    /// lhzu: Load Half Word and Zero with Update
    Lhzu = 448,
    /// lha: Load Half Word Algebraic
    Lha = 449,
    /// lhau: Load Half Word Algebraic with Update
    Lhau = 450,
    /// sth: Store Half Word
    Sth = 451,
    /// sthu: Store Half Word with Update
    Sthu = 452,
    /// lmw: Load Multiple Word
    Lmw = 453,
    /// stmw: Store Multiple Word
    Stmw = 454,
    /// lfs: Load Floating-Point Single
    Lfs = 455,
    /// lfsu: Load Floating-Point Single with Update
    Lfsu = 456,
    /// lfd: Load Floating-Point Double
    Lfd = 457,
    /// lfdu: Load Floating-Point Double with Update
    Lfdu = 458,
    /// stfs: Store Floating-Point Single
    Stfs = 459,
    /// stfsu: Store Floating-Point Single with Update
    Stfsu = 460,
    /// stfd: Store Floating-Point Double
    Stfd = 461,
    /// stfdu: Store Floating-Point Double with Update
    Stfdu = 462,
    /// psq_l: Paired Single Quantized Load
    PsqL = 463,
    /// psq_lu: Paired Single Quantized Load with Update
    PsqLu = 464,
    /// ld: Load Double Word
    Ld = 465,
    /// ldu: Load Double Word with Update
    Ldu = 466,
    /// lwa: Load Word Algebraic
    Lwa = 467,
    /// fadds: Floating Add (Single-Precision)
    Fadds = 468,
    /// fdivs: Floating Divide (Single-Precision)
    Fdivs = 469,
    /// fmadds: Floating Multiply-Add (Single-Precision)
    Fmadds = 470,
    /// fmsubs: Floating Multiply-Subtract (Single-Precision)
    Fmsubs = 471,
    /// fmuls: Floating Multiply (Single-Precision)
    Fmuls = 472,
    /// fnmadds: Floating Negative Multiply-Add (Single-Precision)
    Fnmadds = 473,
    /// fnmsubs: Floating Negative Multiply-Subtract (Single-Precision)
    Fnmsubs = 474,
    /// fres: Floating Reciprocal Estimate Single
    Fres = 475,
    /// fsubs: Floating Subtract (Single-Precision)
    Fsubs = 476,
    /// fsqrts: Floating Square Root (Single-Precision)
    Fsqrts = 477,
    /// psq_st: Paired Single Quantized Store
    PsqSt = 478,
    /// psq_stu: Paired Single Quantized Store with Update
    PsqStu = 479,
    /// std: Store Double Word
    Std = 480,
    /// stdu: Store Double Word with Update
    Stdu = 481,
    /// fabs: Floating Absolute Value
    Fabs = 482,
    /// fadd: Floating Add (Double-Precision)
    Fadd = 483,
    /// fcmpo: Floating Compare Ordered
    Fcmpo = 484,
    /// fcmpu: Floating Compare Unordered
    Fcmpu = 485,
    /// fctiw: Floating Convert to Integer Word
    Fctiw = 486,
    /// fctiwz: Floating Convert to Integer Word with Round toward Zero
    Fctiwz = 487,
    /// fdiv: Floating Divide (Double-Precision)
    Fdiv = 488,
    /// fmadd: Floating Multiply-Add (Double-Precision)
    Fmadd = 489,
    /// fmr: Floating Move Register (Double-Precision)
    Fmr = 490,
    /// fmsub: Floating Multiply-Subtract (Double-Precision)
    Fmsub = 491,
    /// fmul: Floating Multiply (Double-Precision)
    Fmul = 492,
    /// fnabs: Floating Negative Absolute Value
    Fnabs = 493,
    /// fneg: Floating Negate
    Fneg = 494,
    /// fnmadd: Floating Negative Multiply-Add (Double-Precision)
    Fnmadd = 495,
    /// fnmsub: Floating Negative Multiply-Subtract (Double-Precision)
    Fnmsub = 496,
    /// frsp: Floating Round to Single
    Frsp = 497,
    /// frsqrte: Floating Reciprocal Square Root Estimate
    Frsqrte = 498,
    /// fsel: Floating Select
    Fsel = 499,
    /// fsub: Floating Subtract (Double-Precision)
    Fsub = 500,
    /// mcrfs: Move to Condition Register from FPSCR
    Mcrfs = 501,
    /// mffs: Move from FPSCR
    Mffs = 502,
    /// mtfsb0: Move to FPSCR Bit 0
    Mtfsb0 = 503,
    /// mtfsb1: Move to FPSCR Bit 1
    Mtfsb1 = 504,
    /// mtfsf: Move to FPSCR Fields
    Mtfsf = 505,
    /// mtfsfi: Move to FPSCR Field Immediate
    Mtfsfi = 506,
    /// fcfid: Floating Convert from Integer Double Word
    Fcfid = 507,
    /// fctid: Floating Convert to Integer Double Word
    Fctid = 508,
    /// fctidz: Floating Convert to Integer Double Word with Round toward Zero
    Fctidz = 509,
    /// fsqrt: Floating Square Root (Double-Precision)
    Fsqrt = 510,
}
impl Opcode {
    pub fn mnemonic(self) -> &'static str {
        OPCODE_NAMES.get(self as usize).copied().unwrap_or("<illegal>")
    }
    pub fn detect(code: u32, extensions: Extensions) -> Self {
        let entry = OPCODE_ENTRIES[(code >> 26) as usize];
        for i in entry.0..entry.1 {
            let op = OPCODE_PATTERNS[i as usize];
            if extensions.contains_all(op.extensions)
                && (code & op.bitmask) == op.pattern
            {
                // Safety: The enum is repr(u16) and the value is within the enum's range
                return unsafe { core::mem::transmute::<u16, Opcode>(i) };
            }
        }
        Self::Illegal
    }
}
impl From<u16> for Opcode {
    #[inline]
    fn from(value: u16) -> Self {
        if value > 510 {
            Self::Illegal
        } else {
            // Safety: The enum is repr(u16) and the value is within the enum's range
            unsafe { core::mem::transmute::<u16, Self>(value) }
        }
    }
}
impl From<Opcode> for u16 {
    #[inline]
    fn from(value: Opcode) -> Self {
        value as u16
    }
}
impl Ins {
    /// simm: Signed Immediate
    #[inline(always)]
    pub const fn field_simm(&self) -> i16 {
        (self.code & 0xffff) as i16
    }
    /// uimm: Unsigned Immediate
    #[inline(always)]
    pub const fn field_uimm(&self) -> u16 {
        (self.code & 0xffff) as u16
    }
    /// offset: Branch Offset
    #[inline(always)]
    pub const fn field_offset(&self) -> i16 {
        (self.code & 0xffff) as i16
    }
    /// BO: Branch Options
    #[inline(always)]
    pub const fn field_bo(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// BI: Branch Condition Register Bit
    #[inline(always)]
    pub const fn field_bi(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// BD: Branch Destination (14-bit)
    #[inline(always)]
    pub const fn field_bd(&self) -> i16 {
        (self.code & 0xfffc) as i16
    }
    /// LI: Branch Destination (24-bit)
    #[inline(always)]
    pub const fn field_li(&self) -> i32 {
        (((self.code & 0x3fffffc) << 6) as i32) >> 6
    }
    /// SH: Shift Amount
    #[inline(always)]
    pub const fn field_sh(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// MB: Mask Begin
    #[inline(always)]
    pub const fn field_mb(&self) -> u8 {
        ((self.code >> 6) & 0x1f) as u8
    }
    /// ME: Mask End
    #[inline(always)]
    pub const fn field_me(&self) -> u8 {
        ((self.code >> 1) & 0x1f) as u8
    }
    /// rS: Source Register
    #[inline(always)]
    pub const fn field_rs(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// rD: Destination Register
    #[inline(always)]
    pub const fn field_rd(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// rA: Register A
    #[inline(always)]
    pub const fn field_ra(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// rB: Register B
    #[inline(always)]
    pub const fn field_rb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// sr: Segment Register
    #[inline(always)]
    pub const fn field_sr(&self) -> u8 {
        ((self.code >> 16) & 0xf) as u8
    }
    /// spr: Special Purpose Register
    #[inline(always)]
    pub const fn field_spr(&self) -> u16 {
        (((self.code >> 16) & 0x1f) | ((self.code >> 6) & 0x3e0)) as u16
    }
    /// frS: Source Floating-Point Register
    #[inline(always)]
    pub const fn field_frs(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// frD: Destination Floating-Point Register
    #[inline(always)]
    pub const fn field_frd(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// frA: Floating-Point Register A
    #[inline(always)]
    pub const fn field_fra(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// frB: Floating-Point Register B
    #[inline(always)]
    pub const fn field_frb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// frC: Floating-Point Register C
    #[inline(always)]
    pub const fn field_frc(&self) -> u8 {
        ((self.code >> 6) & 0x1f) as u8
    }
    /// crbD: Condition Register Bit Destination
    #[inline(always)]
    pub const fn field_crbd(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// crbA: Condition Register Bit A
    #[inline(always)]
    pub const fn field_crba(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// crbB: Condition Register Bit B
    #[inline(always)]
    pub const fn field_crbb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// crfD: Condition Register Field Destination
    #[inline(always)]
    pub const fn field_crfd(&self) -> u8 {
        ((self.code >> 23) & 0x7) as u8
    }
    /// crfS: Condition Register Field Source
    #[inline(always)]
    pub const fn field_crfs(&self) -> u8 {
        ((self.code >> 18) & 0x7) as u8
    }
    /// crm: Condition Register Mask
    #[inline(always)]
    pub const fn field_crm(&self) -> u8 {
        ((self.code >> 12) & 0xff) as u8
    }
    /// NB
    #[inline(always)]
    pub const fn field_nb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// tbr: Time Base
    #[inline(always)]
    pub const fn field_tbr(&self) -> u16 {
        (((self.code >> 16) & 0x1f) | ((self.code >> 6) & 0x3e0)) as u16
    }
    /// mtfsf_FM: Field Mask for mtfsf
    #[inline(always)]
    pub const fn field_mtfsf_fm(&self) -> u8 {
        ((self.code >> 17) & 0xff) as u8
    }
    /// mtfsf_IMM: Immediate for mtfsfi
    #[inline(always)]
    pub const fn field_mtfsf_imm(&self) -> u8 {
        ((self.code >> 12) & 0xf) as u8
    }
    /// spr_SPRG: SPRG index for m[tf]sprg
    #[inline(always)]
    pub const fn field_spr_sprg(&self) -> u8 {
        ((self.code >> 16) & 0x3) as u8
    }
    /// spr_BAT: IBAT/DBAT index for m[tf][id]bat[ul]
    #[inline(always)]
    pub const fn field_spr_bat(&self) -> u8 {
        ((self.code >> 17) & 0x3) as u8
    }
    /// TO: Bitset for tw and twi
    #[inline(always)]
    pub const fn field_to(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// L: Bitset for cmp, cmpi, cmpl, cmpli
    #[inline(always)]
    pub const fn field_l(&self) -> u8 {
        ((self.code >> 21) & 0x1) as u8
    }
    /// sync_L: L field for sync
    #[inline(always)]
    pub const fn field_sync_l(&self) -> u8 {
        ((self.code >> 21) & 0x3) as u8
    }
    /// ds: Load/Store Double Word Offset (for 64-bit instructions)
    #[inline(always)]
    pub const fn field_ds(&self) -> i16 {
        (self.code & 0xfffc) as i16
    }
    /// SH64: Shift Amount (for 64-bit instructions)
    #[inline(always)]
    pub const fn field_sh64(&self) -> u8 {
        (((self.code >> 11) & 0x1f) | ((self.code & 0x2) << 4)) as u8
    }
    /// MB64: Mask Begin (for 64-bit instructions)
    #[inline(always)]
    pub const fn field_mb64(&self) -> u8 {
        (((self.code >> 6) & 0x1f) | (self.code & 0x20)) as u8
    }
    /// ME64: Mask End (for 64-bit instructions)
    #[inline(always)]
    pub const fn field_me64(&self) -> u8 {
        (((self.code >> 6) & 0x1f) | (self.code & 0x20)) as u8
    }
    /// mtmsrd_L: L field for mtmsrd
    #[inline(always)]
    pub const fn field_mtmsrd_l(&self) -> u8 {
        ((self.code >> 16) & 0x1) as u8
    }
    /// ps_offset: Paired Single Offset
    #[inline(always)]
    pub const fn field_ps_offset(&self) -> i16 {
        (((self.code & 0xfff) << 4) as i16) >> 4
    }
    /// ps_I
    #[inline(always)]
    pub const fn field_ps_i(&self) -> u8 {
        ((self.code >> 12) & 0x7) as u8
    }
    /// ps_IX
    #[inline(always)]
    pub const fn field_ps_ix(&self) -> u8 {
        ((self.code >> 7) & 0x7) as u8
    }
    /// ps_W
    #[inline(always)]
    pub const fn field_ps_w(&self) -> u8 {
        ((self.code >> 15) & 0x1) as u8
    }
    /// ps_WX
    #[inline(always)]
    pub const fn field_ps_wx(&self) -> u8 {
        ((self.code >> 10) & 0x1) as u8
    }
    /// vsimm: Vector Signed Immediate
    #[inline(always)]
    pub const fn field_vsimm(&self) -> i8 {
        ((((self.code >> 16) & 0x1f) << 3) as i8) >> 3
    }
    /// vuimm: Vector Unsigned Immediate
    #[inline(always)]
    pub const fn field_vuimm(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// vS: Vector Source Register
    #[inline(always)]
    pub const fn field_vs(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// vD: Vector Destination Register
    #[inline(always)]
    pub const fn field_vd(&self) -> u8 {
        ((self.code >> 21) & 0x1f) as u8
    }
    /// vA: Vector Register A
    #[inline(always)]
    pub const fn field_va(&self) -> u8 {
        ((self.code >> 16) & 0x1f) as u8
    }
    /// vB: Vector Register B
    #[inline(always)]
    pub const fn field_vb(&self) -> u8 {
        ((self.code >> 11) & 0x1f) as u8
    }
    /// vC: Vector Register C
    #[inline(always)]
    pub const fn field_vc(&self) -> u8 {
        ((self.code >> 6) & 0x1f) as u8
    }
    /// ds_A: All field for ds instructions
    #[inline(always)]
    pub const fn field_ds_a(&self) -> u8 {
        ((self.code >> 25) & 0x1) as u8
    }
    /// STRM: Stream ID
    #[inline(always)]
    pub const fn field_strm(&self) -> u8 {
        ((self.code >> 21) & 0x3) as u8
    }
    /// SHB
    #[inline(always)]
    pub const fn field_shb(&self) -> u8 {
        ((self.code >> 6) & 0xf) as u8
    }
    /// VDS128: VMX128 Source/Dest Register
    #[inline(always)]
    pub const fn field_vds128(&self) -> u8 {
        (((self.code >> 21) & 0x1f) | ((self.code & 0xc) << 3)) as u8
    }
    /// VA128: VMX128 Register A
    #[inline(always)]
    pub const fn field_va128(&self) -> u8 {
        (((self.code >> 16) & 0x1f) | (self.code & 0x20) | ((self.code >> 4) & 0x40))
            as u8
    }
    /// VB128: VMX128 Register B
    #[inline(always)]
    pub const fn field_vb128(&self) -> u8 {
        (((self.code >> 11) & 0x1f) | ((self.code & 0x3) << 5)) as u8
    }
    /// VC128: VMX128 Register C
    #[inline(always)]
    pub const fn field_vc128(&self) -> u8 {
        ((self.code >> 6) & 0x7) as u8
    }
    /// PERM: VMX128 Permutation
    #[inline(always)]
    pub const fn field_perm(&self) -> u8 {
        (((self.code >> 16) & 0x1f) | ((self.code >> 1) & 0xe0)) as u8
    }
    /// D3DType: the packed data type
    #[inline(always)]
    pub const fn field_d3dtype(&self) -> u8 {
        ((self.code >> 18) & 0x7) as u8
    }
    /// VMASK: the pack mask
    #[inline(always)]
    pub const fn field_vmask(&self) -> u8 {
        ((self.code >> 16) & 0x3) as u8
    }
    /// Zimm: amount to rotate/shift left
    #[inline(always)]
    pub const fn field_zimm(&self) -> u8 {
        ((self.code >> 6) & 0x3) as u8
    }
    /// OE: Field used by XO-form instructions to enable setting OV and SO in the XER.
    #[inline(always)]
    pub const fn field_oe(&self) -> bool {
        (self.code & 0x400) == 0x400
    }
    /// Rc: Record Bit
    #[inline(always)]
    pub const fn field_rc(&self) -> bool {
        (self.code & 0x1) == 0x1
    }
    /// LK: Link Bit
    #[inline(always)]
    pub const fn field_lk(&self) -> bool {
        (self.code & 0x1) == 0x1
    }
    /// AA: Absolute Address Bit
    #[inline(always)]
    pub const fn field_aa(&self) -> bool {
        (self.code & 0x2) == 0x2
    }
    /// BP: Predict branch to be taken
    #[inline(always)]
    pub const fn field_bp(&self) -> bool {
        (self.code & 0x200000) == 0x200000 && self.field_bd() >= 0x0
    }
    /// BNP: Predict branch not to be taken (fall through)
    #[inline(always)]
    pub const fn field_bnp(&self) -> bool {
        (self.code & 0x200000) == 0x200000 && self.field_bd() < 0x0
    }
    /// BP_ND: Predict branch to be taken (implicit dest for LR/CTR)
    #[inline(always)]
    pub const fn field_bp_nd(&self) -> bool {
        (self.code & 0x200000) == 0x200000
    }
    /// T: Transient bit
    #[inline(always)]
    pub const fn field_t(&self) -> bool {
        (self.code & 0x2000000) == 0x2000000
    }
    /// RcAV: Record Bit (AltiVec)
    #[inline(always)]
    pub const fn field_rcav(&self) -> bool {
        (self.code & 0x400) == 0x400
    }
    /// Rc128: Record Bit (VMX128)
    #[inline(always)]
    pub const fn field_rc128(&self) -> bool {
        (self.code & 0x40) == 0x40
    }
}
pub type Arguments = [Argument; 5];
pub const EMPTY_ARGS: Arguments = [
    Argument::None,
    Argument::None,
    Argument::None,
    Argument::None,
    Argument::None,
];
type MnemonicFunction = fn(&mut ParsedIns, Ins);
fn basic_tdi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "tdi",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_to() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_tdi(out: &mut ParsedIns, ins: Ins) {
    if ins.field_to() == 0x10 {
        *out = ParsedIns {
            mnemonic: "tdlti",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x18 {
        *out = ParsedIns {
            mnemonic: "tdnei",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_tdi(out, ins)
}
fn basic_twi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "twi",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_to() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_twi(out: &mut ParsedIns, ins: Ins) {
    if ins.field_to() == 0x8 {
        *out = ParsedIns {
            mnemonic: "twgti",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x6 {
        *out = ParsedIns {
            mnemonic: "twllei",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x1f {
        *out = ParsedIns {
            mnemonic: "twui",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_twi(out, ins)
}
fn basic_dcbz_l(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbz_l",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_psq_lux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_lux",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_wx() as _)),
            Argument::GQR(GQR(ins.field_ps_ix() as _)),
        ],
    };
}
fn basic_psq_lx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_lx",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_wx() as _)),
            Argument::GQR(GQR(ins.field_ps_ix() as _)),
        ],
    };
}
fn basic_psq_stux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_stux",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_wx() as _)),
            Argument::GQR(GQR(ins.field_ps_ix() as _)),
        ],
    };
}
fn basic_psq_stx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_stx",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_wx() as _)),
            Argument::GQR(GQR(ins.field_ps_ix() as _)),
        ],
    };
}
fn basic_ps_abs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_abs", "ps_abs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_add(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_add", "ps_add."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_cmpo0(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ps_cmpo0",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_cmpo1(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ps_cmpo1",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_cmpu0(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ps_cmpu0",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_cmpu1(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ps_cmpu1",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ps_div(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_div", "ps_div."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_madd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_madd", "ps_madd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_ps_madds0(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_madds0", "ps_madds0."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_ps_madds1(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_madds1", "ps_madds1."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_ps_merge00(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_merge00", "ps_merge00."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_merge01(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_merge01", "ps_merge01."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_merge10(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_merge10", "ps_merge10."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_merge11(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_merge11", "ps_merge11."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_mr(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_mr", "ps_mr."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_msub(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_msub", "ps_msub."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_ps_mul(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_mul", "ps_mul."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_muls0(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_muls0", "ps_muls0."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_muls1(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_muls1", "ps_muls1."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_nabs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_nabs", "ps_nabs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_neg(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_neg", "ps_neg."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_nmadd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_nmadd", "ps_nmadd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_ps_nmsub(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_nmsub", "ps_nmsub."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_ps_res(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_res", "ps_res."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_rsqrte(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_rsqrte", "ps_rsqrte."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_sel(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_sel", "ps_sel."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_ps_sub(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_sub", "ps_sub."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ps_sum0(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_sum0", "ps_sum0."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_ps_sum1(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["ps_sum1", "ps_sum1."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_mfvscr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfvscr",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtvscr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtvscr",
        args: [
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddcuw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddcuw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddfp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddfp",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddsbs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddsbs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddshs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddshs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddsws(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddsws",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddubm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddubm",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vaddubs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddubs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vadduhm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vadduhm",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vadduhs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vadduhs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vadduwm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vadduwm",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vadduws(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vadduws",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vand(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vand",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vandc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vandc",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vavgsb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vavgsb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vavgsh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vavgsh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vavgsw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vavgsw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vavgub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vavgub",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vavguh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vavguh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vavguw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vavguw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vcfsx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vcfsx",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vcfux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vcfux",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vcmpbfp(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpbfp", "vcmpbfp."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpeqfp(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpeqfp", "vcmpeqfp."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpequb(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpequb", "vcmpequb."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpequh(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpequh", "vcmpequh."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpequw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpequw", "vcmpequw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgefp(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpgefp", "vcmpgefp."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtfp(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpgtfp", "vcmpgtfp."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtsb(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpgtsb", "vcmpgtsb."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtsh(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpgtsh", "vcmpgtsh."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtsw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpgtsw", "vcmpgtsw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtub(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpgtub", "vcmpgtub."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtuh(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpgtuh", "vcmpgtuh."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtuw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpgtuw", "vcmpgtuw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rcav() as usize],
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::VR(VR(ins.field_vb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vctsxs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vctsxs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vctuxs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vctuxs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vexptefp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vexptefp",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vlogefp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vlogefp",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaddfp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaddfp",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmaxfp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxfp",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxsb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxsb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxsh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxsh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxsw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxsw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxub",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxuh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxuh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxuw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxuw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmhaddshs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmhaddshs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmhraddshs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmhraddshs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vminfp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminfp",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminsb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminsb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminsh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminsh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminsw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminsw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminub",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminuh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminuh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminuw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminuw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmladduhm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmladduhm",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmrghb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrghb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmrghh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrghh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmrghw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrghw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmrglb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrglb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmrglh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrglh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmrglw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrglw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmsummbm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsummbm",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmsumshm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsumshm",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmsumshs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsumshs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmsumubm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsumubm",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmsumuhm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsumuhm",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmsumuhs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsumuhs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vmulesb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmulesb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmulesh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmulesh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmuleub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmuleub",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmuleuh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmuleuh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmulosb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmulosb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmulosh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmulosh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmuloub(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmuloub",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmulouh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmulouh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vnmsubfp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vnmsubfp",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
        ],
    };
}
fn basic_vnor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vnor",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_vnor(out: &mut ParsedIns, ins: Ins) {
    if ins.field_vb() == ins.field_va() {
        *out = ParsedIns {
            mnemonic: "vnot",
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_vnor(out, ins)
}
fn basic_vor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vor",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_vor(out: &mut ParsedIns, ins: Ins) {
    if ins.field_vb() == ins.field_va() {
        *out = ParsedIns {
            mnemonic: "vmr",
            args: [
                Argument::VR(VR(ins.field_vd() as _)),
                Argument::VR(VR(ins.field_va() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_vor(out, ins)
}
fn basic_vperm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vperm",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vpkpx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkpx",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkshss(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkshss",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkshus(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkshus",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkswss(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkswss",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkswus(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkswus",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkuhum(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkuhum",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkuhus(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkuhus",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkuwum(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkuwum",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkuwus(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkuwus",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrefp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrefp",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrfim(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrfim",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrfin(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrfin",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrfip(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrfip",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrfiz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrfiz",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrlb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrlb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrlh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrlh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrlw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrlw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrsqrtefp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrsqrtefp",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsel(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsel",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::VR(VR(ins.field_vc() as _)),
            Argument::None,
        ],
    };
}
fn basic_vsl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsl",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vslb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vslb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsldoi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsldoi",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_shb() as _)),
            Argument::None,
        ],
    };
}
fn basic_vslh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vslh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vslo(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vslo",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vslw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vslw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vspltb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vspltb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsplth(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsplth",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vspltisb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vspltisb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::Simm(Simm(ins.field_vsimm() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vspltish(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vspltish",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::Simm(Simm(ins.field_vsimm() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vspltisw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vspltisw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::Simm(Simm(ins.field_vsimm() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vspltw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vspltw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsr",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsrab(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsrab",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsrah(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsrah",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsraw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsraw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsrb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsrb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsrh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsrh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsro(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsro",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsrw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsrw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubcuw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubcuw",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubfp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubfp",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubsbs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubsbs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubshs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubshs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubsws(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubsws",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsububm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsububm",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsububs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsububs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubuhm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubuhm",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubuhs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubuhs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubuwm(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubuwm",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubuws(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubuws",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsumsws(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsumsws",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsum2sws(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsum2sws",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsum4sbs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsum4sbs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsum4shs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsum4shs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsum4ubs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsum4ubs",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupkhpx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupkhpx",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupkhsb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupkhsb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupkhsh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupkhsh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupklpx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupklpx",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupklsb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupklsb",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupklsh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupklsh",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vxor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vxor",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::VR(VR(ins.field_va() as _)),
            Argument::VR(VR(ins.field_vb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvewx128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvewx128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvlx128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvlx128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvlxl128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvlxl128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvrx128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvrx128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvrxl128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvrxl128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvsl128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvsl128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvsr128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvsr128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvx128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvx128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvxl128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvxl128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvewx128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvewx128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvlx128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvlx128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvlxl128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvlxl128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvrx128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvrx128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvrxl128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvrxl128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvx128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvx128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvxl128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvxl128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsldoi128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsldoi128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_shb() as _)),
            Argument::None,
        ],
    };
}
fn basic_vaddfp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vaddfp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vand128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vand128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vandc128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vandc128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaddcfp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaddcfp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaddfp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaddfp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmsum3fp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsum3fp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmsum4fp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmsum4fp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmulfp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmulfp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vnmsubfp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vnmsubfp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vnor128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vnor128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vor128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vor128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vperm128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vperm128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::VR(VR(ins.field_vc128() as _)),
            Argument::None,
        ],
    };
}
fn basic_vpkshss128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkshss128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkshus128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkshus128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkswss128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkswss128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkswus128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkswus128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkuhum128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkuhum128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkuhus128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkuhus128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkuwum128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkuwum128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkuwus128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkuwus128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsel128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsel128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vslo128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vslo128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsro128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsro128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsubfp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsubfp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vxor128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vxor128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vctsxs128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vctsxs128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::Simm(Simm(ins.field_vsimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vctuxs128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vctuxs128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vcmpbfp128(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpbfp128", "vcmpbfp128."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc128() as usize],
            args: [
                Argument::VR(VR(ins.field_vds128() as _)),
                Argument::VR(VR(ins.field_va128() as _)),
                Argument::VR(VR(ins.field_vb128() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpeqfp128(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpeqfp128", "vcmpeqfp128."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc128() as usize],
            args: [
                Argument::VR(VR(ins.field_vds128() as _)),
                Argument::VR(VR(ins.field_va128() as _)),
                Argument::VR(VR(ins.field_vb128() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpequw128(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpequw128", "vcmpequw128."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc128() as usize],
            args: [
                Argument::VR(VR(ins.field_vds128() as _)),
                Argument::VR(VR(ins.field_va128() as _)),
                Argument::VR(VR(ins.field_vb128() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgefp128(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpgefp128", "vcmpgefp128."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc128() as usize],
            args: [
                Argument::VR(VR(ins.field_vds128() as _)),
                Argument::VR(VR(ins.field_va128() as _)),
                Argument::VR(VR(ins.field_vb128() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcmpgtfp128(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["vcmpgtfp128", "vcmpgtfp128."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc128() as usize],
            args: [
                Argument::VR(VR(ins.field_vds128() as _)),
                Argument::VR(VR(ins.field_va128() as _)),
                Argument::VR(VR(ins.field_vb128() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_vcfsx128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vcfsx128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::Simm(Simm(ins.field_vsimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vcfux128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vcfux128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vexptefp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vexptefp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vlogefp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vlogefp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmaxfp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmaxfp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vminfp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vminfp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmrghw128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrghw128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vmrglw128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vmrglw128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpermwi128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpermwi128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_perm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vpkd3d128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vpkd3d128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_d3dtype() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_vmask() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_zimm() as _)),
        ],
    };
}
fn basic_vrefp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrefp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrfim128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrfim128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrfin128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrfin128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrfip128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrfip128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrfiz128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrfiz128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrlimi128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrlimi128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_zimm() as _)),
            Argument::None,
        ],
    };
}
fn basic_vrlw128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrlw128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vrsqrtefp128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vrsqrtefp128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vslw128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vslw128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vspltisw128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vspltisw128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::Simm(Simm(ins.field_vsimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vspltw128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vspltw128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsraw128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsraw128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vsrw128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vsrw128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_va128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupkd3d128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupkd3d128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::Uimm(Uimm(ins.field_vuimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupkhsb128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupkhsb128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupkhsh128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupkhsh128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupklsb128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupklsb128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_vupklsh128(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "vupklsh128",
        args: [
            Argument::VR(VR(ins.field_vds128() as _)),
            Argument::VR(VR(ins.field_vb128() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mulli(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mulli",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_subfic(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "subfic",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_cmpli(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmpli",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_l() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
        ],
    };
}
fn simplified_cmpli(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmplwi",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmplwi",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpldi",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpldi",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cmpli(out, ins)
}
fn basic_cmpi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmpi",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_l() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
        ],
    };
}
fn simplified_cmpi(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmpwi",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmpwi",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpdi",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpdi",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cmpi(out, ins)
}
fn basic_addic(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "addic",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_addic(out: &mut ParsedIns, ins: Ins) {
    if ins.field_simm() < 0x0 && ins.field_simm() != -0x8000 {
        *out = ParsedIns {
            mnemonic: "subic",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm((-ins.field_simm()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_addic(out, ins)
}
fn basic_addic_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "addic.",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_addic_(out: &mut ParsedIns, ins: Ins) {
    if ins.field_simm() < 0x0 && ins.field_simm() != -0x8000 {
        *out = ParsedIns {
            mnemonic: "subic.",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm((-ins.field_simm()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_addic_(out, ins)
}
fn basic_addi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "addi",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Simm(Simm(ins.field_simm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_addi(out: &mut ParsedIns, ins: Ins) {
    if ins.field_ra() == 0x0 {
        *out = ParsedIns {
            mnemonic: "li",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::Simm(Simm(ins.field_simm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_simm() < 0x0 && ins.field_simm() != -0x8000 {
        *out = ParsedIns {
            mnemonic: "subi",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm((-ins.field_simm()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_addi(out, ins)
}
fn basic_addis(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "addis",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_addis(out: &mut ParsedIns, ins: Ins) {
    if ins.field_ra() == 0x0 {
        *out = ParsedIns {
            mnemonic: "lis",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::Uimm(Uimm(ins.field_uimm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_simm() < 0x0 && ins.field_simm() != -0x8000 {
        *out = ParsedIns {
            mnemonic: "subis",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::Simm(Simm((-ins.field_simm()) as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_addis(out, ins)
}
fn basic_bc(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 16] = [
            "bc",
            "bcl",
            "bca",
            "bcla",
            "bc+",
            "bcl+",
            "bca+",
            "bcla+",
            "bc-",
            "bcl-",
            "bca-",
            "bcla-",
            "<illegal>",
            "<illegal>",
            "<illegal>",
            "<illegal>",
        ];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_lk() as usize | (ins.field_aa() as usize) << 1
                | (ins.field_bp() as usize) << 2 | (ins.field_bnp() as usize) << 3],
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_bo() as _)),
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn simplified_bc(out: &mut ParsedIns, ins: Ins) {
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "blt",
                "bltl",
                "blta",
                "bltla",
                "blt+",
                "bltl+",
                "blta+",
                "bltla+",
                "blt-",
                "bltl-",
                "blta-",
                "bltla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x0 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "blt",
                "bltl",
                "blta",
                "bltla",
                "blt+",
                "bltl+",
                "blta+",
                "bltla+",
                "blt-",
                "bltl-",
                "blta-",
                "bltla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x1 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "ble",
                "blel",
                "blea",
                "blela",
                "ble+",
                "blel+",
                "blea+",
                "blela+",
                "ble-",
                "blel-",
                "blea-",
                "blela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x1 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "ble",
                "blel",
                "blea",
                "blela",
                "ble+",
                "blel+",
                "blea+",
                "blela+",
                "ble-",
                "blel-",
                "blea-",
                "blela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x2 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "beq",
                "beql",
                "beqa",
                "beqla",
                "beq+",
                "beql+",
                "beqa+",
                "beqla+",
                "beq-",
                "beql-",
                "beqa-",
                "beqla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x2 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "beq",
                "beql",
                "beqa",
                "beqla",
                "beq+",
                "beql+",
                "beqa+",
                "beqla+",
                "beq-",
                "beql-",
                "beqa-",
                "beqla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bge",
                "bgel",
                "bgea",
                "bgela",
                "bge+",
                "bgel+",
                "bgea+",
                "bgela+",
                "bge-",
                "bgel-",
                "bgea-",
                "bgela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x0 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bge",
                "bgel",
                "bgea",
                "bgela",
                "bge+",
                "bgel+",
                "bgea+",
                "bgela+",
                "bge-",
                "bgel-",
                "bgea-",
                "bgela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x1 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bgt",
                "bgtl",
                "bgta",
                "bgtla",
                "bgt+",
                "bgtl+",
                "bgta+",
                "bgtla+",
                "bgt-",
                "bgtl-",
                "bgta-",
                "bgtla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x1 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bgt",
                "bgtl",
                "bgta",
                "bgtla",
                "bgt+",
                "bgtl+",
                "bgta+",
                "bgtla+",
                "bgt-",
                "bgtl-",
                "bgta-",
                "bgtla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x2 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bne",
                "bnel",
                "bnea",
                "bnela",
                "bne+",
                "bnel+",
                "bnea+",
                "bnela+",
                "bne-",
                "bnel-",
                "bnea-",
                "bnela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x2 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bne",
                "bnel",
                "bnea",
                "bnela",
                "bne+",
                "bnel+",
                "bnea+",
                "bnela+",
                "bne-",
                "bnel-",
                "bnea-",
                "bnela-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x3 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bso",
                "bsol",
                "bsoa",
                "bsola",
                "bso+",
                "bsol+",
                "bsoa+",
                "bsola+",
                "bso-",
                "bsol-",
                "bsoa-",
                "bsola-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x3 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bso",
                "bsol",
                "bsoa",
                "bsola",
                "bso+",
                "bsol+",
                "bsoa+",
                "bsola+",
                "bso-",
                "bsol-",
                "bsoa-",
                "bsola-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x3 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bns",
                "bnsl",
                "bnsa",
                "bnsla",
                "bns+",
                "bnsl+",
                "bnsa+",
                "bnsla+",
                "bns-",
                "bnsl-",
                "bnsa-",
                "bnsla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x3 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bns",
                "bnsl",
                "bnsa",
                "bnsla",
                "bns+",
                "bnsl+",
                "bnsa+",
                "bnsla+",
                "bns-",
                "bnsl-",
                "bnsa-",
                "bnsla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x10 && ins.field_bi() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bdnz",
                "bdnzl",
                "bdnza",
                "bdnzla",
                "bdnz+",
                "bdnzl+",
                "bdnza+",
                "bdnzla+",
                "bdnz-",
                "bdnzl-",
                "bdnza-",
                "bdnzla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x8 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bdnzt",
                "bdnztl",
                "bdnzta",
                "bdnztla",
                "bdnzt+",
                "bdnztl+",
                "bdnzta+",
                "bdnztla+",
                "bdnzt-",
                "bdnztl-",
                "bdnzta-",
                "bdnztla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x0 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bdnzf",
                "bdnzfl",
                "bdnzfa",
                "bdnzfla",
                "bdnzf+",
                "bdnzfl+",
                "bdnzfa+",
                "bdnzfla+",
                "bdnzf-",
                "bdnzfl-",
                "bdnzfa-",
                "bdnzfla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x12 && ins.field_bi() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bdz",
                "bdzl",
                "bdza",
                "bdzla",
                "bdz+",
                "bdzl+",
                "bdza+",
                "bdzla+",
                "bdz-",
                "bdzl-",
                "bdza-",
                "bdzla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xa {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bdzt",
                "bdztl",
                "bdzta",
                "bdztla",
                "bdzt+",
                "bdztl+",
                "bdzta+",
                "bdztla+",
                "bdzt-",
                "bdztl-",
                "bdzta-",
                "bdztla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x2 {
        *out = {
            static MODIFIERS: [&str; 16] = [
                "bdzf",
                "bdzfl",
                "bdzfa",
                "bdzfla",
                "bdzf+",
                "bdzfl+",
                "bdzfa+",
                "bdzfla+",
                "bdzf-",
                "bdzfl-",
                "bdzfa-",
                "bdzfla-",
                "<illegal>",
                "<illegal>",
                "<illegal>",
                "<illegal>",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_aa() as usize) << 1 | (ins.field_bp() as usize) << 2
                    | (ins.field_bnp() as usize) << 3],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::BranchDest(BranchDest(ins.field_bd() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_bc(out, ins)
}
fn basic_sc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sc",
        args: EMPTY_ARGS,
    };
}
fn basic_b(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["b", "bl", "ba", "bla"];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_lk() as usize
                | (ins.field_aa() as usize) << 1],
            args: [
                Argument::BranchDest(BranchDest(ins.field_li() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_bcctr(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["bcctr", "bcctrl", "bcctr+", "bcctrl+"];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_lk() as usize
                | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_bo() as _)),
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn simplified_bcctr(out: &mut ParsedIns, ins: Ins) {
    if ins.field_bo() == 0x14 && ins.field_bi() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 2] = ["bctr", "bctrl"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bltctr", "bltctrl", "bltctr+", "bltctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x0 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bltctr", "bltctrl", "bltctr+", "bltctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x1 {
        *out = {
            static MODIFIERS: [&str; 4] = ["blectr", "blectrl", "blectr+", "blectrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x1 {
        *out = {
            static MODIFIERS: [&str; 4] = ["blectr", "blectrl", "blectr+", "blectrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x2 {
        *out = {
            static MODIFIERS: [&str; 4] = ["beqctr", "beqctrl", "beqctr+", "beqctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x2 {
        *out = {
            static MODIFIERS: [&str; 4] = ["beqctr", "beqctrl", "beqctr+", "beqctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bgectr", "bgectrl", "bgectr+", "bgectrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x0 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bgectr", "bgectrl", "bgectr+", "bgectrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x1 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bgtctr", "bgtctrl", "bgtctr+", "bgtctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x1 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bgtctr", "bgtctrl", "bgtctr+", "bgtctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x2 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bnectr", "bnectrl", "bnectr+", "bnectrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x2 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bnectr", "bnectrl", "bnectr+", "bnectrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x3 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bsoctr", "bsoctrl", "bsoctr+", "bsoctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x3 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bsoctr", "bsoctrl", "bsoctr+", "bsoctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x3 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bnsctr", "bnsctrl", "bnsctr+", "bnsctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x3 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bnsctr", "bnsctrl", "bnsctr+", "bnsctrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_bcctr(out, ins)
}
fn basic_bclr(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["bclr", "bclrl", "bclr+", "bclrl+"];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_lk() as usize
                | (ins.field_bp_nd() as usize) << 1],
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_bo() as _)),
                Argument::CRBit(CRBit(ins.field_bi() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn simplified_bclr(out: &mut ParsedIns, ins: Ins) {
    if ins.field_bo() == 0x14 && ins.field_bi() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 2] = ["blr", "blrl"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bltlr", "bltlrl", "bltlr+", "bltlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x0 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bltlr", "bltlrl", "bltlr+", "bltlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x1 {
        *out = {
            static MODIFIERS: [&str; 4] = ["blelr", "blelrl", "blelr+", "blelrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x1 {
        *out = {
            static MODIFIERS: [&str; 4] = ["blelr", "blelrl", "blelr+", "blelrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x2 {
        *out = {
            static MODIFIERS: [&str; 4] = ["beqlr", "beqlrl", "beqlr+", "beqlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x2 {
        *out = {
            static MODIFIERS: [&str; 4] = ["beqlr", "beqlrl", "beqlr+", "beqlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bgelr", "bgelrl", "bgelr+", "bgelrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x0 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bgelr", "bgelrl", "bgelr+", "bgelrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x1 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bgtlr", "bgtlrl", "bgtlr+", "bgtlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x1 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bgtlr", "bgtlrl", "bgtlr+", "bgtlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x2 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bnelr", "bnelrl", "bnelr+", "bnelrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x2 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bnelr", "bnelrl", "bnelr+", "bnelrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && ins.field_bi() == 0x3 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bsolr", "bsolrl", "bsolr+", "bsolrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xc && (ins.field_bi() & 0x3) == 0x3 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bsolr", "bsolrl", "bsolr+", "bsolrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && ins.field_bi() == 0x3 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bnslr", "bnslrl", "bnslr+", "bnslrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x4 && (ins.field_bi() & 0x3) == 0x3 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bnslr", "bnslrl", "bnslr+", "bnslrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRField(CRField(ins.field_crfs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x10 && ins.field_bi() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bdnzlr", "bdnzlrl", "bdnzlr+", "bdnzlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x8 {
        *out = {
            static MODIFIERS: [&str; 4] = [
                "bdnztlr",
                "bdnztlrl",
                "bdnztlr+",
                "bdnztlrl+",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x0 {
        *out = {
            static MODIFIERS: [&str; 4] = [
                "bdnzflr",
                "bdnzflrl",
                "bdnzflr+",
                "bdnzflrl+",
            ];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x12 && ins.field_bi() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bdzlr", "bdzlrl", "bdzlr+", "bdzlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: EMPTY_ARGS,
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0xa {
        *out = {
            static MODIFIERS: [&str; 4] = ["bdztlr", "bdztlrl", "bdztlr+", "bdztlrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if (ins.field_bo() & 0x1e) == 0x0 {
        *out = {
            static MODIFIERS: [&str; 4] = ["bdzflr", "bdzflrl", "bdzflr+", "bdzflrl+"];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_lk() as usize
                    | (ins.field_bp_nd() as usize) << 1],
                args: [
                    Argument::CRBit(CRBit(ins.field_bi() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_bclr(out, ins)
}
fn basic_crand(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crand",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_crandc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crandc",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_creqv(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "creqv",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_creqv(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crba() == ins.field_crbd() && ins.field_crbb() == ins.field_crbd() {
        *out = ParsedIns {
            mnemonic: "crset",
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_creqv(out, ins)
}
fn basic_crnand(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crnand",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_crnor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crnor",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_crnor(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crbb() == ins.field_crba() {
        *out = ParsedIns {
            mnemonic: "crnot",
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::CRBit(CRBit(ins.field_crba() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_crnor(out, ins)
}
fn basic_cror(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cror",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_cror(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crbb() == ins.field_crba() {
        *out = ParsedIns {
            mnemonic: "crmove",
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::CRBit(CRBit(ins.field_crba() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cror(out, ins)
}
fn basic_crorc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crorc",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_crxor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "crxor",
        args: [
            Argument::CRBit(CRBit(ins.field_crbd() as _)),
            Argument::CRBit(CRBit(ins.field_crba() as _)),
            Argument::CRBit(CRBit(ins.field_crbb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_crxor(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crba() == ins.field_crbd() && ins.field_crbb() == ins.field_crbd() {
        *out = ParsedIns {
            mnemonic: "crclr",
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_crxor(out, ins)
}
fn basic_isync(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "isync",
        args: EMPTY_ARGS,
    };
}
fn basic_mcrf(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mcrf",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::CRField(CRField(ins.field_crfs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_rfi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "rfi",
        args: EMPTY_ARGS,
    };
}
fn basic_rfid(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "rfid",
        args: EMPTY_ARGS,
    };
}
fn basic_rlwimi(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["rlwimi", "rlwimi."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_me() as _)),
            ],
        }
    };
}
fn basic_rlwinm(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["rlwinm", "rlwinm."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_me() as _)),
            ],
        }
    };
}
fn simplified_rlwinm(out: &mut ParsedIns, ins: Ins) {
    if ins.field_sh() == 0x0 && ins.field_mb() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 2] = ["clrrwi", "clrrwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU((31 - ins.field_me()) as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_sh() == 0x0 && ins.field_me() == 0x1f {
        *out = {
            static MODIFIERS: [&str; 2] = ["clrlwi", "clrlwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_mb() == 0x0 && ins.field_me() == 0x1f && ins.field_sh() <= 0x10 {
        *out = {
            static MODIFIERS: [&str; 2] = ["rotlwi", "rotlwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_mb() == 0x0 && ins.field_me() == 0x1f && ins.field_sh() > 0x10 {
        *out = {
            static MODIFIERS: [&str; 2] = ["rotrwi", "rotrwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU((32 - ins.field_sh()) as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_mb() == 0x0 && ins.field_me() == 31 - ins.field_sh() {
        *out = {
            static MODIFIERS: [&str; 2] = ["slwi", "slwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_me() == 0x1f && ins.field_sh() == 32 - ins.field_mb() {
        *out = {
            static MODIFIERS: [&str; 2] = ["srwi", "srwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_sh() < 0x20 && ins.field_me() == 31 - ins.field_sh() {
        *out = {
            static MODIFIERS: [&str; 2] = ["clrlslwi", "clrlslwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU((ins.field_mb() + ins.field_sh()) as _)),
                    Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_mb() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 2] = ["extlwi", "extlwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU((ins.field_me() + 1) as _)),
                    Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                    Argument::None,
                ],
            }
        };
        return;
    }
    if ins.field_me() == 0x1f && ins.field_sh() >= 32 - ins.field_mb() {
        *out = {
            static MODIFIERS: [&str; 2] = ["extrwi", "extrwi."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::OpaqueU(OpaqueU((32 - ins.field_mb()) as _)),
                    Argument::OpaqueU(
                        OpaqueU((ins.field_sh() - (32 - ins.field_mb())) as _),
                    ),
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_rlwinm(out, ins)
}
fn basic_rlwnm(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["rlwnm", "rlwnm."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_me() as _)),
            ],
        }
    };
}
fn simplified_rlwnm(out: &mut ParsedIns, ins: Ins) {
    if ins.field_mb() == 0x0 && ins.field_me() == 0x1f {
        *out = {
            static MODIFIERS: [&str; 2] = ["rotlw", "rotlw."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::GPR(GPR(ins.field_rb() as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_rlwnm(out, ins)
}
fn basic_ori(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ori",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_ori(out: &mut ParsedIns, ins: Ins) {
    if ins.field_ra() == 0x0 && ins.field_rs() == 0x0 && ins.field_uimm() == 0x0 {
        *out = ParsedIns {
            mnemonic: "nop",
            args: EMPTY_ARGS,
        };
        return;
    }
    basic_ori(out, ins)
}
fn basic_oris(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "oris",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_xori(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "xori",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_xoris(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "xoris",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_andi_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "andi.",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_andis_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "andis.",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Uimm(Uimm(ins.field_uimm() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_rldcl(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["rldcl", "rldcl."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb64() as _)),
                Argument::None,
            ],
        }
    };
}
fn simplified_rldcl(out: &mut ParsedIns, ins: Ins) {
    if ins.field_mb64() == 0x0 {
        *out = {
            static MODIFIERS: [&str; 2] = ["rotld", "rotld."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::GPR(GPR(ins.field_rb() as _)),
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_rldcl(out, ins)
}
fn basic_rldcr(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["rldcr", "rldcr."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_me64() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_rldic(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["rldic", "rldic."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh64() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb64() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_rldicl(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["rldicl", "rldicl."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh64() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb64() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_rldicr(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["rldicr", "rldicr."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh64() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_me64() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_rldimi(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["rldimi", "rldimi."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh64() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mb64() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_add(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["add", "addo", "add.", "addo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_addc(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["addc", "addco", "addc.", "addco."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_adde(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["adde", "addeo", "adde.", "addeo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_addme(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["addme", "addmeo", "addme.", "addmeo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_addze(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["addze", "addzeo", "addze.", "addzeo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_and(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["and", "and."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_andc(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["andc", "andc."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_cmp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmp",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_l() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
        ],
    };
}
fn simplified_cmp(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmpw",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmpw",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpd",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpd",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cmp(out, ins)
}
fn basic_cmpl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmpl",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_l() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
        ],
    };
}
fn simplified_cmpl(out: &mut ParsedIns, ins: Ins) {
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmplw",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "cmplw",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_crfd() == 0x0 && ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpld",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "cmpld",
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_cmpl(out, ins)
}
fn basic_cntlzw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["cntlzw", "cntlzw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_dcbf(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbf",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbi",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbst(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbst",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbt(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbt",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbtst(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbtst",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_dcbz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbz",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_divw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["divw", "divwo", "divw.", "divwo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_divwu(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["divwu", "divwuo", "divwu.", "divwuo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_eciwx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "eciwx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ecowx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ecowx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_eieio(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "eieio",
        args: EMPTY_ARGS,
    };
}
fn basic_eqv(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["eqv", "eqv."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_extsb(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["extsb", "extsb."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_extsh(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["extsh", "extsh."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_icbi(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["icbi", "icbi."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_lbzux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lbzux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lbzx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lbzx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfdux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfdux",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfdx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfdx",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfsux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfsux",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfsx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfsx",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhaux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhaux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhax(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhax",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhbrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhbrx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhzux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhzux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhzx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhzx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lswi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lswi",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_nb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lswx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lswx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwarx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwarx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwbrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwbrx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwzux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwzux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwzx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwzx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mcrxr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mcrxr",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfcr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfcr",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfmsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfmsr",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfspr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfspr",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::SPR(SPR(ins.field_spr() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_mfspr(out: &mut ParsedIns, ins: Ins) {
    if ins.field_spr() == 0x1 {
        *out = ParsedIns {
            mnemonic: "mfxer",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x8 {
        *out = ParsedIns {
            mnemonic: "mflr",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x9 {
        *out = ParsedIns {
            mnemonic: "mfctr",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x12 {
        *out = ParsedIns {
            mnemonic: "mfdsisr",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x13 {
        *out = ParsedIns {
            mnemonic: "mfdar",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x16 {
        *out = ParsedIns {
            mnemonic: "mfdec",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x19 {
        *out = ParsedIns {
            mnemonic: "mfsdr1",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x1a {
        *out = ParsedIns {
            mnemonic: "mfsrr0",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x1b {
        *out = ParsedIns {
            mnemonic: "mfsrr1",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3fc) == 0x110 {
        *out = ParsedIns {
            mnemonic: "mfsprg",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_sprg() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x11a {
        *out = ParsedIns {
            mnemonic: "mfear",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x210 {
        *out = ParsedIns {
            mnemonic: "mfibatu",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x211 {
        *out = ParsedIns {
            mnemonic: "mfibatl",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x218 {
        *out = ParsedIns {
            mnemonic: "mfdbatu",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x219 {
        *out = ParsedIns {
            mnemonic: "mfdbatl",
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_mfspr(out, ins)
}
fn basic_mfsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfsr",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::SR(SR(ins.field_sr() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfsrin(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfsrin",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mftb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mftb",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_tbr() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtcrf(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtcrf",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_crm() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtmsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtmsr",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtspr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtspr",
        args: [
            Argument::SPR(SPR(ins.field_spr() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_mtspr(out: &mut ParsedIns, ins: Ins) {
    if ins.field_spr() == 0x1 {
        *out = ParsedIns {
            mnemonic: "mtxer",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x8 {
        *out = ParsedIns {
            mnemonic: "mtlr",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x9 {
        *out = ParsedIns {
            mnemonic: "mtctr",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x12 {
        *out = ParsedIns {
            mnemonic: "mtdsisr",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x13 {
        *out = ParsedIns {
            mnemonic: "mtdar",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x16 {
        *out = ParsedIns {
            mnemonic: "mtdec",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x19 {
        *out = ParsedIns {
            mnemonic: "mtsdr1",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x1a {
        *out = ParsedIns {
            mnemonic: "mtsrr0",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x1b {
        *out = ParsedIns {
            mnemonic: "mtsrr1",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3fc) == 0x110 {
        *out = ParsedIns {
            mnemonic: "mtsprg",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_sprg() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x11a {
        *out = ParsedIns {
            mnemonic: "mtear",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x11c {
        *out = ParsedIns {
            mnemonic: "mttbl",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_spr() == 0x11d {
        *out = ParsedIns {
            mnemonic: "mttbu",
            args: [
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x210 {
        *out = ParsedIns {
            mnemonic: "mtibatu",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x211 {
        *out = ParsedIns {
            mnemonic: "mtibatl",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x218 {
        *out = ParsedIns {
            mnemonic: "mtdbatu",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if (ins.field_spr() & 0x3f9) == 0x219 {
        *out = ParsedIns {
            mnemonic: "mtdbatl",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_spr_bat() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_mtspr(out, ins)
}
fn basic_mtsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtsr",
        args: [
            Argument::SR(SR(ins.field_sr() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtsrin(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtsrin",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mulhw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["mulhw", "mulhw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mulhwu(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["mulhwu", "mulhwu."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mullw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["mullw", "mullwo", "mullw.", "mullwo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_nand(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["nand", "nand."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_neg(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["neg", "nego", "neg.", "nego."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_nor(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["nor", "nor."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_or(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["or", "or."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn simplified_or(out: &mut ParsedIns, ins: Ins) {
    if ins.field_rb() == ins.field_rs() {
        *out = {
            static MODIFIERS: [&str; 2] = ["mr", "mr."];
            ParsedIns {
                mnemonic: MODIFIERS[ins.field_rc() as usize],
                args: [
                    Argument::GPR(GPR(ins.field_ra() as _)),
                    Argument::GPR(GPR(ins.field_rs() as _)),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        };
        return;
    }
    basic_or(out, ins)
}
fn basic_orc(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["orc", "orc."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_slw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["slw", "slw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_sraw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["sraw", "sraw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_srawi(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["srawi", "srawi."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_srw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["srw", "srw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_stbux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stbux",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stbx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stbx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfdux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfdux",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfdx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfdx",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfiwx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfiwx",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfsux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfsux",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfsx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfsx",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sthbrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sthbrx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sthux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sthux",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sthx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sthx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stswi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stswi",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_nb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stswx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stswx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwbrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwbrx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwcx_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwcx.",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwux",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_subf(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["subf", "subfo", "subf.", "subfo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_subfc(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["subfc", "subfco", "subfc.", "subfco."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_subfe(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["subfe", "subfeo", "subfe.", "subfeo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_subfme(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["subfme", "subfmeo", "subfme.", "subfmeo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_subfze(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["subfze", "subfzeo", "subfze.", "subfzeo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_sync(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sync",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_sync_l() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_sync(out: &mut ParsedIns, ins: Ins) {
    if ins.field_sync_l() == 0x0 {
        *out = ParsedIns {
            mnemonic: "sync",
            args: EMPTY_ARGS,
        };
        return;
    }
    if ins.field_sync_l() == 0x1 {
        *out = ParsedIns {
            mnemonic: "lwsync",
            args: EMPTY_ARGS,
        };
        return;
    }
    if ins.field_sync_l() == 0x2 {
        *out = ParsedIns {
            mnemonic: "ptesync",
            args: EMPTY_ARGS,
        };
        return;
    }
    basic_sync(out, ins)
}
fn basic_tlbie(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "tlbie",
        args: [
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_tlbsync(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "tlbsync",
        args: EMPTY_ARGS,
    };
}
fn basic_tw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "tw",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_to() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_tw(out: &mut ParsedIns, ins: Ins) {
    if ins.field_to() == 0x4 {
        *out = ParsedIns {
            mnemonic: "tweq",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x5 {
        *out = ParsedIns {
            mnemonic: "twlge",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x1f && ins.field_ra() == 0x0 && ins.field_rb() == 0x0 {
        *out = ParsedIns {
            mnemonic: "trap",
            args: EMPTY_ARGS,
        };
        return;
    }
    basic_tw(out, ins)
}
fn basic_xor(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["xor", "xor."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_cntlzd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["cntlzd", "cntlzd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_dcbzl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dcbzl",
        args: [
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_divd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["divd", "divdo", "divd.", "divdo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_divdu(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["divdu", "divduo", "divdu.", "divduo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_extsw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["extsw", "extsw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_ldarx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldarx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ldux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ldx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldx",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwaux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwaux",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwax(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwax",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mfocrf(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mfocrf",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_crm() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtmsrd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtmsrd",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_mtmsrd_l() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtsrd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtsrd",
        args: [
            Argument::SR(SR(ins.field_sr() as _)),
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mtsrdin(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mtsrdin",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mulhd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["mulhd", "mulhd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mulhdu(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["mulhdu", "mulhdu."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mulld(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 4] = ["mulld", "mulldo", "mulld.", "mulldo."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_oe() as usize
                | (ins.field_rc() as usize) << 1],
            args: [
                Argument::GPR(GPR(ins.field_rd() as _)),
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_slbia(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "slbia",
        args: EMPTY_ARGS,
    };
}
fn basic_slbie(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "slbie",
        args: [
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sld(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["sld", "sld."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_srad(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["srad", "srad."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_sradi(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["sradi", "sradi."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_sh64() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_srd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["srd", "srd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rs() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_stdcx_(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stdcx.",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stdux(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stdux",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stdx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stdx",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_td(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "td",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_to() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_td(out: &mut ParsedIns, ins: Ins) {
    if ins.field_to() == 0xc {
        *out = ParsedIns {
            mnemonic: "tdge",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_to() == 0x5 {
        *out = ParsedIns {
            mnemonic: "tdlnl",
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    basic_td(out, ins)
}
fn basic_dss(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "dss",
        args: [
            Argument::OpaqueU(OpaqueU(ins.field_strm() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ds_a() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn simplified_dss(out: &mut ParsedIns, ins: Ins) {
    if ins.field_ds_a() == 0x0 {
        *out = ParsedIns {
            mnemonic: "dss",
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_strm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
        return;
    }
    if ins.field_ds_a() == 0x1 && ins.field_strm() == 0x0 {
        *out = ParsedIns {
            mnemonic: "dssall",
            args: EMPTY_ARGS,
        };
        return;
    }
    basic_dss(out, ins)
}
fn basic_dst(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["dst", "dstt"];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_t() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_strm() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_dstst(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["dstst", "dststt"];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_t() as usize],
            args: [
                Argument::GPR(GPR(ins.field_ra() as _)),
                Argument::GPR(GPR(ins.field_rb() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_strm() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_lvebx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvebx",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvehx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvehx",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvewx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvewx",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvlx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvlx",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvlxl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvlxl",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvrx",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvrxl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvrxl",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvsl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvsl",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvsr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvsr",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvx",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lvxl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lvxl",
        args: [
            Argument::VR(VR(ins.field_vd() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvebx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvebx",
        args: [
            Argument::VR(VR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvehx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvehx",
        args: [
            Argument::VR(VR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvewx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvewx",
        args: [
            Argument::VR(VR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvlx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvlx",
        args: [
            Argument::VR(VR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvlxl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvlxl",
        args: [
            Argument::VR(VR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvrx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvrx",
        args: [
            Argument::VR(VR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvrxl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvrxl",
        args: [
            Argument::VR(VR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvx(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvx",
        args: [
            Argument::VR(VR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stvxl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stvxl",
        args: [
            Argument::VR(VR(ins.field_vs() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::GPR(GPR(ins.field_rb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwz",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwzu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwzu",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lbz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lbz",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lbzu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lbzu",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stw",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stwu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stwu",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stb",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stbu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stbu",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhz(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhz",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhzu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhzu",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lha(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lha",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lhau(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lhau",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sth(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sth",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_sthu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sthu",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lmw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lmw",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stmw(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stmw",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfs",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfsu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfsu",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfd",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lfdu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lfdu",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfs",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfsu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfsu",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfd(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfd",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stfdu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stfdu",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_psq_l(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_l",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_ps_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_w() as _)),
            Argument::GQR(GQR(ins.field_ps_i() as _)),
        ],
    };
}
fn basic_psq_lu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_lu",
        args: [
            Argument::FPR(FPR(ins.field_frd() as _)),
            Argument::Offset(Offset(ins.field_ps_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_w() as _)),
            Argument::GQR(GQR(ins.field_ps_i() as _)),
        ],
    };
}
fn basic_ld(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ld",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_ds() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_ldu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldu",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_ds() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_lwa(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lwa",
        args: [
            Argument::GPR(GPR(ins.field_rd() as _)),
            Argument::Offset(Offset(ins.field_ds() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fadds(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fadds", "fadds."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fdivs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fdivs", "fdivs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fmadds(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fmadds", "fmadds."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fmsubs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fmsubs", "fmsubs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fmuls(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fmuls", "fmuls."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fnmadds(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fnmadds", "fnmadds."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fnmsubs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fnmsubs", "fnmsubs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fres(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fres", "fres."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fsubs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fsubs", "fsubs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fsqrts(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fsqrts", "fsqrts."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_psq_st(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_st",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_ps_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_w() as _)),
            Argument::GQR(GQR(ins.field_ps_i() as _)),
        ],
    };
}
fn basic_psq_stu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "psq_stu",
        args: [
            Argument::FPR(FPR(ins.field_frs() as _)),
            Argument::Offset(Offset(ins.field_ps_offset() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::OpaqueU(OpaqueU(ins.field_ps_w() as _)),
            Argument::GQR(GQR(ins.field_ps_i() as _)),
        ],
    };
}
fn basic_std(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "std",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_ds() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_stdu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stdu",
        args: [
            Argument::GPR(GPR(ins.field_rs() as _)),
            Argument::Offset(Offset(ins.field_ds() as _)),
            Argument::GPR(GPR(ins.field_ra() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fabs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fabs", "fabs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fadd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fadd", "fadd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fcmpo(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "fcmpo",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fcmpu(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "fcmpu",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::FPR(FPR(ins.field_fra() as _)),
            Argument::FPR(FPR(ins.field_frb() as _)),
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_fctiw(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fctiw", "fctiw."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fctiwz(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fctiwz", "fctiwz."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fdiv(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fdiv", "fdiv."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fmadd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fmadd", "fmadd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fmr(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fmr", "fmr."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fmsub(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fmsub", "fmsub."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fmul(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fmul", "fmul."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fnabs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fnabs", "fnabs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fneg(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fneg", "fneg."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fnmadd(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fnmadd", "fnmadd."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fnmsub(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fnmsub", "fnmsub."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_frsp(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["frsp", "frsp."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_frsqrte(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["frsqrte", "frsqrte."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fsel(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fsel", "fsel."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frc() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
            ],
        }
    };
}
fn basic_fsub(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fsub", "fsub."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_fra() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mcrfs(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mcrfs",
        args: [
            Argument::CRField(CRField(ins.field_crfd() as _)),
            Argument::CRField(CRField(ins.field_crfs() as _)),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn basic_mffs(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["mffs", "mffs."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mtfsb0(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["mtfsb0", "mtfsb0."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mtfsb1(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["mtfsb1", "mtfsb1."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::CRBit(CRBit(ins.field_crbd() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mtfsf(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["mtfsf", "mtfsf."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::OpaqueU(OpaqueU(ins.field_mtfsf_fm() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_mtfsfi(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["mtfsfi", "mtfsfi."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::CRField(CRField(ins.field_crfd() as _)),
                Argument::OpaqueU(OpaqueU(ins.field_mtfsf_imm() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fcfid(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fcfid", "fcfid."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fctid(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fctid", "fctid."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fctidz(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fctidz", "fctidz."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn basic_fsqrt(out: &mut ParsedIns, ins: Ins) {
    *out = {
        static MODIFIERS: [&str; 2] = ["fsqrt", "fsqrt."];
        ParsedIns {
            mnemonic: MODIFIERS[ins.field_rc() as usize],
            args: [
                Argument::FPR(FPR(ins.field_frd() as _)),
                Argument::FPR(FPR(ins.field_frb() as _)),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    };
}
fn mnemonic_illegal(out: &mut ParsedIns, _ins: Ins) {
    *out = ParsedIns::new();
}
static BASIC_MNEMONICS: [MnemonicFunction; 511] = [
    basic_tdi,
    basic_twi,
    basic_dcbz_l,
    basic_psq_lux,
    basic_psq_lx,
    basic_psq_stux,
    basic_psq_stx,
    basic_ps_abs,
    basic_ps_add,
    basic_ps_cmpo0,
    basic_ps_cmpo1,
    basic_ps_cmpu0,
    basic_ps_cmpu1,
    basic_ps_div,
    basic_ps_madd,
    basic_ps_madds0,
    basic_ps_madds1,
    basic_ps_merge00,
    basic_ps_merge01,
    basic_ps_merge10,
    basic_ps_merge11,
    basic_ps_mr,
    basic_ps_msub,
    basic_ps_mul,
    basic_ps_muls0,
    basic_ps_muls1,
    basic_ps_nabs,
    basic_ps_neg,
    basic_ps_nmadd,
    basic_ps_nmsub,
    basic_ps_res,
    basic_ps_rsqrte,
    basic_ps_sel,
    basic_ps_sub,
    basic_ps_sum0,
    basic_ps_sum1,
    basic_mfvscr,
    basic_mtvscr,
    basic_vaddcuw,
    basic_vaddfp,
    basic_vaddsbs,
    basic_vaddshs,
    basic_vaddsws,
    basic_vaddubm,
    basic_vaddubs,
    basic_vadduhm,
    basic_vadduhs,
    basic_vadduwm,
    basic_vadduws,
    basic_vand,
    basic_vandc,
    basic_vavgsb,
    basic_vavgsh,
    basic_vavgsw,
    basic_vavgub,
    basic_vavguh,
    basic_vavguw,
    basic_vcfsx,
    basic_vcfux,
    basic_vcmpbfp,
    basic_vcmpeqfp,
    basic_vcmpequb,
    basic_vcmpequh,
    basic_vcmpequw,
    basic_vcmpgefp,
    basic_vcmpgtfp,
    basic_vcmpgtsb,
    basic_vcmpgtsh,
    basic_vcmpgtsw,
    basic_vcmpgtub,
    basic_vcmpgtuh,
    basic_vcmpgtuw,
    basic_vctsxs,
    basic_vctuxs,
    basic_vexptefp,
    basic_vlogefp,
    basic_vmaddfp,
    basic_vmaxfp,
    basic_vmaxsb,
    basic_vmaxsh,
    basic_vmaxsw,
    basic_vmaxub,
    basic_vmaxuh,
    basic_vmaxuw,
    basic_vmhaddshs,
    basic_vmhraddshs,
    basic_vminfp,
    basic_vminsb,
    basic_vminsh,
    basic_vminsw,
    basic_vminub,
    basic_vminuh,
    basic_vminuw,
    basic_vmladduhm,
    basic_vmrghb,
    basic_vmrghh,
    basic_vmrghw,
    basic_vmrglb,
    basic_vmrglh,
    basic_vmrglw,
    basic_vmsummbm,
    basic_vmsumshm,
    basic_vmsumshs,
    basic_vmsumubm,
    basic_vmsumuhm,
    basic_vmsumuhs,
    basic_vmulesb,
    basic_vmulesh,
    basic_vmuleub,
    basic_vmuleuh,
    basic_vmulosb,
    basic_vmulosh,
    basic_vmuloub,
    basic_vmulouh,
    basic_vnmsubfp,
    basic_vnor,
    basic_vor,
    basic_vperm,
    basic_vpkpx,
    basic_vpkshss,
    basic_vpkshus,
    basic_vpkswss,
    basic_vpkswus,
    basic_vpkuhum,
    basic_vpkuhus,
    basic_vpkuwum,
    basic_vpkuwus,
    basic_vrefp,
    basic_vrfim,
    basic_vrfin,
    basic_vrfip,
    basic_vrfiz,
    basic_vrlb,
    basic_vrlh,
    basic_vrlw,
    basic_vrsqrtefp,
    basic_vsel,
    basic_vsl,
    basic_vslb,
    basic_vsldoi,
    basic_vslh,
    basic_vslo,
    basic_vslw,
    basic_vspltb,
    basic_vsplth,
    basic_vspltisb,
    basic_vspltish,
    basic_vspltisw,
    basic_vspltw,
    basic_vsr,
    basic_vsrab,
    basic_vsrah,
    basic_vsraw,
    basic_vsrb,
    basic_vsrh,
    basic_vsro,
    basic_vsrw,
    basic_vsubcuw,
    basic_vsubfp,
    basic_vsubsbs,
    basic_vsubshs,
    basic_vsubsws,
    basic_vsububm,
    basic_vsububs,
    basic_vsubuhm,
    basic_vsubuhs,
    basic_vsubuwm,
    basic_vsubuws,
    basic_vsumsws,
    basic_vsum2sws,
    basic_vsum4sbs,
    basic_vsum4shs,
    basic_vsum4ubs,
    basic_vupkhpx,
    basic_vupkhsb,
    basic_vupkhsh,
    basic_vupklpx,
    basic_vupklsb,
    basic_vupklsh,
    basic_vxor,
    basic_lvewx128,
    basic_lvlx128,
    basic_lvlxl128,
    basic_lvrx128,
    basic_lvrxl128,
    basic_lvsl128,
    basic_lvsr128,
    basic_lvx128,
    basic_lvxl128,
    basic_stvewx128,
    basic_stvlx128,
    basic_stvlxl128,
    basic_stvrx128,
    basic_stvrxl128,
    basic_stvx128,
    basic_stvxl128,
    basic_vsldoi128,
    basic_vaddfp128,
    basic_vand128,
    basic_vandc128,
    basic_vmaddcfp128,
    basic_vmaddfp128,
    basic_vmsum3fp128,
    basic_vmsum4fp128,
    basic_vmulfp128,
    basic_vnmsubfp128,
    basic_vnor128,
    basic_vor128,
    basic_vperm128,
    basic_vpkshss128,
    basic_vpkshus128,
    basic_vpkswss128,
    basic_vpkswus128,
    basic_vpkuhum128,
    basic_vpkuhus128,
    basic_vpkuwum128,
    basic_vpkuwus128,
    basic_vsel128,
    basic_vslo128,
    basic_vsro128,
    basic_vsubfp128,
    basic_vxor128,
    basic_vctsxs128,
    basic_vctuxs128,
    basic_vcmpbfp128,
    basic_vcmpeqfp128,
    basic_vcmpequw128,
    basic_vcmpgefp128,
    basic_vcmpgtfp128,
    basic_vcfsx128,
    basic_vcfux128,
    basic_vexptefp128,
    basic_vlogefp128,
    basic_vmaxfp128,
    basic_vminfp128,
    basic_vmrghw128,
    basic_vmrglw128,
    basic_vpermwi128,
    basic_vpkd3d128,
    basic_vrefp128,
    basic_vrfim128,
    basic_vrfin128,
    basic_vrfip128,
    basic_vrfiz128,
    basic_vrlimi128,
    basic_vrlw128,
    basic_vrsqrtefp128,
    basic_vslw128,
    basic_vspltisw128,
    basic_vspltw128,
    basic_vsraw128,
    basic_vsrw128,
    basic_vupkd3d128,
    basic_vupkhsb128,
    basic_vupkhsh128,
    basic_vupklsb128,
    basic_vupklsh128,
    basic_mulli,
    basic_subfic,
    basic_cmpli,
    basic_cmpi,
    basic_addic,
    basic_addic_,
    basic_addi,
    basic_addis,
    basic_bc,
    basic_sc,
    basic_b,
    basic_bcctr,
    basic_bclr,
    basic_crand,
    basic_crandc,
    basic_creqv,
    basic_crnand,
    basic_crnor,
    basic_cror,
    basic_crorc,
    basic_crxor,
    basic_isync,
    basic_mcrf,
    basic_rfi,
    basic_rfid,
    basic_rlwimi,
    basic_rlwinm,
    basic_rlwnm,
    basic_ori,
    basic_oris,
    basic_xori,
    basic_xoris,
    basic_andi_,
    basic_andis_,
    basic_rldcl,
    basic_rldcr,
    basic_rldic,
    basic_rldicl,
    basic_rldicr,
    basic_rldimi,
    basic_add,
    basic_addc,
    basic_adde,
    basic_addme,
    basic_addze,
    basic_and,
    basic_andc,
    basic_cmp,
    basic_cmpl,
    basic_cntlzw,
    basic_dcbf,
    basic_dcbi,
    basic_dcbst,
    basic_dcbt,
    basic_dcbtst,
    basic_dcbz,
    basic_divw,
    basic_divwu,
    basic_eciwx,
    basic_ecowx,
    basic_eieio,
    basic_eqv,
    basic_extsb,
    basic_extsh,
    basic_icbi,
    basic_lbzux,
    basic_lbzx,
    basic_lfdux,
    basic_lfdx,
    basic_lfsux,
    basic_lfsx,
    basic_lhaux,
    basic_lhax,
    basic_lhbrx,
    basic_lhzux,
    basic_lhzx,
    basic_lswi,
    basic_lswx,
    basic_lwarx,
    basic_lwbrx,
    basic_lwzux,
    basic_lwzx,
    basic_mcrxr,
    basic_mfcr,
    basic_mfmsr,
    basic_mfspr,
    basic_mfsr,
    basic_mfsrin,
    basic_mftb,
    basic_mtcrf,
    basic_mtmsr,
    basic_mtspr,
    basic_mtsr,
    basic_mtsrin,
    basic_mulhw,
    basic_mulhwu,
    basic_mullw,
    basic_nand,
    basic_neg,
    basic_nor,
    basic_or,
    basic_orc,
    basic_slw,
    basic_sraw,
    basic_srawi,
    basic_srw,
    basic_stbux,
    basic_stbx,
    basic_stfdux,
    basic_stfdx,
    basic_stfiwx,
    basic_stfsux,
    basic_stfsx,
    basic_sthbrx,
    basic_sthux,
    basic_sthx,
    basic_stswi,
    basic_stswx,
    basic_stwbrx,
    basic_stwcx_,
    basic_stwux,
    basic_stwx,
    basic_subf,
    basic_subfc,
    basic_subfe,
    basic_subfme,
    basic_subfze,
    basic_sync,
    basic_tlbie,
    basic_tlbsync,
    basic_tw,
    basic_xor,
    basic_cntlzd,
    basic_dcbzl,
    basic_divd,
    basic_divdu,
    basic_extsw,
    basic_ldarx,
    basic_ldux,
    basic_ldx,
    basic_lwaux,
    basic_lwax,
    basic_mfocrf,
    basic_mtmsrd,
    basic_mtsrd,
    basic_mtsrdin,
    basic_mulhd,
    basic_mulhdu,
    basic_mulld,
    basic_slbia,
    basic_slbie,
    basic_sld,
    basic_srad,
    basic_sradi,
    basic_srd,
    basic_stdcx_,
    basic_stdux,
    basic_stdx,
    basic_td,
    basic_dss,
    basic_dst,
    basic_dstst,
    basic_lvebx,
    basic_lvehx,
    basic_lvewx,
    basic_lvlx,
    basic_lvlxl,
    basic_lvrx,
    basic_lvrxl,
    basic_lvsl,
    basic_lvsr,
    basic_lvx,
    basic_lvxl,
    basic_stvebx,
    basic_stvehx,
    basic_stvewx,
    basic_stvlx,
    basic_stvlxl,
    basic_stvrx,
    basic_stvrxl,
    basic_stvx,
    basic_stvxl,
    basic_lwz,
    basic_lwzu,
    basic_lbz,
    basic_lbzu,
    basic_stw,
    basic_stwu,
    basic_stb,
    basic_stbu,
    basic_lhz,
    basic_lhzu,
    basic_lha,
    basic_lhau,
    basic_sth,
    basic_sthu,
    basic_lmw,
    basic_stmw,
    basic_lfs,
    basic_lfsu,
    basic_lfd,
    basic_lfdu,
    basic_stfs,
    basic_stfsu,
    basic_stfd,
    basic_stfdu,
    basic_psq_l,
    basic_psq_lu,
    basic_ld,
    basic_ldu,
    basic_lwa,
    basic_fadds,
    basic_fdivs,
    basic_fmadds,
    basic_fmsubs,
    basic_fmuls,
    basic_fnmadds,
    basic_fnmsubs,
    basic_fres,
    basic_fsubs,
    basic_fsqrts,
    basic_psq_st,
    basic_psq_stu,
    basic_std,
    basic_stdu,
    basic_fabs,
    basic_fadd,
    basic_fcmpo,
    basic_fcmpu,
    basic_fctiw,
    basic_fctiwz,
    basic_fdiv,
    basic_fmadd,
    basic_fmr,
    basic_fmsub,
    basic_fmul,
    basic_fnabs,
    basic_fneg,
    basic_fnmadd,
    basic_fnmsub,
    basic_frsp,
    basic_frsqrte,
    basic_fsel,
    basic_fsub,
    basic_mcrfs,
    basic_mffs,
    basic_mtfsb0,
    basic_mtfsb1,
    basic_mtfsf,
    basic_mtfsfi,
    basic_fcfid,
    basic_fctid,
    basic_fctidz,
    basic_fsqrt,
];
pub(crate) fn parse_basic(out: &mut ParsedIns, ins: Ins) {
    match BASIC_MNEMONICS.get(ins.op as usize) {
        Some(f) => f(out, ins),
        None => mnemonic_illegal(out, ins),
    }
}
static SIMPLIFIED_MNEMONICS: [MnemonicFunction; 511] = [
    simplified_tdi,
    simplified_twi,
    basic_dcbz_l,
    basic_psq_lux,
    basic_psq_lx,
    basic_psq_stux,
    basic_psq_stx,
    basic_ps_abs,
    basic_ps_add,
    basic_ps_cmpo0,
    basic_ps_cmpo1,
    basic_ps_cmpu0,
    basic_ps_cmpu1,
    basic_ps_div,
    basic_ps_madd,
    basic_ps_madds0,
    basic_ps_madds1,
    basic_ps_merge00,
    basic_ps_merge01,
    basic_ps_merge10,
    basic_ps_merge11,
    basic_ps_mr,
    basic_ps_msub,
    basic_ps_mul,
    basic_ps_muls0,
    basic_ps_muls1,
    basic_ps_nabs,
    basic_ps_neg,
    basic_ps_nmadd,
    basic_ps_nmsub,
    basic_ps_res,
    basic_ps_rsqrte,
    basic_ps_sel,
    basic_ps_sub,
    basic_ps_sum0,
    basic_ps_sum1,
    basic_mfvscr,
    basic_mtvscr,
    basic_vaddcuw,
    basic_vaddfp,
    basic_vaddsbs,
    basic_vaddshs,
    basic_vaddsws,
    basic_vaddubm,
    basic_vaddubs,
    basic_vadduhm,
    basic_vadduhs,
    basic_vadduwm,
    basic_vadduws,
    basic_vand,
    basic_vandc,
    basic_vavgsb,
    basic_vavgsh,
    basic_vavgsw,
    basic_vavgub,
    basic_vavguh,
    basic_vavguw,
    basic_vcfsx,
    basic_vcfux,
    basic_vcmpbfp,
    basic_vcmpeqfp,
    basic_vcmpequb,
    basic_vcmpequh,
    basic_vcmpequw,
    basic_vcmpgefp,
    basic_vcmpgtfp,
    basic_vcmpgtsb,
    basic_vcmpgtsh,
    basic_vcmpgtsw,
    basic_vcmpgtub,
    basic_vcmpgtuh,
    basic_vcmpgtuw,
    basic_vctsxs,
    basic_vctuxs,
    basic_vexptefp,
    basic_vlogefp,
    basic_vmaddfp,
    basic_vmaxfp,
    basic_vmaxsb,
    basic_vmaxsh,
    basic_vmaxsw,
    basic_vmaxub,
    basic_vmaxuh,
    basic_vmaxuw,
    basic_vmhaddshs,
    basic_vmhraddshs,
    basic_vminfp,
    basic_vminsb,
    basic_vminsh,
    basic_vminsw,
    basic_vminub,
    basic_vminuh,
    basic_vminuw,
    basic_vmladduhm,
    basic_vmrghb,
    basic_vmrghh,
    basic_vmrghw,
    basic_vmrglb,
    basic_vmrglh,
    basic_vmrglw,
    basic_vmsummbm,
    basic_vmsumshm,
    basic_vmsumshs,
    basic_vmsumubm,
    basic_vmsumuhm,
    basic_vmsumuhs,
    basic_vmulesb,
    basic_vmulesh,
    basic_vmuleub,
    basic_vmuleuh,
    basic_vmulosb,
    basic_vmulosh,
    basic_vmuloub,
    basic_vmulouh,
    basic_vnmsubfp,
    simplified_vnor,
    simplified_vor,
    basic_vperm,
    basic_vpkpx,
    basic_vpkshss,
    basic_vpkshus,
    basic_vpkswss,
    basic_vpkswus,
    basic_vpkuhum,
    basic_vpkuhus,
    basic_vpkuwum,
    basic_vpkuwus,
    basic_vrefp,
    basic_vrfim,
    basic_vrfin,
    basic_vrfip,
    basic_vrfiz,
    basic_vrlb,
    basic_vrlh,
    basic_vrlw,
    basic_vrsqrtefp,
    basic_vsel,
    basic_vsl,
    basic_vslb,
    basic_vsldoi,
    basic_vslh,
    basic_vslo,
    basic_vslw,
    basic_vspltb,
    basic_vsplth,
    basic_vspltisb,
    basic_vspltish,
    basic_vspltisw,
    basic_vspltw,
    basic_vsr,
    basic_vsrab,
    basic_vsrah,
    basic_vsraw,
    basic_vsrb,
    basic_vsrh,
    basic_vsro,
    basic_vsrw,
    basic_vsubcuw,
    basic_vsubfp,
    basic_vsubsbs,
    basic_vsubshs,
    basic_vsubsws,
    basic_vsububm,
    basic_vsububs,
    basic_vsubuhm,
    basic_vsubuhs,
    basic_vsubuwm,
    basic_vsubuws,
    basic_vsumsws,
    basic_vsum2sws,
    basic_vsum4sbs,
    basic_vsum4shs,
    basic_vsum4ubs,
    basic_vupkhpx,
    basic_vupkhsb,
    basic_vupkhsh,
    basic_vupklpx,
    basic_vupklsb,
    basic_vupklsh,
    basic_vxor,
    basic_lvewx128,
    basic_lvlx128,
    basic_lvlxl128,
    basic_lvrx128,
    basic_lvrxl128,
    basic_lvsl128,
    basic_lvsr128,
    basic_lvx128,
    basic_lvxl128,
    basic_stvewx128,
    basic_stvlx128,
    basic_stvlxl128,
    basic_stvrx128,
    basic_stvrxl128,
    basic_stvx128,
    basic_stvxl128,
    basic_vsldoi128,
    basic_vaddfp128,
    basic_vand128,
    basic_vandc128,
    basic_vmaddcfp128,
    basic_vmaddfp128,
    basic_vmsum3fp128,
    basic_vmsum4fp128,
    basic_vmulfp128,
    basic_vnmsubfp128,
    basic_vnor128,
    basic_vor128,
    basic_vperm128,
    basic_vpkshss128,
    basic_vpkshus128,
    basic_vpkswss128,
    basic_vpkswus128,
    basic_vpkuhum128,
    basic_vpkuhus128,
    basic_vpkuwum128,
    basic_vpkuwus128,
    basic_vsel128,
    basic_vslo128,
    basic_vsro128,
    basic_vsubfp128,
    basic_vxor128,
    basic_vctsxs128,
    basic_vctuxs128,
    basic_vcmpbfp128,
    basic_vcmpeqfp128,
    basic_vcmpequw128,
    basic_vcmpgefp128,
    basic_vcmpgtfp128,
    basic_vcfsx128,
    basic_vcfux128,
    basic_vexptefp128,
    basic_vlogefp128,
    basic_vmaxfp128,
    basic_vminfp128,
    basic_vmrghw128,
    basic_vmrglw128,
    basic_vpermwi128,
    basic_vpkd3d128,
    basic_vrefp128,
    basic_vrfim128,
    basic_vrfin128,
    basic_vrfip128,
    basic_vrfiz128,
    basic_vrlimi128,
    basic_vrlw128,
    basic_vrsqrtefp128,
    basic_vslw128,
    basic_vspltisw128,
    basic_vspltw128,
    basic_vsraw128,
    basic_vsrw128,
    basic_vupkd3d128,
    basic_vupkhsb128,
    basic_vupkhsh128,
    basic_vupklsb128,
    basic_vupklsh128,
    basic_mulli,
    basic_subfic,
    simplified_cmpli,
    simplified_cmpi,
    simplified_addic,
    simplified_addic_,
    simplified_addi,
    simplified_addis,
    simplified_bc,
    basic_sc,
    basic_b,
    simplified_bcctr,
    simplified_bclr,
    basic_crand,
    basic_crandc,
    simplified_creqv,
    basic_crnand,
    simplified_crnor,
    simplified_cror,
    basic_crorc,
    simplified_crxor,
    basic_isync,
    basic_mcrf,
    basic_rfi,
    basic_rfid,
    basic_rlwimi,
    simplified_rlwinm,
    simplified_rlwnm,
    simplified_ori,
    basic_oris,
    basic_xori,
    basic_xoris,
    basic_andi_,
    basic_andis_,
    simplified_rldcl,
    basic_rldcr,
    basic_rldic,
    basic_rldicl,
    basic_rldicr,
    basic_rldimi,
    basic_add,
    basic_addc,
    basic_adde,
    basic_addme,
    basic_addze,
    basic_and,
    basic_andc,
    simplified_cmp,
    simplified_cmpl,
    basic_cntlzw,
    basic_dcbf,
    basic_dcbi,
    basic_dcbst,
    basic_dcbt,
    basic_dcbtst,
    basic_dcbz,
    basic_divw,
    basic_divwu,
    basic_eciwx,
    basic_ecowx,
    basic_eieio,
    basic_eqv,
    basic_extsb,
    basic_extsh,
    basic_icbi,
    basic_lbzux,
    basic_lbzx,
    basic_lfdux,
    basic_lfdx,
    basic_lfsux,
    basic_lfsx,
    basic_lhaux,
    basic_lhax,
    basic_lhbrx,
    basic_lhzux,
    basic_lhzx,
    basic_lswi,
    basic_lswx,
    basic_lwarx,
    basic_lwbrx,
    basic_lwzux,
    basic_lwzx,
    basic_mcrxr,
    basic_mfcr,
    basic_mfmsr,
    simplified_mfspr,
    basic_mfsr,
    basic_mfsrin,
    basic_mftb,
    basic_mtcrf,
    basic_mtmsr,
    simplified_mtspr,
    basic_mtsr,
    basic_mtsrin,
    basic_mulhw,
    basic_mulhwu,
    basic_mullw,
    basic_nand,
    basic_neg,
    basic_nor,
    simplified_or,
    basic_orc,
    basic_slw,
    basic_sraw,
    basic_srawi,
    basic_srw,
    basic_stbux,
    basic_stbx,
    basic_stfdux,
    basic_stfdx,
    basic_stfiwx,
    basic_stfsux,
    basic_stfsx,
    basic_sthbrx,
    basic_sthux,
    basic_sthx,
    basic_stswi,
    basic_stswx,
    basic_stwbrx,
    basic_stwcx_,
    basic_stwux,
    basic_stwx,
    basic_subf,
    basic_subfc,
    basic_subfe,
    basic_subfme,
    basic_subfze,
    simplified_sync,
    basic_tlbie,
    basic_tlbsync,
    simplified_tw,
    basic_xor,
    basic_cntlzd,
    basic_dcbzl,
    basic_divd,
    basic_divdu,
    basic_extsw,
    basic_ldarx,
    basic_ldux,
    basic_ldx,
    basic_lwaux,
    basic_lwax,
    basic_mfocrf,
    basic_mtmsrd,
    basic_mtsrd,
    basic_mtsrdin,
    basic_mulhd,
    basic_mulhdu,
    basic_mulld,
    basic_slbia,
    basic_slbie,
    basic_sld,
    basic_srad,
    basic_sradi,
    basic_srd,
    basic_stdcx_,
    basic_stdux,
    basic_stdx,
    simplified_td,
    simplified_dss,
    basic_dst,
    basic_dstst,
    basic_lvebx,
    basic_lvehx,
    basic_lvewx,
    basic_lvlx,
    basic_lvlxl,
    basic_lvrx,
    basic_lvrxl,
    basic_lvsl,
    basic_lvsr,
    basic_lvx,
    basic_lvxl,
    basic_stvebx,
    basic_stvehx,
    basic_stvewx,
    basic_stvlx,
    basic_stvlxl,
    basic_stvrx,
    basic_stvrxl,
    basic_stvx,
    basic_stvxl,
    basic_lwz,
    basic_lwzu,
    basic_lbz,
    basic_lbzu,
    basic_stw,
    basic_stwu,
    basic_stb,
    basic_stbu,
    basic_lhz,
    basic_lhzu,
    basic_lha,
    basic_lhau,
    basic_sth,
    basic_sthu,
    basic_lmw,
    basic_stmw,
    basic_lfs,
    basic_lfsu,
    basic_lfd,
    basic_lfdu,
    basic_stfs,
    basic_stfsu,
    basic_stfd,
    basic_stfdu,
    basic_psq_l,
    basic_psq_lu,
    basic_ld,
    basic_ldu,
    basic_lwa,
    basic_fadds,
    basic_fdivs,
    basic_fmadds,
    basic_fmsubs,
    basic_fmuls,
    basic_fnmadds,
    basic_fnmsubs,
    basic_fres,
    basic_fsubs,
    basic_fsqrts,
    basic_psq_st,
    basic_psq_stu,
    basic_std,
    basic_stdu,
    basic_fabs,
    basic_fadd,
    basic_fcmpo,
    basic_fcmpu,
    basic_fctiw,
    basic_fctiwz,
    basic_fdiv,
    basic_fmadd,
    basic_fmr,
    basic_fmsub,
    basic_fmul,
    basic_fnabs,
    basic_fneg,
    basic_fnmadd,
    basic_fnmsub,
    basic_frsp,
    basic_frsqrte,
    basic_fsel,
    basic_fsub,
    basic_mcrfs,
    basic_mffs,
    basic_mtfsb0,
    basic_mtfsb1,
    basic_mtfsf,
    basic_mtfsfi,
    basic_fcfid,
    basic_fctid,
    basic_fctidz,
    basic_fsqrt,
];
pub(crate) fn parse_simplified(out: &mut ParsedIns, ins: Ins) {
    match SIMPLIFIED_MNEMONICS.get(ins.op as usize) {
        Some(f) => f(out, ins),
        None => mnemonic_illegal(out, ins),
    }
}
type DefsUsesFunction = fn(&mut Arguments, Ins);
fn uses_tdi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dcbz_l(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_psq_lux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_psq_lux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_psq_lx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_psq_stux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_psq_stx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_abs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_add(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_ps_cmpo0(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_cmpo0(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_fra() != 0 {
            Argument::FPR(FPR(ins.field_fra() as _))
        } else {
            Argument::None
        },
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_madd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::FPR(FPR(ins.field_frb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_ps_mul(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_fra() as _)),
        Argument::FPR(FPR(ins.field_frc() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mfvscr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_vd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtvscr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vaddcuw(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_va() as _)),
        Argument::VR(VR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vcfsx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_vb() as _)),
        Argument::Uimm(Uimm(ins.field_vuimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmaddfp(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_va() as _)),
        Argument::VR(VR(ins.field_vc() as _)),
        Argument::VR(VR(ins.field_vb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_vmhaddshs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_va() as _)),
        Argument::VR(VR(ins.field_vb() as _)),
        Argument::VR(VR(ins.field_vc() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsldoi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_va() as _)),
        Argument::VR(VR(ins.field_vb() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_shb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_vspltisb(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Simm(Simm(ins.field_vsimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_lvewx128(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_vds128() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vsldoi128(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_va128() as _)),
        Argument::VR(VR(ins.field_vb128() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vperm128(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_va128() as _)),
        Argument::VR(VR(ins.field_vb128() as _)),
        Argument::VR(VR(ins.field_vc128() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_vctsxs128(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_vb128() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_vpkd3d128(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_vb128() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_d3dtype() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_vmask() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_zimm() as _)),
        Argument::None,
    ];
}
fn uses_vupkd3d128(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::VR(VR(ins.field_vb128() as _)),
        Argument::Uimm(Uimm(ins.field_vuimm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mulli(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_addi(out: &mut Arguments, ins: Ins) {
    *out = [
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_crand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crbd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_crand(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRBit(CRBit(ins.field_crba() as _)),
        Argument::CRBit(CRBit(ins.field_crbb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mcrf(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rlwimi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rlwinm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_rlwnm(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_andi_(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_ecowx(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn defs_lbzux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rd() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_mcrxr(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::CRField(CRField(ins.field_crfd() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stbux(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_stswi(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_sync(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::OpaqueU(OpaqueU(ins.field_sync_l() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_mtmsrd(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_mtmsrd_l() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dss(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::OpaqueU(OpaqueU(ins.field_strm() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_dst(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::GPR(GPR(ins.field_rb() as _)),
        Argument::OpaqueU(OpaqueU(ins.field_strm() as _)),
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwz(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_lwzu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::Offset(Offset(ins.field_offset() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stwu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::GPR(GPR(ins.field_rs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfs(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        if ins.field_ra() != 0 {
            Argument::GPR(GPR(ins.field_ra() as _))
        } else {
            Argument::None
        },
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn uses_stfsu(out: &mut Arguments, ins: Ins) {
    *out = [
        Argument::FPR(FPR(ins.field_frs() as _)),
        Argument::GPR(GPR(ins.field_ra() as _)),
        Argument::None,
        Argument::None,
        Argument::None,
    ];
}
fn defs_uses_empty(out: &mut Arguments, _ins: Ins) {
    *out = EMPTY_ARGS;
}
static DEFS_FUNCTIONS: [DefsUsesFunction; 511] = [
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_psq_lux,
    defs_psq_lx,
    uses_tdi,
    defs_uses_empty,
    defs_psq_lx,
    defs_psq_lx,
    defs_ps_cmpo0,
    defs_ps_cmpo0,
    defs_ps_cmpo0,
    defs_ps_cmpo0,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_mfvscr,
    defs_uses_empty,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_lvewx128,
    defs_mulli,
    defs_mulli,
    defs_ps_cmpo0,
    defs_ps_cmpo0,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_crand,
    defs_crand,
    defs_crand,
    defs_crand,
    defs_crand,
    defs_crand,
    defs_crand,
    defs_crand,
    defs_uses_empty,
    defs_ps_cmpo0,
    defs_uses_empty,
    defs_uses_empty,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    uses_tdi,
    uses_tdi,
    defs_ps_cmpo0,
    defs_ps_cmpo0,
    uses_tdi,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_uses_empty,
    defs_uses_empty,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    defs_uses_empty,
    defs_lbzux,
    defs_mulli,
    defs_psq_lux,
    defs_psq_lx,
    defs_psq_lux,
    defs_psq_lx,
    defs_lbzux,
    defs_mulli,
    defs_mulli,
    defs_lbzux,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_lbzux,
    defs_mulli,
    defs_mcrxr,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    uses_tdi,
    defs_mulli,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    defs_uses_empty,
    uses_tdi,
    defs_uses_empty,
    defs_uses_empty,
    uses_tdi,
    defs_uses_empty,
    defs_uses_empty,
    uses_tdi,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    uses_tdi,
    defs_uses_empty,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    uses_tdi,
    uses_tdi,
    defs_uses_empty,
    defs_mulli,
    defs_mulli,
    uses_tdi,
    defs_mulli,
    defs_lbzux,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_mulli,
    defs_mulli,
    defs_mulli,
    defs_uses_empty,
    defs_uses_empty,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    defs_uses_empty,
    uses_tdi,
    uses_tdi,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_mfvscr,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_mulli,
    defs_lbzux,
    defs_mulli,
    defs_lbzux,
    defs_uses_empty,
    uses_tdi,
    defs_uses_empty,
    uses_tdi,
    defs_mulli,
    defs_lbzux,
    defs_mulli,
    defs_lbzux,
    defs_uses_empty,
    uses_tdi,
    defs_mulli,
    defs_uses_empty,
    defs_psq_lx,
    defs_psq_lux,
    defs_psq_lx,
    defs_psq_lux,
    defs_uses_empty,
    uses_tdi,
    defs_uses_empty,
    uses_tdi,
    defs_psq_lx,
    defs_psq_lux,
    defs_mulli,
    defs_lbzux,
    defs_mulli,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_uses_empty,
    uses_tdi,
    defs_uses_empty,
    uses_tdi,
    defs_psq_lx,
    defs_psq_lx,
    defs_ps_cmpo0,
    defs_ps_cmpo0,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_ps_cmpo0,
    defs_psq_lx,
    defs_crand,
    defs_crand,
    defs_uses_empty,
    defs_ps_cmpo0,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
    defs_psq_lx,
];
pub(crate) fn parse_defs(out: &mut Arguments, ins: Ins) {
    match DEFS_FUNCTIONS.get(ins.op as usize) {
        Some(f) => f(out, ins),
        None => defs_uses_empty(out, ins),
    }
}
static USES_FUNCTIONS: [DefsUsesFunction; 511] = [
    uses_tdi,
    uses_tdi,
    uses_dcbz_l,
    uses_psq_lux,
    uses_dcbz_l,
    uses_psq_stux,
    uses_psq_stx,
    uses_ps_abs,
    uses_ps_add,
    uses_ps_cmpo0,
    uses_ps_cmpo0,
    uses_ps_cmpo0,
    uses_ps_cmpo0,
    uses_ps_add,
    uses_ps_madd,
    uses_ps_madd,
    uses_ps_madd,
    uses_ps_add,
    uses_ps_add,
    uses_ps_add,
    uses_ps_add,
    uses_ps_abs,
    uses_ps_madd,
    uses_ps_mul,
    uses_ps_mul,
    uses_ps_mul,
    uses_ps_abs,
    uses_ps_abs,
    uses_ps_madd,
    uses_ps_madd,
    uses_ps_abs,
    uses_ps_abs,
    uses_ps_madd,
    uses_ps_add,
    uses_ps_madd,
    uses_ps_madd,
    defs_uses_empty,
    uses_mtvscr,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vcfsx,
    uses_vcfsx,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vcfsx,
    uses_vcfsx,
    uses_mtvscr,
    uses_mtvscr,
    uses_vmaddfp,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vmhaddshs,
    uses_vmhaddshs,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vmhaddshs,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vmhaddshs,
    uses_vmhaddshs,
    uses_vmhaddshs,
    uses_vmhaddshs,
    uses_vmhaddshs,
    uses_vmhaddshs,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vmaddfp,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vmhaddshs,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_mtvscr,
    uses_mtvscr,
    uses_mtvscr,
    uses_mtvscr,
    uses_mtvscr,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_mtvscr,
    uses_vmhaddshs,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vsldoi,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vcfsx,
    uses_vcfsx,
    uses_vspltisb,
    uses_vspltisb,
    uses_vspltisb,
    uses_vcfsx,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_vaddcuw,
    uses_mtvscr,
    uses_mtvscr,
    uses_mtvscr,
    uses_mtvscr,
    uses_mtvscr,
    uses_mtvscr,
    uses_vaddcuw,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vperm128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vctsxs128,
    uses_vpkd3d128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_vsldoi128,
    uses_vctsxs128,
    uses_vsldoi128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_vsldoi128,
    uses_vsldoi128,
    uses_vupkd3d128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_vctsxs128,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_tdi,
    uses_addi,
    uses_addi,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    uses_crand,
    uses_crand,
    uses_crand,
    uses_crand,
    uses_crand,
    uses_crand,
    uses_crand,
    uses_crand,
    defs_uses_empty,
    uses_mcrf,
    defs_uses_empty,
    defs_uses_empty,
    uses_rlwimi,
    uses_rlwinm,
    uses_rlwnm,
    uses_rlwinm,
    uses_rlwinm,
    uses_rlwinm,
    uses_rlwinm,
    uses_andi_,
    uses_andi_,
    uses_rlwnm,
    uses_rlwnm,
    uses_rlwinm,
    uses_rlwinm,
    uses_rlwinm,
    uses_rlwinm,
    uses_psq_lux,
    uses_psq_lux,
    uses_psq_lux,
    uses_tdi,
    uses_tdi,
    uses_rlwnm,
    uses_rlwnm,
    uses_psq_lux,
    uses_psq_lux,
    uses_rlwinm,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_psq_lux,
    uses_psq_lux,
    uses_dcbz_l,
    uses_ecowx,
    defs_uses_empty,
    uses_rlwnm,
    uses_rlwinm,
    uses_rlwinm,
    uses_dcbz_l,
    uses_psq_lux,
    uses_dcbz_l,
    uses_psq_lux,
    uses_dcbz_l,
    uses_psq_lux,
    uses_dcbz_l,
    uses_psq_lux,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_psq_lux,
    uses_dcbz_l,
    uses_addi,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_psq_lux,
    uses_dcbz_l,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    uses_andi_,
    defs_uses_empty,
    uses_rlwinm,
    uses_rlwinm,
    uses_rlwinm,
    uses_rlwinm,
    uses_rlwnm,
    uses_psq_lux,
    uses_psq_lux,
    uses_psq_lux,
    uses_rlwnm,
    uses_tdi,
    uses_rlwnm,
    uses_rlwnm,
    uses_rlwnm,
    uses_rlwnm,
    uses_rlwnm,
    uses_rlwinm,
    uses_psq_lux,
    uses_stbux,
    uses_ecowx,
    uses_psq_stux,
    uses_psq_stx,
    uses_psq_stx,
    uses_psq_stux,
    uses_psq_stx,
    uses_ecowx,
    uses_stbux,
    uses_ecowx,
    uses_stswi,
    uses_ecowx,
    uses_ecowx,
    uses_ecowx,
    uses_stbux,
    uses_ecowx,
    uses_psq_lux,
    uses_psq_lux,
    uses_psq_lux,
    uses_tdi,
    uses_tdi,
    uses_sync,
    uses_andi_,
    defs_uses_empty,
    uses_psq_lux,
    uses_rlwnm,
    uses_rlwinm,
    uses_dcbz_l,
    uses_psq_lux,
    uses_psq_lux,
    uses_rlwinm,
    uses_psq_lux,
    uses_psq_lux,
    uses_dcbz_l,
    uses_psq_lux,
    uses_dcbz_l,
    defs_uses_empty,
    uses_mtmsrd,
    uses_rlwinm,
    uses_rlwnm,
    uses_psq_lux,
    uses_psq_lux,
    uses_psq_lux,
    defs_uses_empty,
    uses_andi_,
    uses_rlwnm,
    uses_rlwnm,
    uses_rlwinm,
    uses_psq_lux,
    uses_ecowx,
    uses_stbux,
    uses_ecowx,
    uses_psq_lux,
    uses_dss,
    uses_dst,
    uses_dst,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_dcbz_l,
    uses_lwz,
    uses_lwzu,
    uses_lwz,
    uses_lwzu,
    uses_stswi,
    uses_stwu,
    uses_stswi,
    uses_stwu,
    uses_lwz,
    uses_lwzu,
    uses_lwz,
    uses_lwzu,
    uses_stswi,
    uses_stwu,
    uses_lwz,
    uses_stswi,
    uses_lwz,
    uses_lwzu,
    uses_lwz,
    uses_lwzu,
    uses_stfs,
    uses_stfsu,
    uses_stfs,
    uses_stfsu,
    uses_addi,
    uses_tdi,
    uses_addi,
    uses_tdi,
    uses_addi,
    uses_ps_add,
    uses_ps_add,
    uses_ps_madd,
    uses_ps_madd,
    uses_ps_mul,
    uses_ps_madd,
    uses_ps_madd,
    uses_ps_abs,
    uses_ps_add,
    uses_ps_abs,
    uses_stfs,
    uses_stfsu,
    uses_stswi,
    uses_stwu,
    uses_ps_abs,
    uses_ps_add,
    uses_ps_add,
    uses_ps_add,
    uses_ps_abs,
    uses_ps_abs,
    uses_ps_add,
    uses_ps_madd,
    uses_ps_abs,
    uses_ps_madd,
    uses_ps_mul,
    uses_ps_abs,
    uses_ps_abs,
    uses_ps_madd,
    uses_ps_madd,
    uses_ps_abs,
    uses_ps_abs,
    uses_ps_madd,
    uses_ps_add,
    uses_mcrf,
    defs_uses_empty,
    defs_uses_empty,
    defs_uses_empty,
    uses_ps_abs,
    defs_uses_empty,
    uses_ps_abs,
    uses_ps_abs,
    uses_ps_abs,
    uses_ps_abs,
];
pub(crate) fn parse_uses(out: &mut Arguments, ins: Ins) {
    match USES_FUNCTIONS.get(ins.op as usize) {
        Some(f) => f(out, ins),
        None => defs_uses_empty(out, ins),
    }
}
